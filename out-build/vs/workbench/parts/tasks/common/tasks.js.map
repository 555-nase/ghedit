{"version":3,"sources":["vs/workbench/parts/tasks/common/tasks.ts"],"names":[],"mappings":"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","file":"vs/workbench/parts/tasks/common/tasks.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport NLS = require('vs/nls');\n\nimport { IStringDictionary } from 'vs/base/common/collections';\nimport * as Types from 'vs/base/common/types';\nimport * as UUID from 'vs/base/common/uuid';\n\nimport { ValidationStatus, ValidationState, ILogger, Parser } from 'vs/base/common/parsers';\nimport { Executable, ExecutableParser, Config  as ProcessConfig} from 'vs/base/common/processes';\n\nimport { ProblemMatcher, Config as ProblemMatcherConfig, ProblemMatcherParser } from 'vs/platform/markers/common/problemMatcher';\n\nexport namespace Config {\n\n\t/**\n\t * The description of a task.\n\t */\n\texport interface Task {\n\n\t\t/**\n\t\t * The task's name.\n\t\t */\n\t\tname?: string;\n\n\t\t/**\n\t\t * The trigger to automatically activate the task.\n\t\t */\n\t\ttrigger?: string | string[];\n\n\t\t/**\n\t\t * The executable\n\t\t */\n\t\texecutable?: ProcessConfig.Executable;\n\n\t\t/**\n\t\t * Whether the executed command is kept alive and is watching the file system.\n\t\t */\n\t\tisWatching?: boolean;\n\n\t\t/**\n\t\t * Whether the task should prompt on close for confirmation if running.\n\t\t */\n\t\tpromptOnClose?: boolean;\n\n\t\t/**\n\t\t * Controls whether the output view of the running tasks is brought to front or not.\n\t\t * See BaseTaskRunnerConfiguration#showOutput for details.\n\t\t*/\n\t\tshowOutput?: string;\n\n\t\t/**\n\t\t * Controls whether the executed command is printed to the output window as well.\n\t\t */\n\t\techoCommand?: boolean;\n\n\t\t/**\n\t\t * Settings to control the task\n\t\t */\n\t\tsettings?: string;\n\n\t\t/**\n\t\t * The problem matcher(s) to use to capture problems in the tasks\n\t\t * output.\n\t\t */\n\t\tproblemMatcher?: ProblemMatcherConfig.ProblemMatcherType;\n\n\t}\n}\n\nexport enum ShowOutput {\n\tAlways,\n\tSilent,\n\tNever\n}\n\nexport namespace ShowOutput {\n\texport function fromString(value: string): ShowOutput {\n\t\tvalue = value.toLowerCase();\n\t\tif (value === 'always') {\n\t\t\treturn ShowOutput.Always;\n\t\t} else if (value === 'silent') {\n\t\t\treturn ShowOutput.Silent;\n\t\t} else if (value === 'never') {\n\t\t\treturn ShowOutput.Never;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\n/**\n * The description of a task.\n */\nexport interface Task {\n\n\t/**\n\t * The task's internal id\n\t */\n\tid: string;\n\n\t/**\n\t * The task's name\n\t */\n\tname?: string;\n\n\t/**\n\t * The trigger to automatically activate the task.\n\t */\n\ttrigger?: string[];\n\n\t/**\n\t * The executable\n\t */\n\texecutable: Executable;\n\n\t/**\n\t * Whether the executed command is kept alive and is watching the file system.\n\t */\n\tisWatching: boolean;\n\n\t/**\n\t * Whether the task should prompt on close for confirmation if running.\n\t */\n\tpromptOnClose?: boolean;\n\n\t/**\n\t * Controls whether the output view of the running tasks is brought to front or not.\n\t * See BaseTaskRunnerConfiguration#showOutput for details.\n\t */\n\tshowOutput: ShowOutput;\n\n\t/**\n\t * Controls whether the executed command is printed to the output window as well.\n\t */\n\techoCommand: boolean;\n\n\t/**\n\t * Settings to control the task\n\t */\n\tsettings: string;\n\n\t/**\n\t * The problem matcher(s) to use to capture problems in the tasks\n\t * output.\n\t */\n\tproblemMatcher: ProblemMatcher[];\n}\n\nexport interface ParserSettings {\n\tglobals?: Executable;\n\temptyExecutable?: boolean;\n\temptyCommand?: boolean;\n}\n\nexport class TaskParser  extends Parser {\n\n\tprivate resolver: { get(name: string): ProblemMatcher; };\n\n\tconstructor(resolver: { get(name: string): ProblemMatcher; }, logger: ILogger, validationStatus: ValidationStatus = new ValidationStatus()) {\n\t\tsuper(logger, validationStatus);\n\t\tthis.resolver = resolver;\n\t}\n\n\tpublic parse(json: Config.Task, parserSettings: ParserSettings = { globals: null, emptyExecutable: false, emptyCommand: false }): Task {\n\t\tlet id: string = UUID.generateUuid();\n\t\tlet name: string = null;\n\t\tlet trigger: string[] = null;\n\t\tlet settings: string = null;\n\n\t\tif (this.is(json.name, Types.isString)) {\n\t\t\tname = json.name;\n\t\t}\n\t\tif (this.is(json.trigger, Types.isString)) {\n\t\t\ttrigger = [<string>json.trigger];\n\t\t} else if (this.is(json.trigger, Types.isStringArray)) {\n\t\t\ttrigger = <string[]>json.trigger;\n\t\t}\n\t\tif (name === null && trigger === null) {\n\t\t\tthis.status.state = ValidationState.Error;\n\t\t\tthis.log(NLS.localize('TaskParser.nameOrTrigger', 'A task must either define a name or a trigger.'));\n\t\t\treturn null;\n\t\t}\n\t\tlet executable: Executable = json.executable ? (new ExecutableParser(this.logger, this.status)).parse(json.executable, { emptyCommand: !!parserSettings.emptyCommand }) : null;\n\t\tif (!executable && parserSettings.globals) {\n\t\t\texecutable = parserSettings.globals;\n\t\t}\n\t\tif (executable === null && !parserSettings.emptyExecutable) {\n\t\t\tthis.status.state = ValidationState.Error;\n\t\t\tthis.log(NLS.localize('TaskParser.noExecutable', 'A task must must define a valid executable.'));\n\t\t\treturn null;\n\t\t}\n\t\tlet isWatching: boolean = false;\n\t\tlet showOutput: ShowOutput = ShowOutput.Always;\n\t\tlet echoCommand: boolean = false;\n\t\tif (this.is(json.isWatching, Types.isBoolean)) {\n\t\t\tisWatching = json.isWatching;\n\t\t}\n\t\tlet promptOnClose: boolean = true;\n\t\tif (this.is(json.promptOnClose, Types.isBoolean)) {\n\t\t\tpromptOnClose = json.promptOnClose;\n\t\t} else {\n\t\t\tpromptOnClose = !isWatching;\n\t\t}\n\t\tif (this.is(json.showOutput, Types.isString)) {\n\t\t\tshowOutput = ShowOutput.fromString(json.showOutput) || ShowOutput.Always;\n\t\t}\n\t\tif (this.is(json.echoCommand, Types.isBoolean)) {\n\t\t\techoCommand = json.echoCommand;\n\t\t}\n\t\tif (this.is(json.settings, Types.isString)) {\n\t\t\tsettings = json.settings;\n\t\t}\n\n\t\tlet problemMatcher: ProblemMatcher[] = [];\n\t\tif (Types.isArray(json.problemMatcher)) {\n\t\t\t(<(string | ProblemMatcherConfig.ProblemMatcher)[]>json.problemMatcher).forEach((value) => {\n\t\t\t\tlet matcher = this.parseProblemMatcher(value);\n\t\t\t\tif (matcher) {\n\t\t\t\t\tproblemMatcher.push(matcher);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tlet matcher = this.parseProblemMatcher(json.problemMatcher);\n\t\t\tif (matcher) {\n\t\t\t\tproblemMatcher.push(matcher);\n\t\t\t}\n\t\t}\n\t\treturn { id, name, trigger, executable, isWatching, promptOnClose, showOutput, echoCommand, settings, problemMatcher };\n\t}\n\n\tprivate parseProblemMatcher(json: string | ProblemMatcherConfig.ProblemMatcher): ProblemMatcher {\n\t\tif (Types.isString(json)) {\n\t\t\treturn json.length > 0 && json.charAt(0) === '$' ? this.resolver.get(json.substr(1)) : null;\n\t\t} else if (Types.isObject(json)) {\n\t\t\treturn new ProblemMatcherParser(this.resolver, this.logger, this.status).parse(<ProblemMatcherConfig.ProblemMatcher>json);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n\n// let tasksExtPoint = ExtensionsRegistry.registerExtensionPoint<Config.Task | Config.Task[]>('tasks', {\n\t// TODO@Dirk: provide JSON schema here\n// });\n\n// const extensionPoint: string = 'tasks';\n\nexport class TaskRegistry {\n\tprivate tasks: IStringDictionary<Task>;\n\n\tconstructor() {\n\t\tthis.tasks = Object.create(null);\n\t\t/*\n\t\ttasksExtPoint.setHandler((extensions, collector) => {\n\t\t\t// TODO@Dirk: validate extension description here and collect errors/warnings with `collector`\n\t\t\textensions.forEach(extension => {\n\t\t\t\tlet extensions = extension.value;\n\t\t\t\tif (Types.isArray(extensions)) {\n\t\t\t\t\t(<Config.Task[]>extensions).forEach(this.onTask, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis.onTask(extensions)\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\t// private onDescriptions(descriptions: IExtensionDescription[]) {\n\t// \tdescriptions.forEach(description => {\n\t// \t\tlet extensions = description.contributes[extensionPoint];\n\t// \t\tif (Types.isArray(extensions)) {\n\t// \t\t\t(<Config.Task[]>extensions).forEach(this.onTask, this);\n\t// \t\t} else {\n\t// \t\t\tthis.onTask(extensions);\n\t// \t\t}\n\t// \t});\n\t// }\n\n\t// private onTask(json: Config.Task): void {\n\t// \tlet logger: ILogger = {\n\t// \t\tlog: (message) => { console.warn(message); }\n\t// \t};\n\t// \tlet parser = new TaskParser(ProblemMatcherRegistry, logger);\n\t// \tlet result = parser.parse(json, { emptyExecutable: true, emptyCommand: true });\n\t// \tthis.add(result);\n\t// }\n\n\tpublic add(task: Task): void {\n\t\tthis.tasks[task.id] = task;\n\t}\n\n\tpublic get(id: string): Task {\n\t\treturn this.tasks[id];\n\t}\n\n\tpublic exists(id: string): boolean {\n\t\treturn !!this.tasks[id];\n\t}\n\n\tpublic remove(id: string): void {\n\t\tdelete this.tasks[id];\n\t}\n\n\tpublic all(): Task[] {\n\t\treturn Object.keys(this.tasks).map(key => this.tasks[key]);\n\t}\n}\n"]}