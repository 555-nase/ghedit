{"version":3,"file":"vs/workbench/services/files/node/watcher/common.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/workbench/services/files/node/watcher/common.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport uri from 'vs/base/common/uri';\nimport paths = require('vs/base/common/paths');\nimport {FileChangeType, FileChangesEvent} from 'vs/platform/files/common/files';\n\nexport interface IRawFileChange {\n\ttype: FileChangeType;\n\tpath: string;\n}\n\nexport function toFileChangesEvent(changes: IRawFileChange[]): FileChangesEvent {\n\n\t// map to file changes event that talks about URIs\n\treturn new FileChangesEvent(changes.map((c) => {\n\t\treturn {\n\t\t\ttype: c.type,\n\t\t\tresource: uri.file(c.path)\n\t\t};\n\t}));\n}\n\n/**\n * Given events that occurred, applies some rules to normalize the events\n */\nexport function normalize(changes: IRawFileChange[]): IRawFileChange[] {\n\n\t// Build deltas\n\tlet normalizer = new EventNormalizer();\n\tfor (let i = 0; i < changes.length; i++) {\n\t\tlet event = changes[i];\n\t\tnormalizer.processEvent(event);\n\t}\n\n\treturn normalizer.normalize();\n}\n\nclass EventNormalizer {\n\tprivate normalized: IRawFileChange[];\n\tprivate mapPathToChange: { [path: string]: IRawFileChange };\n\n\tconstructor() {\n\t\tthis.normalized = [];\n\t\tthis.mapPathToChange = Object.create(null);\n\t}\n\n\tpublic processEvent(event: IRawFileChange): void {\n\n\t\t// Event path already exists\n\t\tlet existingEvent = this.mapPathToChange[event.path];\n\t\tif (existingEvent) {\n\t\t\tlet currentChangeType = existingEvent.type;\n\t\t\tlet newChangeType = event.type;\n\n\t\t\t// ignore CREATE followed by DELETE in one go\n\t\t\tif (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.DELETED) {\n\t\t\t\tdelete this.mapPathToChange[event.path];\n\t\t\t\tthis.normalized.splice(this.normalized.indexOf(existingEvent), 1);\n\t\t\t}\n\n\t\t\t// flatten DELETE followed by CREATE into CHANGE\n\t\t\telse if (currentChangeType === FileChangeType.DELETED && newChangeType === FileChangeType.ADDED) {\n\t\t\t\texistingEvent.type = FileChangeType.UPDATED;\n\t\t\t}\n\n\t\t\t// Do nothing. Keep the created event\n\t\t\telse if (currentChangeType === FileChangeType.ADDED && newChangeType === FileChangeType.UPDATED) {\n\t\t\t}\n\n\t\t\t// Otherwise apply change type\n\t\t\telse {\n\t\t\t\texistingEvent.type = newChangeType;\n\t\t\t}\n\t\t}\n\n\t\t// Otherwise Store\n\t\telse {\n\t\t\tthis.normalized.push(event);\n\t\t\tthis.mapPathToChange[event.path] = event;\n\t\t}\n\t}\n\n\tpublic normalize(): IRawFileChange[] {\n\t\tlet addedChangeEvents:IRawFileChange[] = [];\n\t\tlet deletedPaths:string[] = [];\n\n\t\t// This algorithm will remove all DELETE events up to the root folder\n\t\t// that got deleted if any. This ensures that we are not producing\n\t\t// DELETE events for each file inside a folder that gets deleted.\n\t\t//\n\t\t// 1.) split ADD/CHANGE and DELETED events\n\t\t// 2.) sort short deleted paths to the top\n\t\t// 3.) for each DELETE, check if there is a deleted parent and ignore the event in that case\n\t\treturn this.normalized.filter(e => {\n\t\t\tif (e.type !== 2) {\n\t\t\t\taddedChangeEvents.push(e);\n\t\t\t\treturn false; // remove ADD / CHANGE\n\t\t\t}\n\n\t\t\treturn true; // keep DELETE\n\t\t}).sort((e1, e2) => {\n\t\t\treturn e1.path.length - e2.path.length; // shortest path first\n\t\t}).filter(e => {\n\t\t\tif (deletedPaths.some(d => this.isParent(e.path, d))) {\n\t\t\t\treturn false; // DELETE is ignored if parent is deleted already\n\t\t\t}\n\n\t\t\t// otherwise mark as deleted\n\t\t\tdeletedPaths.push(e.path);\n\n\t\t\treturn true;\n\t\t}).concat(addedChangeEvents);\n\t}\n\n\tprivate isParent(p:string, candidate:string): boolean {\n\t\treturn p.indexOf(candidate + paths.nativeSep) === 0;\n\t}\n}"]}