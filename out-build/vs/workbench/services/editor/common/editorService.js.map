{"version":3,"file":"vs/workbench/services/editor/common/editorService.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/workbench/services/editor/common/editorService.ts"],"names":[],"mappings":";IAAA;;;oGAGgG;IAChG,YAAY,CAAC;IAMb,WAAY,iBAAiB;QAC5B,+EAAe,CAAA;QACf,qEAAU,CAAA;IACX,CAAC,EAHW,yBAAiB,KAAjB,yBAAiB,QAG5B;IAHD,IAAY,iBAAiB,GAAjB,yBAGX,CAAA;IAEU,+BAAuB,GAAG,+BAAe,CAA0B,eAAe,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport {createDecorator, ServiceIdentifier} from 'vs/platform/instantiation/common/instantiation';\nimport {IEditorService, IEditor, IEditorInput, IEditorOptions, Position, IResourceInput, IEditorModel, ITextEditorModel} from 'vs/platform/editor/common/editor';\n\nexport enum EditorArrangement {\n\tMINIMIZE_OTHERS,\n\tEVEN_WIDTH\n}\n\nexport var IWorkbenchEditorService = createDecorator<IWorkbenchEditorService>('editorService');\n\n/**\n * The editor service allows to open editors and work on the active\n * editor input and models.\n */\nexport interface IWorkbenchEditorService extends IEditorService {\n\tserviceId : ServiceIdentifier<any>;\n\n\t/**\n\t * Returns the currently active editor or null if none.\n\t */\n\tgetActiveEditor(): IEditor;\n\n\t/**\n\t * Returns the currently active editor input or null if none.\n\t */\n\tgetActiveEditorInput(): IEditorInput;\n\n\t/**\n\t * Returns an array of visible editors.\n\t */\n\tgetVisibleEditors(): IEditor[];\n\n\t/**\n\t * Returns iff the provided input is currently visible.\n\t *\n\t * @param includeDiff iff set to true, will also consider diff editors to find out if the provided\n\t * input is opened either on the left or right hand side of the diff editor.\n\t */\n\tisVisible(input: IEditorInput, includeDiff: boolean): boolean;\n\n\t/**\n\t * Opens an Editor on the given input with the provided options at the given position. If the input parameter\n\t * is null, will cause the currently opened editor at the position to close. If sideBySide parameter is provided,\n\t * causes the editor service to decide in what position to open the input.\n\t */\n\topenEditor(input: IEditorInput, options?: IEditorOptions, position?: Position): TPromise<IEditor>;\n\topenEditor(input: IEditorInput, options?: IEditorOptions, sideBySide?: boolean): TPromise<IEditor>;\n\n\t/**\n\t * Specific overload to open an instance of IResourceInput.\n\t */\n\topenEditor(input: IResourceInput, position?: Position): TPromise<IEditor>;\n\topenEditor(input: IResourceInput, sideBySide?: boolean): TPromise<IEditor>;\n\n\t/**\n\t * Opens the set of inputs replacing any other editor that is currently open. Use #openEditor() instead to open\n\t * a single editor.\n\t */\n\tsetEditors(inputs: IEditorInput[]): TPromise<IEditor[]>;\n\tsetEditors(inputs: IResourceInput[]): TPromise<IEditor[]>;\n\n\t/**\n\t * Closes the editor at the provided position. If position is not provided, the current active editor is closed.\n\t */\n\tcloseEditor(editor?: IEditor): TPromise<IEditor>;\n\tcloseEditor(position?: Position): TPromise<IEditor>;\n\n\t/**\n\t * Closes all editors or only others that are not active.\n\t */\n\tcloseEditors(othersOnly?: boolean): TPromise<void>;\n\n\t/**\n\t * Focus the editor at the provided position. If position is not provided, the current active editor is focused.\n\t */\n\tfocusEditor(editor?: IEditor): TPromise<IEditor>;\n\tfocusEditor(position?: Position): TPromise<IEditor>;\n\n\t/**\n\t * Activate the editor at the provided position without moving focus.\n\t */\n\tactivateEditor(editor: IEditor): void;\n\tactivateEditor(position: Position): void;\n\n\t/**\n\t * Allows to move the editor at position 1 to position 2.\n\t */\n\tmoveEditor(from: Position, to: Position): void;\n\n\t/**\n\t * Allows to arrange editors according to the EditorArrangement enumeration.\n\t */\n\tarrangeEditors(arrangement: EditorArrangement): void;\n\n\t/**\n\t * Resolves an input to its model representation. The optional parameter refresh allows to specify\n\t * if a cached model should be returned (false) or a new version (true). The default is returning a\n\t * cached version.\n\t */\n\tresolveEditorModel(input: IEditorInput, refresh?: boolean): TPromise<IEditorModel>;\n\n\t/**\n\t * Specific overload to resolve a IResourceInput to an editor model with a text representation.\n\t */\n\tresolveEditorModel(input: IResourceInput, refresh?: boolean): TPromise<ITextEditorModel>;\n\n\t/**\n\t * Allows to resolve an untyped input to a workbench typed instanceof editor input\n\t */\n\tinputToType(input: IResourceInput): TPromise<IEditorInput>;\n}"]}