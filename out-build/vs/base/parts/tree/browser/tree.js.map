{"version":3,"file":"tree.js","sourceRoot":"","sources":["../../../../../../src/vs/base/parts/tree/browser/tree.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport WinJS = require('vs/base/common/winjs.base');\nimport Touch = require('vs/base/browser/touch');\nimport Events = require('vs/base/common/eventEmitter');\nimport Mouse = require('vs/base/browser/mouseEvent');\nimport Keyboard = require('vs/base/browser/keyboardEvent');\nimport { INavigator } from 'vs/base/common/iterator';\n\nexport interface ITree extends Events.IEventEmitter {\n\n\t/**\n\t * Returns the tree's DOM element.\n\t */\n\tgetHTMLElement(): HTMLElement;\n\n\t/**\n\t * Lays out the tree.\n\t * Provide a specific height to save an (expensive) height computation.\n\t */\n\tlayout(height?: number): void;\n\n\t/**\n\t * Notifies the tree that is has become visible.\n\t */\n\tonVisible(): void;\n\n\t/**\n\t * Notifies the tree that is has become hidden.\n\t */\n\tonHidden(): void;\n\n\t/**\n\t * Sets the input of the tree.\n\t */\n\tsetInput(element: any): WinJS.Promise;\n\n\t/**\n\t * Returns the tree's input.\n\t */\n\tgetInput(): any;\n\n\t/**\n\t * Sets DOM focus on the tree.\n\t */\n\tDOMFocus(): void;\n\n\t/**\n\t * Returns whether the tree has DOM focus.\n\t */\n\tisDOMFocused(): boolean;\n\n\t/**\n\t * Removes DOM focus from the tree.\n\t */\n\tDOMBlur(): void;\n\n\t/**\n\t * Refreshes an element.\n\t * Provide no arguments and it will refresh the input element.\n\t */\n\trefresh(element?: any, recursive?: boolean): WinJS.Promise;\n\n\t/**\n\t * Refreshes all given elements.\n\t */\n\trefreshAll(elements: any[], recursive?: boolean): WinJS.Promise;\n\n\t/**\n\t * Expands an element.\n\t * The returned promise returns a boolean for whether the element was expanded or not.\n\t */\n\texpand(element: any): WinJS.Promise;\n\n\t/**\n\t * Expands several elements.\n\t * The returned promise returns a boolean array for whether the elements were expanded or not.\n\t */\n\texpandAll(elements?: any[]): WinJS.Promise;\n\n\t/**\n\t * Collapses an element.\n\t * The returned promise returns a boolean for whether the element was collapsed or not.\n\t */\n\tcollapse(element: any, recursive?: boolean): WinJS.Promise;\n\n\t/**\n\t * Collapses several elements.\n\t * Provide no arguments and it will recursively collapse all elements in the tree\n\t * The returned promise returns a boolean for whether the elements were collapsed or not.\n\t */\n\tcollapseAll(elements?: any[], recursive?: boolean): WinJS.Promise;\n\n\t/**\n\t * Toggles an element's expansion state.\n\t */\n\ttoggleExpansion(element: any): WinJS.Promise;\n\n\t/**\n\t * Toggles several element's expansion state.\n\t */\n\ttoggleExpansionAll(elements: any[]): WinJS.Promise;\n\n\t/**\n\t * Returns whether an element is expanded or not.\n\t */\n\tisExpanded(element: any): boolean;\n\n\t/**\n\t * Returns a list of the currently expanded elements.\n\t */\n\tgetExpandedElements(): any[];\n\n\t/**\n\t * Reveals an element in the tree. The relativeTop is a value between 0 and 1. The closer to 0 the more the\n\t * element will scroll up to the top.\n\t */\n\treveal(element: any, relativeTop?:number): WinJS.Promise;\n\n\t/**\n\t * Returns a number between 0 and 1 representing how much the tree is scroll down. 0 means all the way\n\t * to the top; 1 means all the way down.\n\t */\n\tgetScrollPosition(): number;\n\n\t/**\n\t * Sets the scroll position with a number between 0 and 1 representing how much the tree is scroll down. 0 means all the way\n\t * to the top; 1 means all the way down.\n\t */\n\tsetScrollPosition(pos: number): void;\n\n\t/**\n\t * Returns the total height of the tree's content.\n\t */\n\tgetContentHeight(): number;\n\n\t/**\n\t * Sets the tree's highlight to be the given element.\n\t * Provide no arguments and it clears the tree's highlight.\n\t */\n\tsetHighlight(element?: any, eventPayload?:any): void;\n\n\t/**\n\t * Returns the currently highlighted element.\n\t */\n\tgetHighlight(includeHidden?: boolean): any;\n\n\t/**\n\t * Returns whether an element is highlighted or not.\n\t */\n\tisHighlighted(element: any): boolean;\n\n\t/**\n\t * Clears the highlight.\n\t */\n\tclearHighlight(eventPayload?:any): void;\n\n\t/**\n\t * Selects an element.\n\t */\n\tselect(element: any, eventPayload?:any): void;\n\n\t/**\n\t * Selects a range of elements.\n\t */\n\tselectRange(fromElement: any, toElement: any, eventPayload?:any): void;\n\n\t/**\n\t * Deselects a range of elements.\n\t */\n\tdeselectRange(fromElement: any, toElement: any, eventPayload?:any): void;\n\n\t/**\n\t * Selects several elements.\n\t */\n\tselectAll(elements: any[], eventPayload?:any): void;\n\n\t/**\n\t * Deselects an element.\n\t */\n\tdeselect(element: any, eventPayload?:any): void;\n\n\t/**\n\t * Deselects several elements.\n\t */\n\tdeselectAll(elements: any[], eventPayload?:any): void;\n\n\t/**\n\t * Replaces the current selection with the given elements.\n\t */\n\tsetSelection(elements: any[], eventPayload?:any): void;\n\n\t/**\n\t * Toggles the element's selection.\n\t */\n\ttoggleSelection(element: any, eventPayload?:any): void;\n\n\t/**\n\t * Returns the currently selected elements.\n\t */\n\tgetSelection(includeHidden?: boolean): any[];\n\n\t/**\n\t * Returns whether an element is selected or not.\n\t */\n\tisSelected(element: any): boolean;\n\n\t/**\n\t * Selects the next `count`-nth element, in visible order.\n\t */\n\tselectNext(count?: number, clearSelection?: boolean, eventPayload?:any): void;\n\n\t/**\n\t * Selects the previous `count`-nth element, in visible order.\n\t */\n\tselectPrevious(count?: number, clearSelection?: boolean, eventPayload?:any): void;\n\n\t/**\n\t * Selects the currently selected element's parent.\n\t */\n\tselectParent(clearSelection?: boolean, eventPayload?:any): void;\n\n\t/**\n\t * Clears the selection.\n\t */\n\tclearSelection(eventPayload?:any): void;\n\n\t/**\n\t * Sets the focused element.\n\t */\n\tsetFocus(element?: any, eventPayload?:any): void;\n\n\t/**\n\t * Returns whether an element is focused or not.\n\t */\n\tisFocused(element: any): boolean;\n\n\t/**\n\t * Returns focused element.\n\t */\n\tgetFocus(includeHidden?: boolean): any;\n\n\t/**\n\t * Focuses the next `count`-nth element, in visible order.\n\t */\n\tfocusNext(count?: number, eventPayload?:any): void;\n\n\t/**\n\t * Focuses the previous `count`-nth element, in visible order.\n\t */\n\tfocusPrevious(count?: number, eventPayload?:any): void;\n\n\t/**\n\t * Focuses the currently selected element's parent.\n\t */\n\tfocusParent(eventPayload?: any): void;\n\n\t/**\n\t * Focuses the second element, in visible order.\n\t */\n\tfocusFirst(eventPayload?:any): void;\n\n\t/**\n\t * Focuses the nth element, in visible order.\n\t */\n\tfocusNth(index:number, eventPayload?:any): void;\n\n\t/**\n\t * Focuses the last element, in visible order.\n\t */\n\tfocusLast(eventPayload?:any): void;\n\n\t/**\n\t * Focuses the element at the end of the next page, in visible order.\n\t */\n\tfocusNextPage(eventPayload?:any): void;\n\n\t/**\n\t * Focuses the element at the beginning of the previous page, in visible order.\n\t */\n\tfocusPreviousPage(eventPayload?:any): void;\n\n\t/**\n\t * Clears the focus.\n\t */\n\tclearFocus(eventPayload?:any): void;\n\n\t/**\n\t * Adds the trait to elements.\n\t */\n\taddTraits(trait:string, elements: any[]): void;\n\n\t/**\n\t * Removes the trait from elements.\n\t */\n\tremoveTraits(trait: string, elements: any[]): void;\n\n\t/**\n\t * Toggles the element's trait.\n\t */\n\ttoggleTrait(trait: string, element: any): void;\n\n\t/**\n\t * Returns whether the element has the trait or not.\n\t */\n\thasTrait(trait: string, element: any): boolean;\n\n\t/**\n\t * Returns a navigator which allows to discover the visible and\n\t * expanded elements in the tree.\n\t */\n\tgetNavigator(): INavigator<any>;\n\n\t/**\n\t * Disposes the tree\n\t */\n\tdispose(): void;\n}\n\nexport interface IDataSource {\n\n\t/**\n\t * Returns the unique identifier of the given element.\n\t * No more than one element may use a given identifier.\n\t */\n\tgetId(tree: ITree, element: any): string;\n\n\t/**\n\t * Returns a boolean value indicating whether the element has children.\n\t */\n\thasChildren(tree: ITree, element: any): boolean;\n\n\t/**\n\t * Returns the element's children as an array in a promise.\n\t */\n\tgetChildren(tree: ITree, element: any): WinJS.Promise;\n\n\t/**\n\t * Returns the element's parent in a promise.\n\t */\n\tgetParent(tree: ITree, element: any): WinJS.Promise;\n}\n\nexport interface IRenderer {\n\n\t/**\n\t * Returns the element's height in the tree, in pixels.\n\t */\n\tgetHeight(tree: ITree, element: any): number;\n\n\t/**\n\t * Returns a template ID for a given element. This will be used as an identifier\n\t * for the next 3 methods.\n\t */\n\tgetTemplateId(tree: ITree, element: any): string;\n\n\t/**\n\t * Renders the template in a DOM element. This method should render all the DOM\n\t * structure for an hypothetical element leaving its contents blank. It should\n\t * return an object bag which will be passed along to `renderElement` and used\n\t * to fill in those blanks.\n\t *\n\t * You should do all DOM creating and object allocation in this method. It\n\t * will be called only a few times.\n\t */\n\trenderTemplate(tree: ITree, templateId: string, container: HTMLElement): any;\n\n\t/**\n\t * Renders an element, given an object bag returned by `renderTemplate`.\n\t * This method should do as little as possible and ideally it should only fill\n\t * in the blanks left by `renderTemplate`.\n\t *\n\t * Try to make this method do as little possible, since it will be called very\n\t * often.\n\t */\n\trenderElement(tree: ITree, element: any, templateId: string, templateData: any): void;\n\n\t/**\n\t * Disposes a template that was once rendered.\n\t */\n\tdisposeTemplate(tree: ITree, templateId: string, templateData: any): void;\n}\n\nexport interface IAccessibilityProvider {\n\n\t/**\n\t * Given an element in the tree, return the ARIA label that should be associated with the\n\t * item. This helps screen readers to provide a meaningful label for the currently focused\n\t * tree element.\n\t *\n\t * Returning null will not disable ARIA for the element. Instead it is up to the screen reader\n\t * to compute a meaningful label based on the contents of the element in the DOM\n\t *\n\t * See also: https://www.w3.org/TR/wai-aria/states_and_properties#aria-label\n\t */\n\tgetAriaLabel(tree: ITree, element: any): string;\n}\n\nexport /* abstract */ class ContextMenuEvent {\n\n\tprivate _posx: number;\n\tprivate _posy: number;\n\tprivate _target: HTMLElement;\n\n\tconstructor(posx: number, posy: number, target: HTMLElement) {\n\t\tthis._posx = posx;\n\t\tthis._posy = posy;\n\t\tthis._target = target;\n\t}\n\n\tpublic preventDefault(): void {\n\t\t// no-op\n\t}\n\n\tpublic stopPropagation(): void {\n\t\t// no-op\n\t}\n\n\tpublic get posx(): number {\n\t\treturn this._posx;\n\t}\n\n\tpublic get posy(): number {\n\t\treturn this._posy;\n\t}\n\n\tpublic get target(): HTMLElement {\n\t\treturn this._target;\n\t}\n}\n\nexport class MouseContextMenuEvent extends ContextMenuEvent {\n\n\tprivate originalEvent: Mouse.IMouseEvent;\n\n\tconstructor(originalEvent: Mouse.IMouseEvent) {\n\t\tsuper(originalEvent.posx, originalEvent.posy, originalEvent.target);\n\t\tthis.originalEvent = originalEvent;\n\t}\n\n\tpublic preventDefault(): void {\n\t\tthis.originalEvent.preventDefault();\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tthis.originalEvent.stopPropagation();\n\t}\n}\n\nexport class KeyboardContextMenuEvent extends ContextMenuEvent {\n\n\tprivate originalEvent: Keyboard.IKeyboardEvent;\n\n\tconstructor(posx: number, posy: number, originalEvent: Keyboard.IKeyboardEvent) {\n\t\tsuper(posx, posy, originalEvent.target);\n\t\tthis.originalEvent = originalEvent;\n\t}\n\n\tpublic preventDefault(): void {\n\t\tthis.originalEvent.preventDefault();\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tthis.originalEvent.stopPropagation();\n\t}\n}\n\nexport interface IController {\n\n\t/**\n\t * Called when an element is clicked.\n\t */\n\tonClick(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n\n\t/**\n\t * Called when an element is requested for a context menu.\n\t */\n\tonContextMenu(tree: ITree, element: any, event: ContextMenuEvent): boolean;\n\n\t/**\n\t * Called when an element is tapped.\n\t */\n\tonTap(tree: ITree, element: any, event: Touch.GestureEvent): boolean;\n\n\t/**\n\t * Called when a key is pressed down while selecting elements.\n\t */\n\tonKeyDown(tree: ITree, event: Keyboard.IKeyboardEvent): boolean;\n\n\t/**\n\t * Called when a key is released while selecting elements.\n\t */\n\tonKeyUp(tree: ITree, event: Keyboard.IKeyboardEvent): boolean;\n\n\t/**\n\t * Called when a mouse button is pressed down on an element.\n\t */\n\tonMouseDown?(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n\n\t/**\n\t * Called when a mouse button goes up on an element.\n\t */\n\tonMouseUp?(tree: ITree, element: any, event: Mouse.IMouseEvent): boolean;\n}\n\nexport enum DragOverEffect {\n\tCOPY,\n\tMOVE\n}\n\nexport enum DragOverBubble {\n\tBUBBLE_DOWN,\n\tBUBBLE_UP\n}\n\nexport interface IDragOverReaction {\n\taccept: boolean;\n\teffect?: DragOverEffect;\n\tbubble?: DragOverBubble;\n}\n\nexport var DRAG_OVER_REJECT: IDragOverReaction = { accept: false };\nexport var DRAG_OVER_ACCEPT: IDragOverReaction = { accept: true };\nexport var DRAG_OVER_ACCEPT_BUBBLE_UP: IDragOverReaction = { accept: true, bubble: DragOverBubble.BUBBLE_UP };\nexport var DRAG_OVER_ACCEPT_BUBBLE_DOWN: IDragOverReaction = { accept: true, bubble: DragOverBubble.BUBBLE_DOWN };\nexport var DRAG_OVER_ACCEPT_BUBBLE_UP_COPY: IDragOverReaction = { accept: true, bubble: DragOverBubble.BUBBLE_UP, effect: DragOverEffect.COPY };\nexport var DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY: IDragOverReaction = { accept: true, bubble: DragOverBubble.BUBBLE_DOWN, effect: DragOverEffect.COPY };\n\nexport interface IDragAndDropData {\n\tupdate(event: Mouse.DragMouseEvent): void;\n\tgetData(): any;\n}\n\nexport interface IDragAndDrop {\n\n\t/**\n\t * Returns a uri if the given element should be allowed to drag.\n\t * Returns null, otherwise.\n\t */\n\tgetDragURI(tree: ITree, element: any): string;\n\n\t/**\n\t * Sent when the drag operation is starting.\n\t */\n\tonDragStart(tree: ITree, data: IDragAndDropData, originalEvent:Mouse.DragMouseEvent): void;\n\n\t/**\n\t * Returns a DragOverReaction indicating whether sources can be\n\t * dropped into target or some parent of the target.\n\t */\n\tonDragOver(tree: ITree, data: IDragAndDropData, targetElement: any, originalEvent:Mouse.DragMouseEvent): IDragOverReaction;\n\n\t/**\n\t * Handles the action of dropping sources into target.\n\t */\n\tdrop(tree: ITree, data: IDragAndDropData, targetElement: any, originalEvent:Mouse.DragMouseEvent): void;\n}\n\nexport interface IFilter {\n\n\t/**\n\t * Returns whether the given element should be visible.\n\t */\n\tisVisible(tree: ITree, element: any): boolean;\n}\n\nexport interface IElementCallback {\n\t(tree: ITree, element: any): void;\n}\n\nexport type ICallback = ()=>void;\n\nexport interface ISorter {\n\n\t/**\n\t * Compare two elements in the viewer to define the sorting order.\n\t */\n\tcompare(tree: ITree, element: any, otherElement: any): number;\n}\n\n// Events\n\nexport interface ISelectionEvent {\n\tselection: any[];\n\tpayload?: any;\n}\n\nexport interface IFocusEvent {\n\tfocus: any;\n\tpayload?: any;\n}\n\nexport interface IHighlightEvent {\n\thighlight: any;\n\tpayload?: any;\n}\n\n// Options\n\nexport interface ITreeConfiguration {\n\tdataSource: IDataSource;\n\trenderer?: IRenderer;\n\tcontroller?: IController;\n\tdnd?: IDragAndDrop;\n\tfilter?: IFilter;\n\tsorter?: ISorter;\n\taccessibilityProvider?: IAccessibilityProvider;\n}\n\nexport interface ITreeOptions {\n\ttwistiePixels?: number;\n\tindentPixels?: number;\n\thorizontalScrollMode?: string;\n\tverticalScrollMode?: string;\n\talwaysFocused?: boolean;\n\tautoExpandSingleChildren?: boolean;\n\tbare?:boolean;\n\tuseShadows?:boolean;\n\tpaddingOnRow?:boolean;\n\tariaLabel?:string;\n}\n\nexport interface ITreeContext extends ITreeConfiguration {\n\ttree: ITree;\n\toptions: ITreeOptions;\n}\n"]}