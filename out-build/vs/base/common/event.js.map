{"version":3,"file":"vs/base/common/event.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/base/common/event.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IDisposable}  from 'vs/base/common/lifecycle';\nimport CallbackList from 'vs/base/common/callbackList';\nimport {EventEmitter} from 'vs/base/common/eventEmitter';\n\n/**\n * To an event a function with one or zero parameters\n * can be subscribed. The event is the subscriber function itself.\n */\ninterface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;\n}\n\nnamespace Event {\n\tconst _disposable = { dispose() { } };\n\texport const None: Event<any> = function() { return _disposable; };\n}\n\nexport default Event;\n\nexport interface EmitterOptions {\n\tonFirstListenerAdd?: Function;\n\tonLastListenerRemove?: Function;\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate static _noop = function () { };\n\n\tprivate _event: Event<T>;\n\tprivate _callbacks: CallbackList;\n\tprivate _disposed: boolean;\n\n\tconstructor(private _options?: EmitterOptions) {\n\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tif (!this._event) {\n\t\t\tthis._event = (listener: (e: T) => any,  thisArgs?: any, disposables?: IDisposable[]) => {\n\t\t\t\tif (!this._callbacks) {\n\t\t\t\t\tthis._callbacks = new CallbackList();\n\t\t\t\t}\n\t\t\t\tif (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n\t\t\t\t\tthis._options.onFirstListenerAdd(this);\n\t\t\t\t}\n\t\t\t\tthis._callbacks.add(listener, thisArgs);\n\n\t\t\t\tlet result: IDisposable;\n\t\t\t\tresult = {\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tresult.dispose = Emitter._noop;\n\t\t\t\t\t\tif (!this._disposed) {\n\t\t\t\t\t\t\tthis._callbacks.remove(listener, thisArgs);\n\t\t\t\t\t\t\tif(this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n\t\t\t\t\t\t\t\tthis._options.onLastListenerRemove(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif(Array.isArray(disposables)) {\n\t\t\t\t\tdisposables.push(result);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t\treturn this._event;\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event?: T): any {\n\t\tif (this._callbacks) {\n\t\t\tthis._callbacks.invoke.call(this._callbacks, event);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tif(this._callbacks) {\n\t\t\tthis._callbacks.dispose();\n\t\t\tthis._callbacks = undefined;\n\t\t\tthis._disposed = true;\n\t\t}\n\t}\n}\n\n/**\n * Creates an Event which is backed-up by the event emitter. This allows\n * to use the existing eventing pattern and is likely using less memory.\n * Sample:\n *\n * \tclass Document {\n *\n *\t\tprivate _eventbus = new EventEmitter();\n *\n *\t\tpublic onDidChange = fromEventEmitter(this._eventbus, 'changed');\n *\n *\t\t// getter-style\n *\t\t// get onDidChange(): Event<(value:string)=>any> {\n *\t\t// \tcache fromEventEmitter result and return\n *\t\t// }\n *\n *\t\tprivate _doIt() {\n *\t\t\t// ...\n *\t\t\tthis._eventbus.emit('changed', value)\n *\t\t}\n *\t}\n */\nexport function fromEventEmitter<T>(emitter: EventEmitter, eventType: string): Event<T> {\n\treturn function (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable {\n\t\tconst result = emitter.addListener2(eventType, function () {\n\t\t\tlistener.apply(thisArgs, arguments);\n\t\t});\n\t\tif(Array.isArray(disposables)) {\n\t\t\tdisposables.push(result);\n\t\t}\n\t\treturn result;\n\t};\n}\n\nexport function mapEvent<I,O>(event: Event<I>, map: (i:I)=>O): Event<O> {\n\treturn (listener, thisArgs?, disposables?) =>\n\t\tevent(i => listener(map(i)), thisArgs, disposables);\n}\n\nenum EventDelayerState {\n\tIdle,\n\tRunning\n}\n\n/**\n * The EventDelayer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.delay(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.wrap(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate buffers: Function[][] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst buffer = this.buffers[this.buffers.length - 1];\n\n\t\t\t\tif (buffer) {\n\t\t\t\t\tbuffer.push(() => listener.call(thisArgs, i));\n\t\t\t\t} else {\n\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t}\n\t\t\t}, void 0, disposables);\n\t\t};\n\t}\n\n\tbufferEvents(fn: () => void): void {\n\t\tconst buffer = [];\n\t\tthis.buffers.push(buffer);\n\t\tfn();\n\t\tthis.buffers.pop();\n\t\tbuffer.forEach(flush => flush());\n\t}\n}"]}