{"version":3,"file":"vs/base/common/glob.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/base/common/glob.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport strings = require('vs/base/common/strings');\nimport paths = require('vs/base/common/paths');\n\nconst CACHE: { [glob: string]: RegExp } = Object.create(null);\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause | any;\n}\n\nexport interface SiblingClause {\n\twhen: string;\n}\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\n\nfunction starsToRegExp(starCount: number): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn NO_PATH_REGEX + '*?'; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep    OR     Path Val followed by Path Sep     OR    Path Sep followed by Path Val) 0-many times\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn '(?:' + PATH_REGEX + '|' + NO_PATH_REGEX + '+' + PATH_REGEX + '|' + PATH_REGEX + NO_PATH_REGEX + '+)*?';\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tlet segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet char: string;\n\tlet curVal = '';\n\tfor (let i = 0; i < pattern.length; i++) {\n\t\tchar = pattern[i];\n\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tlet segments = splitGlobAware(pattern, '/');\n\n\t// Special case where we only have globstars\n\tif (segments.every(s => s === '**')) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Globstar is special\n\t\t\tif (segment === '**') {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (!previousSegmentWasGlobStar) {\n\t\t\t\t\tregEx += starsToRegExp(2);\n\t\t\t\t\tpreviousSegmentWasGlobStar = true;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// States\n\t\t\tlet inBraces = false;\n\t\t\tlet braceVal = '';\n\n\t\t\tlet inBrackets = false;\n\t\t\tlet bracketVal = '';\n\n\t\t\tlet char: string;\n\t\t\tfor (let i = 0; i < segment.length; i++) {\n\t\t\t\tchar = segment[i];\n\n\t\t\t\t// Support brace expansion\n\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\tbraceVal += char;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Support brackets\n\t\t\t\tif (char !== ']' && inBrackets) {\n\t\t\t\t\tlet res: string;\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '-':\t\t// allow the range operator\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '^':\t\t// allow the negate operator\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tres = strings.escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\n\t\t\t\t\tbracketVal += res;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase '{':\n\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '}':\n\t\t\t\t\t\tlet choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\tlet braceRegExp = '(?:' + choices.reduce((prevValue, curValue, i, array) => {\n\t\t\t\t\t\t\treturn prevValue + '|' + parseRegExp(curValue);\n\t\t\t\t\t\t}, parseRegExp(choices[0]) /* parse the first segment as regex and give as initial value */) + ')';\n\n\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase '?':\n\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tregEx += strings.escapeRegExpCharacters(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tail: Add the slash we had split on if there is more to come and the next one is not a globstar\n\t\t\tif (index < segments.length - 1 && segments[index + 1] !== '**') {\n\t\t\t\tregEx += PATH_REGEX;\n\t\t\t}\n\n\t\t\t// reset state\n\t\t\tpreviousSegmentWasGlobStar = false;\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\nfunction globToRegExp(pattern: string): RegExp {\n\tif (!pattern) {\n\t\treturn null;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tif (CACHE[pattern]) {\n\t\tlet cached = CACHE[pattern];\n\t\tcached.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\treturn cached;\n\t}\n\n\tlet regEx = parseRegExp(pattern);\n\n\t// Wrap it\n\tregEx = '^' + regEx + '$';\n\n\t// Convert to regexp and be ready for errors\n\tlet result = toRegExp(regEx);\n\n\t// Make sure to cache\n\tCACHE[pattern] = result;\n\n\treturn result;\n}\n\nfunction toRegExp(regEx: string): RegExp {\n\ttry {\n\t\treturn new RegExp(regEx);\n\t} catch (error) {\n\t\treturn /.^/; // create a regex that matches nothing if we cannot parse the pattern\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * - * matches anything inside a path segment\n * - ? matches 1 character inside a path segment\n * - ** matches anything including an empty path segment\n * - simple brace expansion ({js,ts} => js or ts)\n * - character ranges (using [...])\n */\nexport function match(pattern: string, path: string): boolean;\nexport function match(expression: IExpression, path: string, siblings?: string[]): string /* the matching pattern */;\nexport function match(arg1: string | IExpression, path: string, siblings?: string[]): any {\n\tif (!arg1 || !path) {\n\t\treturn false;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string') {\n\t\tvar regExp = globToRegExp(arg1);\n\t\treturn regExp && regExp.test(path);\n\t}\n\n\t// Glob with Expression\n\treturn matchExpression(<IExpression>arg1, path, siblings);\n}\n\nfunction matchExpression(expression: IExpression, path: string, siblings?: string[]): string /* the matching pattern */ {\n\tlet patterns = Object.getOwnPropertyNames(expression);\n\tlet basename: string;\n\tfor (let i = 0; i < patterns.length; i++) {\n\t\tlet pattern = patterns[i];\n\n\t\tlet value = expression[pattern];\n\t\tif (value === false) {\n\t\t\tcontinue; // pattern is disabled\n\t\t}\n\n\t\t// Pattern matches path\n\t\tif (match(pattern, path)) {\n\n\t\t\t// Expression Pattern is <boolean>\n\t\t\tif (typeof value === 'boolean') {\n\t\t\t\treturn pattern;\n\t\t\t}\n\n\t\t\t// Expression Pattern is <SiblingClause>\n\t\t\tif (value && typeof (<SiblingClause>value).when === 'string') {\n\t\t\t\tif (!siblings || !siblings.length) {\n\t\t\t\t\tcontinue; // pattern is malformed or we don't have siblings\n\t\t\t\t}\n\n\t\t\t\tif (!basename) {\n\t\t\t\t\tbasename = strings.rtrim(paths.basename(path), paths.extname(path));\n\t\t\t\t}\n\n\t\t\t\tlet clause = <SiblingClause>value;\n\t\t\t\tlet clausePattern = clause.when.replace('$(basename)', basename);\n\t\t\t\tif (siblings.some((sibling) => sibling === clausePattern)) {\n\t\t\t\t\treturn pattern;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue; // pattern does not match in the end because the when clause is not satisfied\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Expression is Anything\n\t\t\treturn pattern;\n\t\t}\n\t}\n\n\treturn null;\n}"]}