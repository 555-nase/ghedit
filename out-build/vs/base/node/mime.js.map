{"version":3,"file":"vs/base/node/mime.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/base/node/mime.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport streams = require('stream');\n\nimport mime = require('vs/base/common/mime');\n\nimport stream = require('vs/base/node/stream');\nimport encoding = require('vs/base/node/encoding');\n\n/**\n * Lots of binary file types exists where the type can be determined by matching the first few bytes against some \"magic patterns\".\n * E.g. PDF files always start with %PDF- and the rest of the file contains mostly text, but sometimes binary data (for fonts and images).\n * In order to detect these types correctly (and independently from the file's extension), the content base mime type detection must be performed\n * on any file, not only on text files.\n *\n * Here is the original mime type detection in pseudocode:\n *\n * let mimes = [];\n *\n * read file extension\n *\n * if (file extension matches) {\n * \tif (file extension is bogus) {\n * \t\t// ignore.\n * \t\t// this covers *.manifest files which can contain arbitrary content, so the extension is of no value.\n * \t\t// a consequence of this is that the content based mime type becomes the most specific type in the array\n * \t} else {\n * \t\tmimes.push(associated mime type)\t  // first element: most specific\n * \t}\n * }\n *\n * read file contents\n *\n * if (content based match found) {\t// this is independent from text or binary\n * \tmimes.push(associated mime type)\n * \tif (a second mime exists for the match) {   // should be rare; text/plain should never be included here\n * \t\t// e.g. for svg: ['image/svg+xml', 'application/xml']\n * \t\tmimes.push(second mime)\n * \t}\n * }\n *\n * if (content == text)\n * \tmimes.push('text/plain')   // last element: least specific\n * else\n * \tmimes.push('application/octet-stream')    // last element: least specific\n */\n\nconst BUFFER_READ_MAX_LEN = 512; // max buffer len to use when detecting encoding/mime\n\nexport interface IMimeAndEncoding {\n\tencoding: string;\n\tmimes: string[];\n}\n\nfunction doDetectMimesFromStream(instream: streams.Readable, callback: (error: Error, result: IMimeAndEncoding) => void): void {\n\tstream.readExactlyByStream(instream, BUFFER_READ_MAX_LEN, (err, buffer, bytesRead) => {\n\t\thandleReadResult(err, buffer, bytesRead, callback);\n\t});\n}\n\nfunction doDetectMimesFromFile(absolutePath: string, callback: (error: Error, result: IMimeAndEncoding) => void): void {\n\tstream.readExactlyByFile(absolutePath, BUFFER_READ_MAX_LEN, (err, buffer, bytesRead) => {\n\t\thandleReadResult(err, buffer, bytesRead, callback);\n\t});\n}\n\nfunction handleReadResult(err: Error, buffer: NodeBuffer, bytesRead: number, callback: (error: Error, result: IMimeAndEncoding) => void): void {\n\tif (err) {\n\t\treturn callback(err, null);\n\t}\n\n\treturn callback(null, detectMimeAndEncodingFromBuffer(buffer, bytesRead));\n}\n\nexport function detectMimeAndEncodingFromBuffer(buffer: NodeBuffer, bytesRead: number): IMimeAndEncoding {\n\tlet enc = encoding.detectEncodingByBOMFromBuffer(buffer, bytesRead);\n\n\t// Detect 0 bytes to see if file is binary (ignore for UTF 16 though)\n\tlet isText = true;\n\tif (enc !== encoding.UTF16be && enc !== encoding.UTF16le) {\n\t\tfor (let i = 0; i < bytesRead && i < BUFFER_READ_MAX_LEN; i++) {\n\t\t\tif (buffer.readInt8(i) === 0) {\n\t\t\t\tisText = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tmimes: isText ? [mime.MIME_TEXT] : [mime.MIME_BINARY],\n\t\tencoding: enc\n\t};\n}\n\nfunction filterAndSortMimes(detectedMimes: string[], guessedMimes: string[]): string[] {\n\tlet mimes = detectedMimes;\n\n\t// Add extension based mime as first element as this is the desire of whoever created the file.\n\t// Never care about application/octet-stream or application/unknown as guessed mime, as this is the fallback of the guess which is never accurate\n\tlet guessedMime = guessedMimes[0];\n\tif (guessedMime !== mime.MIME_BINARY && guessedMime !== mime.MIME_UNKNOWN) {\n\t\tmimes.unshift(guessedMime);\n\t}\n\n\t// Remove duplicate elements from array and sort unspecific mime to the end\n\tlet uniqueSortedMimes = mimes.filter((element, position) => {\n\t\treturn element && mimes.indexOf(element) === position;\n\t}).sort((mimeA, mimeB) => {\n\t\tif (mimeA === mime.MIME_BINARY) { return 1; }\n\t\tif (mimeB === mime.MIME_BINARY) { return -1; }\n\t\tif (mimeA === mime.MIME_TEXT) { return 1; }\n\t\tif (mimeB === mime.MIME_TEXT) { return -1; }\n\n\t\treturn 0;\n\t});\n\n\treturn uniqueSortedMimes;\n}\n\n/**\n * Opens the given stream to detect its mime type. Returns an array of mime types sorted from most specific to unspecific.\n * @param instream the readable stream to detect the mime types from.\n * @param nameHint an additional hint that can be used to detect a mime from a file extension.\n */\nexport function detectMimesFromStream(instream: streams.Readable, nameHint: string, callback: (error: Error, result: IMimeAndEncoding) => void): void {\n\tdoDetectMimesFromStream(instream, (error: Error, result: IMimeAndEncoding) => {\n\t\thandleMimeResult(nameHint, error, result, callback);\n\t});\n}\n\n/**\n * Opens the given file to detect its mime type. Returns an array of mime types sorted from most specific to unspecific.\n * @param absolutePath the absolute path of the file.\n */\nexport function detectMimesFromFile(absolutePath: string, callback: (error: Error, result: IMimeAndEncoding) => void): void {\n\tdoDetectMimesFromFile(absolutePath, (error: Error, result: IMimeAndEncoding) => {\n\t\thandleMimeResult(absolutePath, error, result, callback);\n\t});\n}\n\nfunction handleMimeResult(nameHint: string, error: Error, result: IMimeAndEncoding, callback: (error: Error, result: IMimeAndEncoding) => void): void {\n\tif (error) {\n\t\treturn callback(error, null);\n\t}\n\n\tlet filterAndSortedMimes = filterAndSortMimes(result.mimes, mime.guessMimeTypes(nameHint));\n\tresult.mimes = filterAndSortedMimes;\n\n\tcallback(null, result);\n}"]}