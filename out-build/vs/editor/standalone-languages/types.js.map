{"version":3,"file":"vs/editor/standalone-languages/types.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/editor/standalone-languages/types.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;IAEhG,YAAY,CAAC;;AA4Cb,2CAA2C;AAC3C,yEAAyE;AACzE,2DAA2D;AAC3D,qDAAqD;AACrD,IAAI;AAEJ,yCAAyC;AACzC,oEAAoE;AACpE,oFAAoF;AACpF,IAAI;AAEJ,MAAM;AACN,mEAAmE;AACnE,MAAM;AACN,uCAAuC;AACvC,yFAAyF;AACzF,6LAA6L;AAC7L,wHAAwH;AACxH,0IAA0I;AAC1I,qHAAqH;AACrH,4GAA4G;AAC5G,yEAAyE;AACzE,mHAAmH;AACnH,oFAAoF;AAEpF,2FAA2F;AAC3F,8LAA8L;AAC9L,qHAAqH;AACrH,2DAA2D;AAC3D,IAAI","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nexport interface ILanguageDef {\n\tid: string;\n\textensions: string[];\n\tfilenames?: string[];\n\tfirstLine?: string;\n\taliases: string[];\n\tmimetypes?: string[];\n\tdefModule: string;\n}\n\nexport interface ILanguage {\n\t// required\n\tname: string;\t\t\t\t\t\t\t\t// unique name to identify the language\n\ttokenizer: Object;\t\t\t\t\t\t\t// map from string to ILanguageRule[]\n\n\t// optional\n\tdisplayName?: string;\t\t\t\t\t\t// nice display name\n\tignoreCase?: boolean;\t\t\t\t\t\t\t// is the language case insensitive?\n\tlineComment?: string;\t\t\t\t\t\t// used to insert/delete line comments in the editor\n\tblockCommentStart?: string;\t\t\t\t\t// used to insert/delete block comments in the editor\n\tblockCommentEnd?: string;\n\tdefaultToken?: string;\t\t\t\t\t\t// if no match in the tokenizer assign this token class (default 'source')\n\tbrackets?: ILanguageBracket[];\t\t\t\t// for example [['{','}','delimiter.curly']]\n\n\t// advanced\n\tstart?: string;\t\t\t\t\t\t\t\t// start symbol in the tokenizer (by default the first entry is used)\n\ttokenPostfix?: string;\t\t\t\t\t\t// attach this to every token class (by default '.' + name)\n\tautoClosingPairs?: string[][];\t\t\t\t// for example [['\"','\"']]\n\twordDefinition?: RegExp;\t\t\t\t\t// word definition regular expression\n\toutdentTriggers?: string;\t\t\t\t\t// characters that could potentially cause outdentation\n\t// enhancedBrackets?: IRegexBracketPair[];     // Advanced auto completion, auto indenting, and bracket matching\n}\n\n/**\n\t* This interface can be shortened as an array, ie. ['{','}','delimiter.curly']\n\t*/\nexport interface ILanguageBracket {\n\topen: string;\t// open bracket\n\tclose: string;\t// closeing bracket\n\ttoken: string;\t// token class\n}\n\n// export interface ILanguageAutoComplete {\n// \ttriggers: string;\t\t\t\t// characters that trigger auto completion rules\n// \tmatch: string|RegExp;\t\t\t// autocomplete if this matches\n// \tcomplete: string;\t\t\t\t// complete with this string\n// }\n\n// export interface ILanguageAutoIndent {\n// \tmatch: string|RegExp; \t\t\t// auto indent if this matches on enter\n// \tmatchAfter: string|RegExp;\t\t// and auto-outdent if this matches on the next line\n// }\n\n// /**\n// \t* Regular expression based brackets. These are always electric.\n// \t*/\n// export interface IRegexBracketPair {\n// \t// openTrigger?: string; // The character that will trigger the evaluation of 'open'.\n// \topen: RegExp; // The definition of when an opening brace is detected. This regex is matched against the entire line upto, and including the last typed character (the trigger character).\n// \tcloseComplete?: string; // How to complete a matching open brace. Matches from 'open' will be expanded, e.g. '</$1>'\n// \tmatchCase?: boolean; // If set to true, the case of the string captured in 'open' will be detected an applied also to 'closeComplete'.\n// \t\t\t\t\t\t// This is useful for cases like BEGIN/END or begin/end where the opening and closing phrases are unrelated.\n// \t\t\t\t\t\t// For identical phrases, use the $1 replacement syntax above directly in closeComplete, as it will\n// \t\t\t\t\t\t// include the proper casing from the captured string in 'open'.\n// \t\t\t\t\t\t// Upper/Lower/Camel cases are detected. Camel case dection uses only the first two characters and assumes\n// \t\t\t\t\t\t// that 'closeComplete' contains wors separated by spaces (e.g. 'End Loop')\n\n// \t// closeTrigger?: string; // The character that will trigger the evaluation of 'close'.\n// \tclose?: RegExp; // The definition of when a closing brace is detected. This regex is matched against the entire line upto, and including the last typed character (the trigger character).\n// \ttokenType?: string; // The type of the token. Matches from 'open' or 'close' will be expanded, e.g. 'keyword.$1'.\n// \t\t\t\t\t\t// Only used to auto-(un)indent a closing bracket.\n// }\n"]}