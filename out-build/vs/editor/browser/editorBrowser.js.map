{"version":3,"file":"vs/editor/browser/editorBrowser.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/editor/browser/editorBrowser.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IEmitterEvent, IEventEmitter} from 'vs/base/common/eventEmitter';\nimport {IDisposable} from 'vs/base/common/lifecycle';\nimport {IKeyboardEvent} from 'vs/base/browser/keyboardEvent';\nimport {IMouseEvent} from 'vs/base/browser/mouseEvent';\nimport {IInstantiationService, IConstructorSignature1} from 'vs/platform/instantiation/common/instantiation';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\n\nexport interface IContentWidgetData {\n\twidget: IContentWidget;\n\tposition: IContentWidgetPosition;\n}\n\nexport interface IOverlayWidgetData {\n\twidget: IOverlayWidget;\n\tposition: IOverlayWidgetPosition;\n}\n\nexport interface ICodeEditorHelper {\n\tgetScrollTop(): number;\n\tsetScrollTop(scrollTop:number): void;\n\tgetScrollLeft(): number;\n\tsetScrollLeft(scrollLeft:number): void;\n\tgetScrollHeight(): number;\n\tgetScrollWidth(): number;\n\tgetVerticalOffsetForPosition(lineNumber:number, column:number): number;\n\tdelegateVerticalScrollbarMouseDown(browserEvent:MouseEvent): void;\n\tgetOffsetForColumn(lineNumber:number, column:number): number;\n}\n\nexport interface IKeyboardHandlerHelper {\n\tviewDomNode:HTMLElement;\n\ttextArea:HTMLTextAreaElement;\n\tvisibleRangeForPositionRelativeToEditor(lineNumber:number, column:number): editorCommon.VisibleRange;\n\tflushAnyAccumulatedEvents(): void;\n}\n\nexport interface IPointerHandlerHelper {\n\tviewDomNode:HTMLElement;\n\tlinesContentDomNode:HTMLElement;\n\n\tfocusTextArea(): void;\n\tisDirty(): boolean;\n\n\tgetScrollTop(): number;\n\tsetScrollTop(scrollTop:number): void;\n\tgetScrollLeft(): number;\n\tsetScrollLeft(scrollLeft:number): void;\n\n\tisAfterLines(verticalOffset:number): boolean;\n\tgetLineNumberAtVerticalOffset(verticalOffset: number): number;\n\tgetVerticalOffsetForLineNumber(lineNumber: number): number;\n\tgetWhitespaceAtVerticalOffset(verticalOffset:number): editorCommon.IViewWhitespaceViewportData;\n\tshouldSuppressMouseDownOnViewZone(viewZoneId:number): boolean;\n\n\t/**\n\t * Decode an Editor.IPosition from a rendered dom node\n\t */\n\tgetPositionFromDOMInfo(spanNode:HTMLElement, offset:number): editorCommon.IPosition;\n\n\tvisibleRangeForPosition2(lineNumber:number, column:number): editorCommon.VisibleRange;\n\tgetLineWidth(lineNumber:number): number;\n}\n\nexport interface IView extends IDisposable {\n\tdomNode: HTMLElement;\n\n\tgetInternalEventBus(): IEventEmitter;\n\n\tcreateOverviewRuler(cssClassName:string, minimumHeight:number, maximumHeight:number): IOverviewRuler;\n\tgetCodeEditorHelper(): ICodeEditorHelper;\n\n\tgetCenteredRangeInViewport(): editorCommon.IEditorRange;\n\n\tchange(callback:(changeAccessor:IViewZoneChangeAccessor) => any): boolean;\n\tgetWhitespaces(): editorCommon.IEditorWhitespace[];\n\trenderOnce(callback:() => any): any;\n\n\trender(now:boolean, everything:boolean): void;\n\tsetAriaActiveDescendant(id:string): void;\n\n\tfocus(): void;\n\tisFocused(): boolean;\n\n\tsaveState(): editorCommon.IViewState;\n\trestoreState(state:editorCommon.IViewState): void;\n\n\taddContentWidget(widgetData: IContentWidgetData): void;\n\tlayoutContentWidget(widgetData: IContentWidgetData): void;\n\tremoveContentWidget(widgetData: IContentWidgetData): void;\n\n\taddOverlayWidget(widgetData: IOverlayWidgetData): void;\n\tlayoutOverlayWidget(widgetData: IOverlayWidgetData): void;\n\tremoveOverlayWidget(widgetData: IOverlayWidgetData): void;\n}\n\nexport interface IViewZoneData {\n\tviewZoneId: number;\n\tpositionBefore:editorCommon.IEditorPosition;\n\tpositionAfter:editorCommon.IEditorPosition;\n\tposition: editorCommon.IEditorPosition;\n\tafterLineNumber: number;\n}\n\nexport interface IMouseDispatchData {\n\tposition: editorCommon.IEditorPosition;\n\t/**\n\t * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).\n\t */\n\tmouseColumn: number;\n\tstartedOnLineNumbers: boolean;\n\n\tinSelectionMode: boolean;\n\tmouseDownCount: number;\n\taltKey: boolean;\n\tctrlKey: boolean;\n\tmetaKey: boolean;\n\tshiftKey: boolean;\n}\n\nexport interface IViewController {\n\tdispatchMouse(data:IMouseDispatchData);\n\n\tmoveTo(source:string, position:editorCommon.IEditorPosition): void;\n\n\tpaste(source:string, text:string, pasteOnNewLine:boolean): void;\n\ttype(source: string, text: string): void;\n\treplacePreviousChar(source: string, text: string, replaceCharCnt:number): void;\n\tcut(source:string): void;\n\n\temitKeyDown(e:IKeyboardEvent): void;\n\temitKeyUp(e:IKeyboardEvent): void;\n\temitContextMenu(e:IEditorMouseEvent): void;\n\temitMouseMove(e:IEditorMouseEvent): void;\n\temitMouseLeave(e:IEditorMouseEvent): void;\n\temitMouseUp(e:IEditorMouseEvent): void;\n\temitMouseDown(e:IEditorMouseEvent): void;\n}\n\nexport var ClassNames = {\n\tTEXTAREA_COVER: 'textAreaCover',\n\tTEXTAREA: 'inputarea',\n\tLINES_CONTENT: 'lines-content',\n\tOVERFLOW_GUARD: 'overflow-guard',\n\tVIEW_LINES: 'view-lines',\n\tVIEW_LINE: 'view-line',\n\tSCROLLABLE_ELEMENT: 'editor-scrollable',\n\tCONTENT_WIDGETS: 'contentWidgets',\n\tOVERFLOWING_CONTENT_WIDGETS: 'overflowingContentWidgets',\n\tOVERLAY_WIDGETS: 'overlayWidgets',\n\tMARGIN_VIEW_OVERLAYS: 'margin-view-overlays',\n\tLINE_NUMBERS: 'line-numbers',\n\tGLYPH_MARGIN: 'glyph-margin',\n\tSCROLL_DECORATION: 'scroll-decoration',\n\tVIEW_CURSORS_LAYER: 'cursors-layer',\n\tVIEW_ZONES: 'view-zones'\n};\n\nexport interface IRestrictedRenderingContext {\n\tlinesViewportData:editorCommon.ViewLinesViewportData;\n\n\tscrollWidth:number;\n\tscrollHeight:number;\n\n\tvisibleRange:editorCommon.IEditorRange;\n\tbigNumbersDelta:number;\n\n\tviewportTop:number;\n\tviewportWidth:number;\n\tviewportHeight:number;\n\tviewportLeft:number;\n\n\tgetScrolledTopFromAbsoluteTop(absoluteTop:number): number;\n\tgetViewportVerticalOffsetForLineNumber(lineNumber:number): number;\n\tlineIsVisible(lineNumber:number): boolean;\n\n\tgetDecorationsInViewport(): editorCommon.IModelDecoration[];\n}\n\nexport interface IRenderingContext extends IRestrictedRenderingContext {\n\n\tlinesVisibleRangesForRange(range:editorCommon.IRange, includeNewLines:boolean): editorCommon.LineVisibleRanges[];\n\n\tvisibleRangeForPosition(position:editorCommon.IPosition): editorCommon.VisibleRange;\n}\n\nexport interface IViewEventHandler {\n\thandleEvents(events:IEmitterEvent[]): void;\n}\n\nexport interface IViewportInfo {\n\tvisibleRange: editorCommon.IEditorRange;\n\twidth:number;\n\theight:number;\n\tdeltaTop:number;\n\tdeltaLeft:number;\n}\n\n// --- end View Event Handlers & Parts\n\nexport interface IViewContext {\n\n\taddEventHandler(eventHandler:IViewEventHandler): void;\n\tremoveEventHandler(eventHandler:IViewEventHandler): void;\n\n\tconfiguration:editorCommon.IConfiguration;\n\tmodel: editorCommon.IViewModel;\n\tprivateViewEventBus:editorCommon.IViewEventBus;\n}\n\nexport interface ILayoutProvider extends IVerticalLayoutProvider, IScrollingProvider {\n\n\tdispose():void;\n\n\tgetCenteredViewLineNumberInViewport(): number;\n\n\tgetCurrentViewport(): editorCommon.Viewport;\n\n\tonMaxLineWidthChanged(width:number): void;\n\n\tsaveState(): editorCommon.IViewState;\n\trestoreState(state:editorCommon.IViewState): void;\n}\n\nexport interface IScrollingProvider {\n\n\tgetOverviewRulerInsertData(): { parent: HTMLElement; insertBefore: HTMLElement; };\n\tgetScrollbarContainerDomNode(): HTMLElement;\n\tdelegateVerticalScrollbarMouseDown(browserEvent:MouseEvent): void;\n\n\t// This is for the glyphs, line numbers, etc.\n\tgetScrolledTopFromAbsoluteTop(top:number): number;\n\n\tgetScrollHeight(): number;\n\tgetScrollWidth(): number;\n\tgetScrollLeft(): number;\n\tsetScrollLeft(scrollLeft:number): void;\n\tgetScrollTop(): number;\n\tsetScrollTop(scrollTop:number): void;\n}\n\nexport interface IVerticalLayoutProvider {\n\n\t/**\n\t * Compute vertical offset (top) of line number\n\t */\n\tgetVerticalOffsetForLineNumber(lineNumber:number): number;\n\n\t/**\n\t * Returns the height in pixels for `lineNumber`.\n\t */\n\theightInPxForLine(lineNumber:number): number;\n\n\t/**\n\t * Return line number at `verticalOffset` or closest line number\n\t */\n\tgetLineNumberAtVerticalOffset(verticalOffset:number): number;\n\n\t/**\n\t * Compute content height (including one extra scroll page if necessary)\n\t */\n\tgetTotalHeight(): number;\n\n\t/**\n\t * Compute the lines that need to be rendered in the current viewport position.\n\t */\n\tgetLinesViewportData(): editorCommon.ViewLinesViewportData;\n}\n\n/**\n * A view zone is a full horizontal rectangle that 'pushes' text down.\n * The editor reserves space for view zones when rendering.\n */\nexport interface IViewZone {\n\t/**\n\t * The line number after which this zone should appear.\n\t * Use 0 to place a view zone before the first line number.\n\t */\n\tafterLineNumber:number;\n\t/**\n\t * The column after which this zone should appear.\n\t * If not set, the maxLineColumn of `afterLineNumber` will be used.\n\t */\n\tafterColumn?:number;\n\t/**\n\t * Suppress mouse down events.\n\t * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.\n\t * Defaults to false\n\t */\n\tsuppressMouseDown?:boolean;\n\t/**\n\t * The height in lines of the view zone.\n\t * If specified, `heightInPx` will be used instead of this.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInLines?:number;\n\t/**\n\t * The height in px of the view zone.\n\t * If this is set, the editor will give preference to it rather than `heightInLines` above.\n\t * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.\n\t */\n\theightInPx?: number;\n\t/**\n\t * The dom node of the view zone\n\t */\n\tdomNode:HTMLElement;\n\t/**\n\t * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).\n\t */\n\tonDomNodeTop?:(top: number) =>void;\n\t/**\n\t * Callback which gives the height in pixels of the view zone.\n\t */\n\tonComputedHeight?:(height: number) =>void;\n}\n/**\n * An accessor that allows for zones to be added or removed.\n */\nexport interface IViewZoneChangeAccessor {\n\t/**\n\t * Create a new view zone.\n\t * @param zone Zone to create\n\t * @return A unique identifier to the view zone.\n\t */\n\taddZone(zone: IViewZone): number;\n\t/**\n\t * Remove a zone\n\t * @param id A unique identifier to the view zone, as returned by the `addZone` call.\n\t */\n\tremoveZone(id: number): void;\n\t/**\n\t * Change a zone's position.\n\t * The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.\n\t */\n\tlayoutZone(id: number): void;\n}\n\n/**\n * A positioning preference for rendering content widgets.\n */\nexport enum ContentWidgetPositionPreference {\n\t/**\n\t * Place the content widget exactly at a position\n\t */\n\tEXACT,\n\t/**\n\t * Place the content widget above a position\n\t */\n\tABOVE,\n\t/**\n\t * Place the content widget below a position\n\t */\n\tBELOW\n}\n/**\n * A position for rendering content widgets.\n */\nexport interface IContentWidgetPosition {\n\t/**\n\t * Desired position for the content widget.\n\t * `preference` will also affect the placement.\n\t */\n\tposition: editorCommon.IPosition;\n\t/**\n\t * Placement preference for position, in order of preference.\n\t */\n\tpreference: ContentWidgetPositionPreference[];\n}\n/**\n * A content widget renders inline with the text and can be easily placed 'near' an editor position.\n */\nexport interface IContentWidget {\n\t/**\n\t * Render this content widget in a location where it could overflow the editor's view dom node.\n\t */\n\tallowEditorOverflow?: boolean;\n\t/**\n\t * Get a unique identifier of the content widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the content widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the content widget.\n\t * If null is returned, the content widget will be placed off screen.\n\t */\n\tgetPosition(): IContentWidgetPosition;\n}\n\n/**\n * A positioning preference for rendering overlay widgets.\n */\nexport enum OverlayWidgetPositionPreference {\n\t/**\n\t * Position the overlay widget in the top right corner\n\t */\n\tTOP_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the bottom right corner\n\t */\n\tBOTTOM_RIGHT_CORNER,\n\n\t/**\n\t * Position the overlay widget in the top center\n\t */\n\tTOP_CENTER\n}\n/**\n * A position for rendering overlay widgets.\n */\nexport interface IOverlayWidgetPosition {\n\t/**\n\t * The position preference for the overlay widget.\n\t */\n\tpreference: OverlayWidgetPositionPreference;\n}\n/**\n * An overlay widgets renders on top of the text.\n */\nexport interface IOverlayWidget {\n\t/**\n\t * Get a unique identifier of the overlay widget.\n\t */\n\tgetId(): string;\n\t/**\n\t * Get the dom node of the overlay widget.\n\t */\n\tgetDomNode(): HTMLElement;\n\t/**\n\t * Get the placement of the overlay widget.\n\t * If null is returned, the overlay widget is responsible to place itself.\n\t */\n\tgetPosition(): IOverlayWidgetPosition;\n}\n\n/**\n * Target hit with the mouse in the editor.\n */\nexport interface IMouseTarget {\n\t/**\n\t * The target element\n\t */\n\telement: Element;\n\t/**\n\t * The target type\n\t */\n\ttype: editorCommon.MouseTargetType;\n\t/**\n\t * The 'approximate' editor position\n\t */\n\tposition: editorCommon.IEditorPosition;\n\t/**\n\t * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).\n\t */\n\tmouseColumn: number;\n\t/**\n\t * The 'approximate' editor range\n\t */\n\trange: editorCommon.IEditorRange;\n\t/**\n\t * Some extra detail.\n\t */\n\tdetail: any;\n}\n/**\n * A mouse event originating from the editor.\n */\nexport interface IEditorMouseEvent {\n\tevent: IMouseEvent;\n\ttarget: IMouseTarget;\n}\n\nexport type ISimpleEditorContributionCtor = IConstructorSignature1<ICodeEditor, editorCommon.IEditorContribution>;\n\n/**\n * An editor contribution descriptor that will be used to construct editor contributions\n */\nexport interface IEditorContributionDescriptor {\n\t/**\n\t * Create an instance of the contribution\n\t */\n\tcreateInstance(instantiationService:IInstantiationService, editor:ICodeEditor): editorCommon.IEditorContribution;\n}\n\nexport class ColorZone {\n\t_colorZoneTrait: void;\n\n\tfrom: number;\n\tto: number;\n\tcolorId: number;\n\tposition: editorCommon.OverviewRulerLane;\n\n\tconstructor(from:number, to:number, colorId:number, position: editorCommon.OverviewRulerLane) {\n\t\tthis.from = from|0;\n\t\tthis.to = to|0;\n\t\tthis.colorId = colorId|0;\n\t\tthis.position = position|0;\n\t}\n}\n\n/**\n * A zone in the overview ruler\n */\nexport class OverviewRulerZone {\n\t_overviewRulerZoneTrait: void;\n\n\tstartLineNumber: number;\n\tendLineNumber: number;\n\tposition: editorCommon.OverviewRulerLane;\n\tforceHeight: number;\n\n\tprivate _color: string;\n\tprivate _darkColor: string;\n\n\tprivate _colorZones: ColorZone[];\n\n\tconstructor(\n\t\tstartLineNumber: number, endLineNumber: number,\n\t\tposition: editorCommon.OverviewRulerLane,\n\t\tforceHeight: number,\n\t\tcolor: string, darkColor: string\n\t) {\n\t\tthis.startLineNumber = startLineNumber;\n\t\tthis.endLineNumber = endLineNumber;\n\t\tthis.position = position;\n\t\tthis.forceHeight = forceHeight;\n\t\tthis._color = color;\n\t\tthis._darkColor = darkColor;\n\t\tthis._colorZones = null;\n\t}\n\n\tpublic getColor(useDarkColor:boolean): string {\n\t\tif (useDarkColor) {\n\t\t\treturn this._darkColor;\n\t\t}\n\t\treturn this._color;\n\t}\n\n\tpublic equals(other:OverviewRulerZone): boolean {\n\t\treturn (\n\t\t\tthis.startLineNumber === other.startLineNumber\n\t\t\t&& this.endLineNumber === other.endLineNumber\n\t\t\t&& this.position === other.position\n\t\t\t&& this.forceHeight === other.forceHeight\n\t\t\t&& this._color === other._color\n\t\t\t&& this._darkColor === other._darkColor\n\t\t);\n\t}\n\n\tpublic compareTo(other:OverviewRulerZone): number {\n\t\tif (this.startLineNumber === other.startLineNumber) {\n\t\t\tif (this.endLineNumber === other.endLineNumber) {\n\t\t\t\tif (this.forceHeight === other.forceHeight) {\n\t\t\t\t\tif (this.position === other.position) {\n\t\t\t\t\t\tif (this._darkColor === other._darkColor) {\n\t\t\t\t\t\t\tif (this._color === other._color) {\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn this._color < other._color ? -1 : 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this._darkColor < other._darkColor ? -1 : 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this.position - other.position;\n\t\t\t\t}\n\t\t\t\treturn this.forceHeight - other.forceHeight;\n\t\t\t}\n\t\t\treturn this.endLineNumber - other.endLineNumber;\n\t\t}\n\t\treturn this.startLineNumber - other.startLineNumber;\n\t}\n\n\tpublic setColorZones(colorZones:ColorZone[]): void {\n\t\tthis._colorZones = colorZones;\n\t}\n\n\tpublic getColorZones(): ColorZone[] {\n\t\treturn this._colorZones;\n\t}\n}\n/**\n * An overview ruler\n */\nexport interface IOverviewRuler {\n\tgetDomNode(): HTMLElement;\n\tdispose(): void;\n\tsetZones(zones:OverviewRulerZone[]): void;\n\tsetLayout(position:editorCommon.IOverviewRulerPosition): void;\n}\n/**\n * A rich code editor.\n */\nexport interface ICodeEditor extends editorCommon.ICommonCodeEditor {\n\n\t/**\n\t * Returns the editor's dom node\n\t */\n\tgetDomNode(): HTMLElement;\n\n\t/**\n\t * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropiately.\n\t */\n\tlayoutContentWidget(widget: IContentWidget): void;\n\t/**\n\t * Remove a content widget.\n\t */\n\tremoveContentWidget(widget: IContentWidget): void;\n\n\t/**\n\t * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.\n\t */\n\taddOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()\n\t * and update appropiately.\n\t */\n\tlayoutOverlayWidget(widget: IOverlayWidget): void;\n\t/**\n\t * Remove an overlay widget.\n\t */\n\tremoveOverlayWidget(widget: IOverlayWidget): void;\n\n\t/**\n\t * Change the view zones. View zones are lost when a new model is attached to the editor.\n\t */\n\tchangeViewZones(callback: (accessor: IViewZoneChangeAccessor) => void): void;\n\n\t/**\n\t * Returns the range that is currently centered in the view port.\n\t */\n\tgetCenteredRangeInViewport(): editorCommon.IEditorRange;\n\n\t/**\n\t * Get the view zones.\n\t */\n\tgetWhitespaces(): editorCommon.IEditorWhitespace[];\n\n\t/**\n\t * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.\n\t * This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).\n\t * Use this method with caution.\n\t */\n\tgetOffsetForColumn(lineNumber: number, column: number): number;\n\n\t/**\n\t * Force an editor render now.\n\t */\n\trender(): void;\n\n\t/**\n\t * Get the vertical position (top offset) for the line w.r.t. to the first line.\n\t */\n\tgetTopForLineNumber(lineNumber: number): number;\n\n\t/**\n\t * Get the vertical position (top offset) for the position w.r.t. to the first line.\n\t */\n\tgetTopForPosition(lineNumber: number, column: number): number;\n\n\t/**\n\t * Get the visible position for `position`.\n\t * The result position takes scrolling into account and is relative to the top left corner of the editor.\n\t * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.\n\t * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.\n\t * Warning: the results of this method are innacurate for positions that are outside the current editor viewport.\n\t */\n\tgetScrolledVisiblePosition(position: editorCommon.IPosition): { top: number; left: number; height: number; };\n\n\t/**\n\t * Set the model ranges that will be hidden in the view.\n\t */\n\tsetHiddenAreas(ranges:editorCommon.IRange[]): void;\n\n\tsetAriaActiveDescendant(id:string): void;\n}\n\n/**\n * A rich diff editor.\n */\nexport interface IDiffEditor extends editorCommon.ICommonDiffEditor {\n\t/**\n\t * @see ICodeEditor.getDomNode\n\t */\n\tgetDomNode(): HTMLElement;\n}\n"]}