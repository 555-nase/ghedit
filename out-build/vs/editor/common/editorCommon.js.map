{"version":3,"file":"vs/editor/common/editorCommon.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/editor/common/editorCommon.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IAction} from 'vs/base/common/actions';\nimport Event from 'vs/base/common/event';\nimport {IEventEmitter, ListenerUnbind} from 'vs/base/common/eventEmitter';\nimport {IHTMLContentElement} from 'vs/base/common/htmlContent';\nimport {KeyCode, KeyMod} from 'vs/base/common/keyCodes';\nimport {IDisposable} from 'vs/base/common/lifecycle';\nimport URI from 'vs/base/common/uri';\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport {IInstantiationService, IConstructorSignature1, IConstructorSignature2} from 'vs/platform/instantiation/common/instantiation';\nimport {ILineContext, IMode, IModeTransition, IToken} from 'vs/editor/common/modes';\nimport {Arrays} from 'vs/editor/common/core/arrays';\n\nexport type KeyCode = KeyCode;\nexport type KeyMod = KeyMod;\n\n// --- position & range\n\n/**\n * A position in the editor. This interface is suitable for serialization.\n */\nexport interface IPosition {\n\t/**\n\t * line number (starts at 1)\n\t */\n\tlineNumber:number;\n\t/**\n\t * column (the first character in a line is between column 1 and column 2)\n\t */\n\tcolumn:number;\n}\n\n/**\n * A position in the editor.\n */\nexport interface IEditorPosition extends IPosition {\n\t/**\n\t * Test if this position equals other position\n\t */\n\tequals(other:IPosition): boolean;\n\t/**\n\t * Test if this position is before other position. If the two positions are equal, the result will be false.\n\t */\n\tisBefore(other:IPosition): boolean;\n\t/**\n\t * Test if this position is before other position. If the two positions are equal, the result will be true.\n\t */\n\tisBeforeOrEqual(other:IPosition): boolean;\n\t/**\n\t * Clone this position.\n\t */\n\tclone(): IEditorPosition;\n}\n\n/**\n * A range in the editor. This interface is suitable for serialization.\n */\nexport interface IRange {\n\t/**\n\t * Line number on which the range starts (starts at 1).\n\t */\n\tstartLineNumber:number;\n\t/**\n\t * Column on which the range starts in line `startLineNumber` (starts at 1).\n\t */\n\tstartColumn:number;\n\t/**\n\t * Line number on which the range ends.\n\t */\n\tendLineNumber:number;\n\t/**\n\t * Column on which the range ends in line `endLineNumber`.\n\t */\n\tendColumn:number;\n}\n\n/**\n * A range in the editor.\n */\nexport interface IEditorRange extends IRange {\n\t/**\n\t * Test if this range is empty.\n\t */\n\tisEmpty(): boolean;\n\tcollapseToStart():IEditorRange;\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tcontainsPosition(position:IPosition): boolean;\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tcontainsRange(range:IRange): boolean;\n\t/**\n\t * A reunion of the two ranges. The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tplusRange(range:IRange): IEditorRange;\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tintersectRanges(range:IRange): IEditorRange;\n\t/**\n\t * Test if this range equals other.\n\t */\n\tequalsRange(other:IRange): boolean;\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tgetEndPosition(): IEditorPosition;\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tsetEndPosition(endLineNumber: number, endColumn: number): IEditorRange;\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tgetStartPosition(): IEditorPosition;\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tsetStartPosition(startLineNumber: number, startColumn: number): IEditorRange;\n\t/**\n\t * Clone this range.\n\t */\n\tcloneRange(): IEditorRange;\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\ttoString(): string;\n}\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport interface ISelection {\n\t/**\n\t * The line number on which the selection has started.\n\t */\n\tselectionStartLineNumber: number;\n\t/**\n\t * The column on `selectionStartLineNumber` where the selection has started.\n\t */\n\tselectionStartColumn: number;\n\t/**\n\t * The line number on which the selection has ended.\n\t */\n\tpositionLineNumber: number;\n\t/**\n\t * The column on `positionLineNumber` where the selection has ended.\n\t */\n\tpositionColumn: number;\n}\n\n/**\n * The direction of a selection.\n */\nexport enum SelectionDirection {\n\t/**\n\t * The selection starts above where it ends.\n\t */\n\tLTR,\n\t/**\n\t * The selection starts below where it ends.\n\t */\n\tRTL\n}\n\n/**\n * A selection in the editor.\n */\nexport interface IEditorSelection extends ISelection, IEditorRange {\n\t/**\n\t * Test if equals other selection.\n\t */\n\tequalsSelection(other:ISelection): boolean;\n\t/**\n\t * Clone this selection.\n\t */\n\tclone(): IEditorSelection;\n\t/**\n\t * Get directions (LTR or RTL).\n\t */\n\tgetDirection(): SelectionDirection;\n\t/**\n\t * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n\t */\n\tsetEndPosition(endLineNumber: number, endColumn: number): IEditorSelection;\n\t/**\n\t * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n\t */\n\tsetStartPosition(startLineNumber: number, startColumn: number): IEditorSelection;\n}\n\n/**\n * Configuration options for editor scrollbars\n */\nexport interface IEditorScrollbarOptions {\n\t/**\n\t * The size of arrows (if displayed).\n\t * Defaults to 11.\n\t */\n\tarrowSize?:number;\n\t/**\n\t * Render vertical scrollbar.\n\t * Accepted values: 'auto', 'visible', 'hidden'.\n\t * Defaults to 'auto'.\n\t */\n\tvertical?:string;\n\t/**\n\t * Render horizontal scrollbar.\n\t * Accepted values: 'auto', 'visible', 'hidden'.\n\t * Defaults to 'auto'.\n\t */\n\thorizontal?:string;\n\t/**\n\t * Cast horizontal and vertical shadows when the content is scrolled.\n\t * Defaults to false.\n\t */\n\tuseShadows?:boolean;\n\t/**\n\t * Render arrows at the top and bottom of the vertical scrollbar.\n\t * Defaults to false.\n\t */\n\tverticalHasArrows?:boolean;\n\t/**\n\t * Render arrows at the left and right of the horizontal scrollbar.\n\t * Defaults to false.\n\t */\n\thorizontalHasArrows?:boolean;\n\t/**\n\t * Listen to mouse wheel events and react to them by scrolling.\n\t * Defaults to true.\n\t */\n\thandleMouseWheel?: boolean;\n\t/**\n\t * Height in pixels for the horizontal scrollbar.\n\t * Defaults to 10 (px).\n\t */\n\thorizontalScrollbarSize?: number;\n\t/**\n\t * Width in pixels for the vertical scrollbar.\n\t * Defaults to 10 (px).\n\t */\n\tverticalScrollbarSize?: number;\n\tverticalSliderSize?: number;\n\thorizontalSliderSize?: number;\n}\n\nexport enum WrappingIndent {\n\tNone = 0,\n\tSame = 1,\n\tIndent = 2\n}\n\nexport function wrappingIndentFromString(wrappingIndent:string): WrappingIndent {\n\tif (wrappingIndent === 'indent') {\n\t\treturn WrappingIndent.Indent;\n\t} else if (wrappingIndent === 'same') {\n\t\treturn WrappingIndent.Same;\n\t} else {\n\t\treturn WrappingIndent.None;\n\t}\n}\n\n/**\n * Configuration options for the editor.\n */\nexport interface IEditorOptions {\n\texperimentalScreenReader?: boolean;\n\tariaLabel?: string;\n\t/**\n\t * Render vertical lines at the specified columns.\n\t * Defaults to empty array.\n\t */\n\trulers?: number[];\n\t/**\n\t * A string containing the word separators used when doing word navigation.\n\t * Defaults to `~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?\n\t */\n\twordSeparators?: string;\n\t/**\n\t * Enable Linux primary clipboard.\n\t * Defaults to true.\n\t */\n\tselectionClipboard?: boolean;\n\t/**\n\t * Control the rendering of line numbers.\n\t * If it is a function, it will be invoked when rendering a line number and the return value will be rendered.\n\t * Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).\n\t * Otherwise, line numbers will not be rendered.\n\t * Defaults to true.\n\t */\n\tlineNumbers?:any;\n\t/**\n\t * Should the corresponding line be selected when clicking on the line number?\n\t * Defaults to true.\n\t */\n\tselectOnLineNumbers?:boolean;\n\t/**\n\t * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.\n\t * Defaults to 5.\n\t */\n\tlineNumbersMinChars?:number;\n\t/**\n\t * Enable the rendering of the glyph margin.\n\t * Defaults to false.\n\t */\n\tglyphMargin?:boolean;\n\t/**\n\t * The width reserved for line decorations (in px).\n\t * Line decorations are placed between line numbers and the editor content.\n\t * Defaults to 10.\n\t */\n\tlineDecorationsWidth?:number;\n\t/**\n\t * When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.\n\t * This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.\n\t * Defaults to 30 (px).\n\t */\n\trevealHorizontalRightPadding?:number;\n\t/**\n\t * Render the editor selection with rounded borders.\n\t * Defaults to true.\n\t */\n\troundedSelection?:boolean;\n\t/**\n\t * Theme to be used for rendering. Consists of two parts, the UI theme and the syntax theme,\n\t * separated by a space.\n\t * The current available UI themes are: 'vs' (default), 'vs-dark', 'hc-black'\n\t * The syntax themes are contributed. The default is 'default-theme'\n\t */\n\ttheme?:string;\n\t/**\n\t * Should the editor be read only.\n\t * Defaults to false.\n\t */\n\treadOnly?:boolean;\n\t/**\n\t * Control the behavior and rendering of the scrollbars.\n\t */\n\tscrollbar?:IEditorScrollbarOptions;\n\t/**\n\t * The number of vertical lanes the overview ruler should render.\n\t * Defaults to 2.\n\t */\n\toverviewRulerLanes?:number;\n\t/**\n\t * Control the cursor blinking animation.\n\t * Defaults to 'blink'.\n\t */\n\tcursorBlinking?:string;\n\t/**\n\t * Control the cursor style, either 'block' or 'line'.\n\t * Defaults to 'line'.\n\t */\n\tcursorStyle?:string;\n\t/**\n\t * Enable font ligatures.\n\t * Defaults to false.\n\t */\n\tfontLigatures?:boolean;\n\t/**\n\t * Should the cursor be hidden in the overview ruler.\n\t * Defaults to false.\n\t */\n\thideCursorInOverviewRuler?:boolean;\n\t/**\n\t * Enable that scrolling can go one screen size after the last line.\n\t * Defaults to true.\n\t */\n\tscrollBeyondLastLine?:boolean;\n\t/**\n\t * Enable that the editor will install an interval to check if its container dom node size has changed.\n\t * Enabling this might have a severe performance impact.\n\t * Defaults to false.\n\t */\n\tautomaticLayout?:boolean;\n\t/**\n\t * Control the wrapping strategy of the editor.\n\t * Using -1 means no wrapping whatsoever.\n\t * Using 0 means viewport width wrapping (ajusts with the resizing of the editor).\n\t * Using a positive number means wrapping after a fixed number of characters.\n\t * Defaults to 300.\n\t */\n\twrappingColumn?:number;\n\t/**\n\t * Control indentation of wrapped lines. Can be: 'none', 'same' or 'indent'.\n\t * Defaults to 'none'.\n\t */\n\twrappingIndent?: string;\n\t/**\n\t * Configure word wrapping characters. A break will be introduced before these characters.\n\t * Defaults to '{([+'.\n\t */\n\twordWrapBreakBeforeCharacters?: string;\n\t/**\n\t * Configure word wrapping characters. A break will be introduced after these characters.\n\t * Defaults to ' \\t})]?|&,;'.\n\t */\n\twordWrapBreakAfterCharacters?: string;\n\t/**\n\t * Configure word wrapping characters. A break will be introduced after these characters only if no `wordWrapBreakBeforeCharacters` or `wordWrapBreakAfterCharacters` were found.\n\t * Defaults to '.'.\n\t */\n\twordWrapBreakObtrusiveCharacters?: string;\n\n//\tautoSize?:boolean;\n\t/**\n\t * Control what pressing Tab does.\n\t * If it is false, pressing Tab or Shift-Tab will be handled by the editor.\n\t * If it is true, pressing Tab or Shift-Tab will move the browser focus.\n\t * Defaults to false.\n\t */\n\ttabFocusMode?:boolean;\n\n\t/**\n\t * Performance guard: Stop tokenizing a line after x characters.\n\t * Defaults to 10000 if wrappingColumn is -1. Defaults to -1 if wrappingColumn is >= 0.\n\t * Use -1 to never stop tokenization.\n\t */\n\tstopLineTokenizationAfter?:number;\n\t/**\n\t * Performance guard: Stop rendering a line after x characters.\n\t * Defaults to 10000 if wrappingColumn is -1. Defaults to -1 if wrappingColumn is >= 0.\n\t * Use -1 to never stop rendering\n\t */\n\tstopRenderingLineAfter?:number;\n\t/**\n\t * Performance guard: Force viewport width wrapping if more than half of the\n\t * characters in a model are on lines of length >= `longLineBoundary`.\n\t * Defaults to 300.\n\t */\n\tlongLineBoundary?:number;\n\t/**\n\t * Performance guard: Tokenize in the background if the [wrapped] lines count is above\n\t * this number. If the [wrapped] lines count is below this number, then the view will\n\t * always force tokenization before rendering.\n\t * Defaults to 1000.\n\t */\n\tforcedTokenizationBoundary?:number;\n\t/**\n\t * Enable hover.\n\t * Defaults to true.\n\t */\n\thover?:boolean;\n\t/**\n\t * Enable custom contextmenu.\n\t * Defaults to true.\n\t */\n\tcontextmenu?:boolean;\n\t/**\n\t * A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.\n\t * Defaults to 1.\n\t */\n\tmouseWheelScrollSensitivity?: number;\n\t/**\n\t * Enable quick suggestions (shaddow suggestions)\n\t * Defaults to true.\n\t */\n\tquickSuggestions?:boolean;\n\t/**\n\t * Quick suggestions show delay (in ms)\n\t * Defaults to 500 (ms)\n\t */\n\tquickSuggestionsDelay?:number;\n\t/**\n\t * Render icons in suggestions box.\n\t * Defaults to true.\n\t */\n\ticonsInSuggestions?:boolean;\n\t/**\n\t * Enable auto closing brackets.\n\t * Defaults to true.\n\t */\n\tautoClosingBrackets?:boolean;\n\t/**\n\t * Enable format on type.\n\t * Defaults to false.\n\t */\n\tformatOnType?:boolean;\n\t/**\n\t * Enable the suggestion box to pop-up on trigger characters.\n\t * Defaults to true.\n\t */\n\tsuggestOnTriggerCharacters?: boolean;\n\t/**\n\t * Accept suggestions on ENTER.\n\t * Defaults to true.\n\t */\n\tacceptSuggestionOnEnter?: boolean;\n\t/**\n\t * Enable selection highlight.\n\t * Defaults to true.\n\t */\n\tselectionHighlight?:boolean;\n\t/**\n\t * Show lines before classes and methods (based on outline info).\n\t * Defaults to false.\n\t */\n\toutlineMarkers?: boolean;\n\t/**\n\t * Show reference infos (a.k.a. code lenses) for modes that support it\n\t * Defaults to true.\n\t */\n\treferenceInfos?: boolean;\n\t/**\n\t * Enable code folding\n\t * Defaults to true.\n\t */\n\tfolding?: boolean;\n\t/**\n\t * Enable rendering of leading whitespace.\n\t * Defaults to false.\n\t */\n\trenderWhitespace?: boolean;\n\t/**\n\t * Enable rendering of indent guides.\n\t * Defaults to true.\n\t */\n\tindentGuides?: boolean;\n\t/**\n\t * The font family\n\t */\n\tfontFamily?: string;\n\t/**\n\t * The font size\n\t */\n\tfontSize?: number;\n\t/**\n\t * The line height\n\t */\n\tlineHeight?: number;\n}\n\n/**\n * Configuration options for the diff editor.\n */\nexport interface IDiffEditorOptions extends IEditorOptions {\n\t/**\n\t * Allow the user to resize the diff editor split view.\n\t * Defaults to true.\n\t */\n\tenableSplitViewResizing?: boolean;\n\t/**\n\t * Render the differences in two side-by-side editors.\n\t * Defaults to true.\n\t */\n\trenderSideBySide?: boolean;\n\t/**\n\t * Compute the diff by ignoring leading/trailing whitespace\n\t * Defaults to true.\n\t */\n\tignoreTrimWhitespace?: boolean;\n\t/**\n\t * Original model should be editable?\n\t * Defaults to false.\n\t */\n\toriginalEditable?: boolean;\n}\n\n/**\n * Internal indentation options (computed) for the editor.\n */\nexport interface IInternalIndentationOptions {\n\t/**\n\t * Tab size in spaces. This is used for rendering and for editing.\n\t */\n\ttabSize:number;\n\t/**\n\t * Insert spaces instead of tabs when indenting or when auto-indenting.\n\t */\n\tinsertSpaces:boolean;\n}\n\nexport interface IInternalEditorScrollbarOptions {\n\tarrowSize:number;\n\tvertical:string;\n\thorizontal:string;\n\tuseShadows:boolean;\n\tverticalHasArrows:boolean;\n\thorizontalHasArrows:boolean;\n\thandleMouseWheel: boolean;\n\thorizontalScrollbarSize: number;\n\thorizontalSliderSize: number;\n\tverticalScrollbarSize: number;\n\tverticalSliderSize: number;\n\tmouseWheelScrollSensitivity: number;\n}\n\nexport interface IEditorWrappingInfo {\n\tisViewportWrapping: boolean;\n\twrappingColumn: number;\n}\n\n/**\n * Internal configuration options (transformed or computed) for the editor.\n */\nexport interface IInternalEditorOptions {\n\texperimentalScreenReader: boolean;\n\trulers: number[];\n\twordSeparators: string;\n\tselectionClipboard: boolean;\n\tariaLabel: string;\n\n\t// ---- Options that are transparent - get no massaging\n\tlineNumbers:any;\n\tselectOnLineNumbers:boolean;\n\tglyphMargin:boolean;\n\trevealHorizontalRightPadding:number;\n\troundedSelection:boolean;\n\ttheme:string;\n\treadOnly:boolean;\n\tscrollbar:IInternalEditorScrollbarOptions;\n\toverviewRulerLanes:number;\n\tcursorBlinking:string;\n\tcursorStyle:TextEditorCursorStyle;\n\tfontLigatures:boolean;\n\thideCursorInOverviewRuler:boolean;\n\tscrollBeyondLastLine:boolean;\n\twrappingIndent: string;\n\twordWrapBreakBeforeCharacters: string;\n\twordWrapBreakAfterCharacters: string;\n\twordWrapBreakObtrusiveCharacters: string;\n\ttabFocusMode:boolean;\n\tstopLineTokenizationAfter:number;\n\tstopRenderingLineAfter: number;\n\tlongLineBoundary:number;\n\tforcedTokenizationBoundary:number;\n\n\t// ---- Options that are transparent - get no massaging\n\thover:boolean;\n\tcontextmenu:boolean;\n\tquickSuggestions:boolean;\n\tquickSuggestionsDelay:number;\n\ticonsInSuggestions:boolean;\n\tautoClosingBrackets:boolean;\n\tformatOnType:boolean;\n\tsuggestOnTriggerCharacters: boolean;\n\tacceptSuggestionOnEnter: boolean;\n\tselectionHighlight:boolean;\n\toutlineMarkers: boolean;\n\treferenceInfos: boolean;\n\tfolding: boolean;\n\trenderWhitespace: boolean;\n\tindentGuides: boolean;\n\n\t// ---- Options that are computed\n\n\tlayoutInfo: IEditorLayoutInfo;\n\n\tstylingInfo: IEditorStyling;\n\n\twrappingInfo: IEditorWrappingInfo;\n\n\t/**\n\t * Computed width of the container of the editor in px.\n\t */\n\tobservedOuterWidth:number;\n\t/**\n\t * Computed height of the container of the editor in px.\n\t */\n\tobservedOuterHeight:number;\n\t/**\n\t * Computed line height (deduced from theme and CSS) in px.\n\t */\n\tlineHeight:number;\n\t/**\n\t * Computed page size (deduced from editor size) in lines.\n\t */\n\tpageSize:number;\n\t/**\n\t * Computed width of 'm' (deduced from theme and CSS) in px.\n\t */\n\ttypicalHalfwidthCharacterWidth:number;\n\t/**\n\t * Computed width of fullwidth 'm' (U+FF4D)\n\t */\n\ttypicalFullwidthCharacterWidth:number;\n\t/**\n\t * Computed width of non breaking space &nbsp;\n\t */\n\tspaceWidth:number;\n\t/**\n\t * Computed font size.\n\t */\n\tfontSize:number;\n}\n\n/**\n * An event describing that the configuration of the editor has changed.\n */\nexport interface IConfigurationChangedEvent {\n\texperimentalScreenReader: boolean;\n\trulers: boolean;\n\twordSeparators: boolean;\n\tselectionClipboard: boolean;\n\tariaLabel: boolean;\n\n\t// ---- Options that are transparent - get no massaging\n\tlineNumbers: boolean;\n\tselectOnLineNumbers: boolean;\n\tglyphMargin: boolean;\n\trevealHorizontalRightPadding: boolean;\n\troundedSelection: boolean;\n\ttheme: boolean;\n\treadOnly: boolean;\n\tscrollbar: boolean;\n\toverviewRulerLanes: boolean;\n\tcursorBlinking: boolean;\n\tcursorStyle: boolean;\n\tfontLigatures: boolean;\n\thideCursorInOverviewRuler: boolean;\n\tscrollBeyondLastLine: boolean;\n\twrappingIndent: boolean;\n\twordWrapBreakBeforeCharacters: boolean;\n\twordWrapBreakAfterCharacters: boolean;\n\twordWrapBreakObtrusiveCharacters: boolean;\n\ttabFocusMode: boolean;\n\tstopLineTokenizationAfter: boolean;\n\tstopRenderingLineAfter: boolean;\n\tlongLineBoundary: boolean;\n\tforcedTokenizationBoundary: boolean;\n\n\t// ---- Options that are transparent - get no massaging\n\thover: boolean;\n\tcontextmenu: boolean;\n\tquickSuggestions: boolean;\n\tquickSuggestionsDelay: boolean;\n\ticonsInSuggestions: boolean;\n\tautoClosingBrackets: boolean;\n\tformatOnType: boolean;\n\tsuggestOnTriggerCharacters: boolean;\n\tselectionHighlight: boolean;\n\toutlineMarkers: boolean;\n\treferenceInfos: boolean;\n\tfolding: boolean;\n\trenderWhitespace: boolean;\n\tindentGuides: boolean;\n\n\t// ---- Options that are computed\n\tlayoutInfo: boolean;\n\tstylingInfo: boolean;\n\twrappingInfo: boolean;\n\tobservedOuterWidth: boolean;\n\tobservedOuterHeight: boolean;\n\tlineHeight: boolean;\n\tpageSize: boolean;\n\ttypicalHalfwidthCharacterWidth: boolean;\n\ttypicalFullwidthCharacterWidth: boolean;\n\tspaceWidth: boolean;\n\tfontSize: boolean;\n}\n\n/**\n * An event describing that one or more supports of a mode have changed.\n */\nexport interface IModeSupportChangedEvent {\n\ttokenizationSupport:boolean;\n\toccurrencesSupport:boolean;\n\tdeclarationSupport:boolean;\n\ttypeDeclarationSupport:boolean;\n\tnavigateTypesSupport:boolean;\n\treferenceSupport:boolean;\n\tsuggestSupport:boolean;\n\tparameterHintsSupport:boolean;\n\textraInfoSupport:boolean;\n\toutlineSupport:boolean;\n\tlogicalSelectionSupport:boolean;\n\tformattingSupport:boolean;\n\tinplaceReplaceSupport:boolean;\n\temitOutputSupport:boolean;\n\tlinkSupport:boolean;\n\tconfigSupport:boolean;\n\tquickFixSupport: boolean;\n\tcodeLensSupport: boolean;\n\trichEditSupport: boolean;\n}\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport enum OverviewRulerLane {\n\tLeft = 1,\n\tCenter = 2,\n\tRight = 4,\n\tFull = 7\n}\n\n/**\n * Options for rendering a model decoration in the overview ruler.\n */\nexport interface IModelDecorationOverviewRulerOptions {\n\t/**\n\t * CSS color to render in the overview ruler.\n\t * e.g.: rgba(100, 100, 100, 0.5)\n\t */\n\tcolor: string;\n\t/**\n\t * CSS color to render in the overview ruler.\n\t * e.g.: rgba(100, 100, 100, 0.5)\n\t */\n\tdarkColor: string;\n\t/**\n\t * The position in the overview ruler.\n\t */\n\tposition: OverviewRulerLane;\n}\n\n/**\n * Options for a model decoration.\n */\nexport interface IModelDecorationOptions {\n\t/**\n\t * Customize the growing behaviour of the decoration when typing at the edges of the decoration.\n\t * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges\n\t */\n\tstickiness?:TrackedRangeStickiness;\n\t/**\n\t * CSS class name describing the decoration.\n\t */\n\tclassName?:string;\n\t/**\n\t * Message to be rendered when hovering over the decoration.\n\t */\n\thoverMessage?:string;\n\t/**\n\t * Array of IHTMLContentElements to render as the decoration message.\n\t */\n\thtmlMessage?:IHTMLContentElement[];\n\t/**\n\t * Should the decoration expand to encompass a whole line.\n\t */\n\tisWholeLine?:boolean;\n\t/**\n\t * @deprecated : Use `overviewRuler` instead\n\t */\n\tshowInOverviewRuler?:string;\n\t/**\n\t * If set, render this decoration in the overview ruler.\n\t */\n\toverviewRuler?:IModelDecorationOverviewRulerOptions;\n\t/**\n\t * If set, the decoration will be rendered in the glyph margin with this CSS class name.\n\t */\n\tglyphMarginClassName?:string;\n\t/**\n\t * If set, the decoration will be rendered in the lines decorations with this CSS class name.\n\t */\n\tlinesDecorationsClassName?:string;\n\t/**\n\t * If set, the decoration will be rendered inline with the text with this CSS class name.\n\t * Please use this only for CSS rules that must impact the text. For example, use `className`\n\t * to have a background color decoration.\n\t */\n\tinlineClassName?:string;\n}\n\n/**\n * New model decorations.\n */\nexport interface IModelDeltaDecoration {\n\t/**\n\t * Range that this decoration covers.\n\t */\n\trange: IRange;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\toptions: IModelDecorationOptions;\n}\n\n/**\n * A tracked range in the model.\n */\nexport interface IModelTrackedRange {\n\t/**\n\t * Identifier for a tracked range\n\t */\n\tid: string;\n\t/**\n\t * Range that this tracked range covers\n\t */\n\trange: IEditorRange;\n}\n\n/**\n * A decoration in the model.\n */\nexport interface IModelDecoration {\n\t/**\n\t * Identifier for a decoration.\n\t */\n\tid: string;\n\t/**\n\t * Identifier for a decoration's owener.\n\t */\n\townerId: number;\n\t/**\n\t * Range that this decoration covers.\n\t */\n\trange: IEditorRange;\n\t/**\n\t * Options associated with this decoration.\n\t */\n\toptions: IModelDecorationOptions;\n}\n\n/**\n * An accessor that can add, change or remove model decorations.\n */\nexport interface IModelDecorationsChangeAccessor {\n\t/**\n\t * Add a new decoration.\n\t * @param range Range that this decoration covers.\n\t * @param options Options associated with this decoration.\n\t * @return An unique identifier associated with this decoration.\n\t */\n\taddDecoration(range:IRange, options:IModelDecorationOptions): string;\n\t/**\n\t * Change the range that an existing decoration covers.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newRange The new range that this decoration covers.\n\t */\n\tchangeDecoration(id:string, newRange:IRange): void;\n\t/**\n\t * Change the options associated with an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t * @param newOptions The new options associated with this decoration.\n\t */\n\tchangeDecorationOptions(id: string, newOptions:IModelDecorationOptions): void;\n\t/**\n\t * Remove an existing decoration.\n\t * @param id The unique identifier associated with the decoration.\n\t */\n\tremoveDecoration(id:string): void;\n\t/**\n\t * Perform a minimum ammount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations:string[], newDecorations:IModelDeltaDecoration[]): string[];\n}\n\n/**\n * Word inside a model.\n */\nexport interface IWordAtPosition {\n\t/**\n\t * The word.\n\t */\n\tword: string;\n\t/**\n\t * The column where the word starts.\n\t */\n\tstartColumn: number;\n\t/**\n\t * The column where the word ends.\n\t */\n\tendColumn: number;\n}\n\n/**\n * Range of a word inside a model.\n */\nexport interface IWordRange {\n\t/**\n\t * The column where the word starts.\n\t */\n\tstart:number;\n\t/**\n\t * The column where the word ends.\n\t */\n\tend:number;\n}\n\nexport interface ITokenInfo {\n\ttoken: IToken;\n\tlineNumber: number;\n\tstartColumn: number;\n\tendColumn: number;\n}\n\nexport interface ITokenIterator {\n\thasNext(): boolean;\n\tnext(): ITokenInfo;\n\thasPrev(): boolean;\n\tprev(): ITokenInfo;\n}\n\n/**\n * End of line character preference.\n */\nexport enum EndOfLinePreference {\n\t/**\n\t * Use the end of line character identified in the text buffer.\n\t */\n\tTextDefined = 0,\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * The default end of line to use when instantiating models.\n */\nexport enum DefaultEndOfLine {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 1,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 2\n}\n\n/**\n * End of line character preference.\n */\nexport enum EndOfLineSequence {\n\t/**\n\t * Use line feed (\\n) as the end of line character.\n\t */\n\tLF = 0,\n\t/**\n\t * Use carriage return and line feed (\\r\\n) as the end of line character.\n\t */\n\tCRLF = 1\n}\n\n/**\n * The result of a matchBracket operation.\n */\nexport interface IMatchBracketResult {\n\t/**\n\t * The two ranges describing matching brackets, or null\n\t */\n\tbrackets:IEditorRange[];\n\t/**\n\t * Indicates that the bracket match result is not accurate because the search\n\t * hit some untokenized lines.\n\t */\n\tisAccurate:boolean;\n}\n\n/**\n * A read-only line marker in the model.\n */\nexport interface IReadOnlyLineMarker {\n\tid: string;\n\tcolumn: number;\n}\n\n/**\n * And identifier for a single edit operation.\n */\nexport interface ISingleEditOperationIdentifier {\n\t/**\n\t * Identifier major\n\t */\n\tmajor:number;\n\t/**\n\t * Identifier minor\n\t */\n\tminor:number;\n}\n\n/**\n * A builder and helper for edit operations for a command.\n */\nexport interface IEditOperationBuilder {\n\t/**\n\t * Add a new edit operation (a replace operation).\n\t * @param range The range to replace (delete). May be empty to represent a simple insert.\n\t * @param text The text to replace with. May be null to represent a simple delete.\n\t */\n\taddEditOperation(range:IEditorRange, text:string): void;\n\n\t/**\n\t * Track `selection` when applying edit operations.\n\t * A best effort will be made to not grow/expand the selection.\n\t * An empty selection will clamp to a nearby character.\n\t * @param selection The selection to track.\n\t * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection\n\t *           should clamp to the previous or the next character.\n\t * @return A unique identifer.\n\t */\n\ttrackSelection(selection:IEditorSelection, trackPreviousOnEmpty?:boolean): string;\n}\n\n/**\n * A helper for computing cursor state after a command.\n */\nexport interface ICursorStateComputerData {\n\t/**\n\t * Get the inverse edit operations of the added edit operations.\n\t */\n\tgetInverseEditOperations(): IIdentifiedSingleEditOperation[];\n\t/**\n\t * Get a previously tracked selection.\n\t * @param id The unique identifier returned by `trackSelection`.\n\t * @return The selection.\n\t */\n\tgetTrackedSelection(id:string): IEditorSelection;\n}\n\n/**\n * A command that modifies text / cursor state on a model.\n */\nexport interface ICommand {\n\t/**\n\t * Get the edit operations needed to execute this command.\n\t * @param model The model the command will execute on.\n\t * @param builder A helper to collect the needed edit operations and to track selections.\n\t */\n\tgetEditOperations(model:ITokenizedModel, builder:IEditOperationBuilder): void;\n\t/**\n\t * Compute the cursor state after the edit operations were applied.\n\t * @param model The model the commad has executed on.\n\t * @param helper A helper to get inverse edit operations and to get previously tracked selections.\n\t * @return The cursor state after the command executed.\n\t */\n\tcomputeCursorState(model:ITokenizedModel, helper:ICursorStateComputerData): IEditorSelection;\n}\n\n/**\n * A single edit operation, that acts as a simple replace.\n * i.e. Replace text at `range` with `text` in model.\n */\nexport interface ISingleEditOperation {\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: IRange;\n\t/**\n\t * The text to replace with. This can be null to emulate a simple delete.\n\t */\n\ttext: string;\n\t/**\n\t * This indicates that this operation has \"insert\" semantics.\n\t * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.\n\t */\n\tforceMoveMarkers?: boolean;\n}\n\n/**\n * A single edit operation, that has an identifier.\n */\nexport interface IIdentifiedSingleEditOperation {\n\t/**\n\t * An identifier associated with this single edit operation.\n\t */\n\tidentifier: ISingleEditOperationIdentifier;\n\t/**\n\t * The range to replace. This can be empty to emulate a simple insert.\n\t */\n\trange: IEditorRange;\n\t/**\n\t * The text to replace with. This can be null to emulate a simple delete.\n\t */\n\ttext: string;\n\t/**\n\t * This indicates that this operation has \"insert\" semantics.\n\t * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.\n\t */\n\tforceMoveMarkers: boolean;\n}\n\n\n/**\n * A callback that can compute the cursor state after applying a series of edit operations.\n */\nexport interface ICursorStateComputer {\n\t/**\n\t * A callback that can compute the resulting cursors state after some edit operations have been executed.\n\t */\n\t(inverseEditOperations:IIdentifiedSingleEditOperation[]): IEditorSelection[];\n}\n\n/**\n * A token on a line.\n */\nexport class ViewLineToken {\n\tpublic _viewLineTokenTrait: void;\n\n\tpublic startIndex:number;\n\tpublic type:string;\n\n\tconstructor(startIndex:number, type:string) {\n\t\tthis.startIndex = startIndex|0;// @perf\n\t\tthis.type = type.replace(/[^a-z0-9\\-]/gi, ' ');\n\t}\n\n\tpublic equals(other:ViewLineToken): boolean {\n\t\treturn (\n\t\t\tthis.startIndex === other.startIndex\n\t\t\t&& this.type === other.type\n\t\t);\n\t}\n\n\tpublic static findIndexInSegmentsArray(arr:ViewLineToken[], desiredIndex: number): number {\n\t\treturn Arrays.findIndexInSegmentsArray(arr, desiredIndex);\n\t}\n\n\tpublic static equalsArray(a:ViewLineToken[], b:ViewLineToken[]): boolean {\n\t\tlet aLen = a.length;\n\t\tlet bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!a[i].equals(b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\n/**\n * A token on a line.\n */\nexport class LineToken {\n\tpublic _lineTokenTrait: void;\n\n\tpublic startIndex:number;\n\tpublic type:string;\n\n\tconstructor(startIndex:number, type:string) {\n\t\tthis.startIndex = startIndex|0;// @perf\n\t\tthis.type = type;\n\t}\n\n\tpublic equals(other:LineToken): boolean {\n\t\treturn (\n\t\t\tthis.startIndex === other.startIndex\n\t\t\t&& this.type === other.type\n\t\t);\n\t}\n\n\tpublic static findIndexInSegmentsArray(arr:LineToken[], desiredIndex: number): number {\n\t\treturn Arrays.findIndexInSegmentsArray(arr, desiredIndex);\n\t}\n\n\tpublic static equalsArray(a:LineToken[], b:LineToken[]): boolean {\n\t\tlet aLen = a.length;\n\t\tlet bLen = b.length;\n\t\tif (aLen !== bLen) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < aLen; i++) {\n\t\t\tif (!a[i].equals(b[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport interface ITokensInflatorMap {\n\t_inflate:string[];\n\t_deflate: { [token:string]:number; };\n}\n\nexport interface ILineTokensBinaryEncoding {\n\tSTART_INDEX_MASK: number;\n\tTYPE_MASK: number;\n\tSTART_INDEX_OFFSET: number;\n\tTYPE_OFFSET: number;\n\n\tdeflateArr(map:ITokensInflatorMap, tokens:IToken[]): number[];\n\tinflate(map:ITokensInflatorMap, binaryEncodedToken:number): IToken;\n\tgetStartIndex(binaryEncodedToken:number): number;\n\tgetType(map:ITokensInflatorMap, binaryEncodedToken:number): string;\n\tinflateArr(map:ITokensInflatorMap, binaryEncodedTokens:number[]): IToken[];\n\tfindIndexOfOffset(binaryEncodedTokens:number[], offset:number): number;\n\tsliceAndInflate(map:ITokensInflatorMap, binaryEncodedTokens:number[], startOffset:number, endOffset:number, deltaStartIndex:number): IToken[];\n}\n\n/**\n * A list of tokens on a line.\n */\nexport interface ILineTokens {\n\t/**\n\t * Get the binary representation of tokens.\n\t */\n\tgetBinaryEncodedTokens(): number[];\n\n\t/**\n\t * A map to help decoding the token type.\n\t */\n\tgetBinaryEncodedTokensMap(): ITokensInflatorMap;\n\n\tgetTokenCount(): number;\n\tgetTokenStartIndex(tokenIndex:number): number;\n\tgetTokenType(tokenIndex:number): string;\n\tgetTokenEndIndex(tokenIndex:number, textLength:number): number;\n\n\t/**\n\t * Check if tokens have changed. This is called by the view to validate rendered lines\n\t * and decide which lines need re-rendering.\n\t */\n\tequals(other:ILineTokens): boolean;\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t *    For example, with the following tokens [0, 5), [5, 9), [9, infinity)\n\t *    Searching for 0, 1, 2, 3 or 4 will return 0.\n\t *    Searching for 5, 6, 7 or 8 will return 1.\n\t *    Searching for 9, 10, 11, ... will return 2.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tfindIndexOfOffset(offset:number): number;\n}\n\n/**\n * Result for a ITextModel.guessIndentation\n */\nexport interface IGuessedIndentation {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n}\n\nexport interface ITextModelResolvedOptions {\n\ttabSize: number;\n\tinsertSpaces: boolean;\n\tdefaultEOL: DefaultEndOfLine;\n}\n\nexport interface ITextModelCreationOptions {\n\ttabSize: number;\n\tinsertSpaces: boolean;\n\tdetectIndentation: boolean;\n\tdefaultEOL: DefaultEndOfLine;\n}\n\nexport interface ITextModelUpdateOptions {\n\ttabSize?: number;\n\tinsertSpaces?: boolean;\n}\n\nexport interface IModelOptionsChangedEvent {\n\ttabSize: boolean;\n\tinsertSpaces: boolean;\n}\n\n/**\n * A textual read-only model.\n */\nexport interface ITextModel {\n\n\tgetOptions(): ITextModelResolvedOptions;\n\n\t/**\n\t * Get the current version id of the model.\n\t * Anytime a change happens to the model (even undo/redo),\n\t * the version id is incremented.\n\t */\n\tgetVersionId(): number;\n\n\t/**\n\t * Get the alternative version id of the model.\n\t * This alternative version id is not always incremented,\n\t * it will return the same values in the case of undo-redo.\n\t */\n\tgetAlternativeVersionId(): number;\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t */\n\tsetValue(newValue:string): void;\n\n\t/**\n\t * Get the text stored in this model.\n\t * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.\n\t * @return The text.\n\t */\n\tgetValue(eol?:EndOfLinePreference, preserveBOM?:boolean): string;\n\n\tgetValueLength(eol?:EndOfLinePreference, preserveBOM?:boolean): number;\n\n\ttoRawText(): IRawText;\n\n\tequals(other:IRawText): boolean;\n\n\t/**\n\t * Get the text in a certain range.\n\t * @param range The range describing what text to get.\n\t * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.\n\t * @return The text.\n\t */\n\tgetValueInRange(range:IRange, eol?:EndOfLinePreference): string;\n\n\t/**\n\t * Get the length of text in a certain range.\n\t * @param range The range describing what text length to get.\n\t * @return The text length.\n\t */\n\tgetValueLengthInRange(range:IRange): number;\n\n\t/**\n\t * Splits characters in two buckets. First bucket (A) is of characters that\n\t * sit in lines with length < `longLineBoundary`. Second bucket (B) is of\n\t * characters that sit in lines with length >= `longLineBoundary`.\n\t * If count(B) > count(A) return true. Returns false otherwise.\n\t */\n\tisDominatedByLongLines(longLineBoundary:number): boolean;\n\n\t/**\n\t * Get the number of lines in the model.\n\t */\n\tgetLineCount(): number;\n\n\t/**\n\t * Get the text for a certain line.\n\t */\n\tgetLineContent(lineNumber:number): string;\n\n\t/**\n\t * Get the text for all lines.\n\t */\n\tgetLinesContent(): string[];\n\n\t/**\n\t * Get the end of line character predominantly used in the text buffer.\n\t * @return EOL char sequence (e.g.: '\\n' or '\\r\\n').\n\t */\n\tgetEOL(): string;\n\n\tsetEOL(eol: EndOfLineSequence): void;\n\n\t/**\n\t * Get the minimum legal column for line at `lineNumber`\n\t */\n\tgetLineMinColumn(lineNumber:number): number;\n\n\t/**\n\t * Get the maximum legal column for line at `lineNumber`\n\t */\n\tgetLineMaxColumn(lineNumber:number): number;\n\n\t/**\n\t * Returns the column before the first non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineFirstNonWhitespaceColumn(lineNumber:number): number;\n\n\t/**\n\t * Returns the column after the last non whitespace character for line at `lineNumber`.\n\t * Returns 0 if line is empty or contains only whitespace.\n\t */\n\tgetLineLastNonWhitespaceColumn(lineNumber:number): number;\n\n\t/**\n\t * Create a valid position,\n\t */\n\tvalidatePosition(position:IPosition): IEditorPosition;\n\n\t/**\n\t * Advances the given position by the given offest (negative offsets are also accepted)\n\t * and returns it as a new valid position.\n\t *\n\t * If the offset and position are such that their combination goes beyond the beginning or\n\t * end of the model, throws an exception.\n\t *\n\t * If the ofsset is such that the new position would be in the middle of a multi-byte\n\t * line terminator, throws an exception.\n\t */\n\tmodifyPosition(position: IPosition, offset: number): IEditorPosition;\n\n\t/**\n\t * Create a valid range.\n\t */\n\tvalidateRange(range:IRange): IEditorRange;\n\n\t/**\n\t * Get a range covering the entire model\n\t */\n\tgetFullModelRange(): IEditorRange;\n\n\t/**\n\t * Returns iff the model was disposed or not.\n\t */\n\tisDisposed(): boolean;\n}\n\nexport interface IRichEditBracket {\n\tmodeId: string;\n\topen: string;\n\tclose: string;\n\tforwardRegex: RegExp;\n\treversedRegex: RegExp;\n}\n\nexport interface IFoundBracket {\n\trange: IEditorRange;\n\topen: string;\n\tclose: string;\n\tisOpen: boolean;\n}\n\n/**\n * A model that is tokenized.\n */\nexport interface ITokenizedModel extends ITextModel {\n\n\t/**\n\t * Set the value at which to stop tokenization.\n\t * The default is 10000.\n\t */\n\tsetStopLineTokenizationAfter(stopLineTokenizationAfter:number): void;\n\n\t/**\n\t * Tokenize if necessary and get the tokens for the line `lineNumber`.\n\t * @param lineNumber The line number\n\t * @param inaccurateTokensAcceptable Are inaccurate tokens acceptable? Defaults to false\n\t */\n\tgetLineTokens(lineNumber:number, inaccurateTokensAcceptable?:boolean): ILineTokens;\n\n\t/**\n\t * Tokenize if necessary and get the tokenization result for the line `lineNumber`, as returned by the language mode.\n\t */\n\tgetLineContext(lineNumber:number): ILineContext;\n\n\t/*package*/_getLineModeTransitions(lineNumber:number): IModeTransition[];\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t * Optionally, the language mode of the model can be changed.\n\t * This call clears all of the undo / redo stack,\n\t * removes all decorations or tracked ranges, emits a\n\t * ModelContentChanged(ModelContentChangedFlush) event and\n\t * unbinds the mirror model from the previous mode to the new\n\t * one if the mode has changed.\n\t */\n\tsetValue(newValue:string, newMode?:IMode): void;\n\n\t/**\n\t * Get the current language mode associated with the model.\n\t */\n\tgetMode(): IMode;\n\n\t/**\n\t * Set the current language mode associated with the model.\n\t */\n\tsetMode(newMode:IMode): void;\n\tsetMode(newModePromise:TPromise<IMode>): void;\n\t/**\n\t * A mode can be currently pending loading if a promise is used when constructing a model or calling setMode().\n\t *\n\t * If there is no currently pending loading mode, then the result promise will complete immediately.\n\t * Otherwise, the result will complete once the currently pending loading mode is loaded.\n\t */\n\twhenModeIsReady(): TPromise<IMode>;\n\n\t/**\n\t * Returns the true (inner-most) language mode at a given position.\n\t */\n\tgetModeAtPosition(lineNumber:number, column:number): IMode;\n\n\t/**\n\t * Get the word under or besides `position`.\n\t * @param position The position to look for a word.\n\t * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.\n\t * @return The word under or besides `position`. Might be null.\n\t */\n\tgetWordAtPosition(position:IPosition): IWordAtPosition;\n\n\t/**\n\t * Get the word under or besides `position` trimmed to `position`.column\n\t * @param position The position to look for a word.\n\t * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.\n\t * @return The word under or besides `position`. Will never be null.\n\t */\n\tgetWordUntilPosition(position:IPosition): IWordAtPosition;\n\n\t/**\n\t * Get the words on line `lineNumber`.\n\t * @param lineNumber The lineNumber\n\t * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.\n\t * @return All the words on the line.\n\t */\n\tgetWords(lineNumber:number): IWordRange[];\n\n\t/**\n\t * Returns an iterator that can be used to read\n\t * next and previous tokens from the provided position.\n\t * The iterator is made available through the callback\n\t * function and can't be used afterwards.\n\t */\n\ttokenIterator(position: IPosition, callback: (it: ITokenIterator) =>any): any;\n\n\t/**\n\t * Find the matching bracket of `request` up, counting brackets.\n\t * @param request The bracket we're searching for\n\t * @param position The position at which to start the search.\n\t * @return The range of the matching bracket, or null if the bracket match was not found.\n\t */\n\tfindMatchingBracketUp(bracket:string, position:IPosition): IEditorRange;\n\n\t/**\n\t * Find the first bracket in the model before `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.\n\t */\n\tfindPrevBracket(position:IPosition): IFoundBracket;\n\n\t/**\n\t * Find the first bracket in the model after `position`.\n\t * @param position The position at which to start the search.\n\t * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.\n\t */\n\tfindNextBracket(position:IPosition): IFoundBracket;\n\n\t/**\n\t * Given a `position`, if the position is on top or near a bracket,\n\t * find the matching bracket of that bracket and return the ranges of both brackets.\n\t * @param position The position at which to look for a bracket.\n\t */\n\tmatchBracket(position:IPosition, inaccurateResultAcceptable?:boolean): IMatchBracketResult;\n\n\t/**\n\t * No mode supports allowed on this model because it is simply too large.\n\t * (even tokenization would cause too much memory pressure)\n\t */\n\tisTooLargeForHavingAMode(): boolean;\n\n\t/**\n\t * Only basic mode supports allowed on this model because it is simply too large.\n\t * (tokenization is allowed and other basic supports)\n\t */\n\tisTooLargeForHavingARichMode(): boolean;\n}\n\n/**\n * A model that can track markers.\n */\nexport interface ITextModelWithMarkers extends ITextModel {\n\t/*package*/_addMarker(lineNumber:number, column:number, stickToPreviousCharacter:boolean): string;\n\t/*package*/_changeMarker(id:string, newLineNumber:number, newColumn:number): void;\n\t/*package*/_changeMarkerStickiness(id:string, newStickToPreviousCharacter:boolean): void;\n\t/*package*/_getMarker(id:string): IEditorPosition;\n\t/*package*/_removeMarker(id:string): void;\n\t/*package*/_getLineMarkers(lineNumber: number): IReadOnlyLineMarker[];\n}\n\n/**\n * A map of changed ranges used during the model internal processing\n */\nexport interface IChangedTrackedRanges {\n\t[key:string]:IRange;\n}\n\nexport enum TrackedRangeStickiness {\n\tAlwaysGrowsWhenTypingAtEdges = 0,\n\tNeverGrowsWhenTypingAtEdges = 1,\n\tGrowsOnlyWhenTypingBefore = 2,\n\tGrowsOnlyWhenTypingAfter = 3,\n}\n\n/**\n * A model that can track ranges.\n */\nexport interface ITextModelWithTrackedRanges extends ITextModel {\n\t/**\n\t * Start tracking a range (across edit operations).\n\t * @param range The range to start tracking.\n\t * @param stickiness The behaviour when typing at the edges of the range.\n\t * @return A unique identifier for the tracked range.\n\t */\n\taddTrackedRange(range:IRange, stickiness:TrackedRangeStickiness): string;\n\n\t/**\n\t * Change the range of a tracked range.\n\t * @param id The id of the tracked range, as returned by a `addTrackedRange` call.\n\t * @param newRange The new range of the tracked range.\n\t */\n\tchangeTrackedRange(id:string, newRange:IRange): void;\n\n\t/**\n\t * Change the stickiness (behaviour when typing at the edges of the range) for a tracked range.\n\t * @param id The id of the tracked range, as returned by a `addTrackedRange` call.\n\t * @param newStickiness The new behaviour when typing at the edges of the range.\n\t */\n\tchangeTrackedRangeStickiness(id:string, newStickiness:TrackedRangeStickiness): void;\n\n\t/**\n\t * Remove a tracked range.\n\t * @param id The id of the tracked range, as returned by a `addTrackedRaneg` call.\n\t */\n\tremoveTrackedRange(id:string): void;\n\n\t/**\n\t * Get the range of a tracked range.\n\t * @param id The id of the tracked range, as returned by a `addTrackedRaneg` call.\n\t */\n\tgetTrackedRange(id:string): IEditorRange;\n\n\t/**\n\t * Gets all the tracked ranges for the lines between `startLineNumber` and `endLineNumber` as an array.\n\t * @param startLineNumber The start line number\n\t * @param endLineNumber The end line number\n\t * @return An array with the tracked ranges\n\t */\n\tgetLinesTrackedRanges(startLineNumber:number, endLineNumber:number): IModelTrackedRange[];\n}\n\n/**\n * A model that can have decorations.\n */\nexport interface ITextModelWithDecorations {\n\t/**\n\t * Change the decorations. The callback will be called with a change accessor\n\t * that becomes invalid as soon as the callback finishes executing.\n\t * This allows for all events to be queued up until the change\n\t * is completed. Returns whatever the callback returns.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t */\n\tchangeDecorations(callback: (changeAccessor:IModelDecorationsChangeAccessor)=>any, ownerId?:number): any;\n\n\t/**\n\t * Perform a minimum ammount of operations, in order to transform the decorations\n\t * identified by `oldDecorations` to the decorations described by `newDecorations`\n\t * and returns the new identifiers associated with the resulting decorations.\n\t *\n\t * @param oldDecorations Array containing previous decorations identifiers.\n\t * @param newDecorations Array describing what decorations should result after the call.\n\t * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.\n\t * @return An array containing the new decorations identifiers.\n\t */\n\tdeltaDecorations(oldDecorations:string[], newDecorations:IModelDeltaDecoration[], ownerId?:number): string[];\n\n\t/**\n\t * Remove all decorations that have been added with this specific ownerId.\n\t * @param ownerId The owner id to search for.\n\t */\n\tremoveAllDecorationsWithOwnerId(ownerId:number): void;\n\n\t/**\n\t * Get the options associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration options or null if the decoration was not found.\n\t */\n\tgetDecorationOptions(id:string): IModelDecorationOptions;\n\n\t/**\n\t * Get the range associated with a decoration.\n\t * @param id The decoration id.\n\t * @return The decoration range or null if the decoration was not found.\n\t */\n\tgetDecorationRange(id:string): IEditorRange;\n\n\t/**\n\t * Gets all the decorations for the line `lineNumber` as an array.\n\t * @param lineNumber The line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @return An array with the decorations\n\t */\n\tgetLineDecorations(lineNumber:number, ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.\n\t * @param startLineNumber The start line number\n\t * @param endLineNumber The end line number\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @return An array with the decorations\n\t */\n\tgetLinesDecorations(startLineNumber:number, endLineNumber:number, ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the deocorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.\n\t * So for now it returns all the decorations on the same line as `range`.\n\t * @param range The range to search in\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t * @return An array with the decorations\n\t */\n\tgetDecorationsInRange(range:IRange, ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];\n\n\t/**\n\t * Gets all the decorations as an array.\n\t * @param ownerId If set, it will ignore decorations belonging to other owners.\n\t * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).\n\t */\n\tgetAllDecorations(ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];\n}\n\n/**\n * An editable text model.\n */\nexport interface IEditableTextModel extends ITextModelWithMarkers {\n\n\tnormalizeIndentation(str:string): string;\n\n\tgetOneIndent(): string;\n\n\tupdateOptions(newOpts:ITextModelUpdateOptions): void;\n\n\tdetectIndentation(defaultInsertSpaces:boolean, defaultTabSize:number): void;\n\n\t/**\n\t * Push a stack element onto the undo stack. This acts as an undo/redo point.\n\t * The idea is to use `pushEditOperations` to edit the model and then to\n\t * `pushStackElement` to create an undo/redo stop point.\n\t */\n\tpushStackElement(): void;\n\n\t/**\n\t * Push edit operations, basically editing the model. This is the preferred way\n\t * of editing the model. The edit operations will land on the undo stack.\n\t * @param beforeCursorState The cursor state before the edit operaions. This cursor state will be returned when `undo` or `redo` are invoked.\n\t * @param editOperations The edit operations.\n\t * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.\n\t * @return The cursor state returned by the `cursorStateComputer`.\n\t */\n\tpushEditOperations(beforeCursorState:IEditorSelection[], editOperations:IIdentifiedSingleEditOperation[], cursorStateComputer:ICursorStateComputer): IEditorSelection[];\n\n\t/**\n\t * Edit the model without adding the edits to the undo stack.\n\t * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.\n\t * @param operations The edit operations.\n\t * @return The inverse edit operations, that, when applied, will bring the model back to the previous state.\n\t */\n\tapplyEdits(operations:IIdentifiedSingleEditOperation[]): IIdentifiedSingleEditOperation[];\n\n\t/**\n\t * Undo edit operations until the first previous stop point created by `pushStackElement`.\n\t * The inverse edit operations will be pushed on the redo stack.\n\t */\n\tundo(): IEditorSelection[];\n\n\t/**\n\t * Redo edit operations until the next stop point created by `pushStackElement`.\n\t * The inverse edit operations will be pushed on the undo stack.\n\t */\n\tredo(): IEditorSelection[];\n\n\t/**\n\t * Set an editable range on the model.\n\t */\n\tsetEditableRange(range:IRange): void;\n\n\t/**\n\t * Check if the model has an editable range.\n\t */\n\thasEditableRange(): boolean;\n\n\t/**\n\t * Get the editable range on the model.\n\t */\n\tgetEditableRange(): IEditorRange;\n}\n\n/**\n * A model.\n */\nexport interface IModel extends IEditableTextModel, ITextModelWithMarkers, ITokenizedModel, ITextModelWithTrackedRanges, ITextModelWithDecorations, IEventEmitter, IEditorModel {\n\t/**\n\t * A unique identifier associated with this model.\n\t */\n\tid: string;\n\n\t/**\n\t * Destroy this model. This will unbind the model from the mode\n\t * and make all necessary clean-up to release this object to the GC.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Gets the resource associated with this editor model.\n\t */\n\tgetAssociatedResource(): URI;\n\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wholeWord Force the matching to match entire words only.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if not matches have been found.\n\t */\n\tfindMatches(searchString:string, searchOnlyEditableRange:boolean, isRegex:boolean, matchCase:boolean, wholeWord:boolean, limitResultCount?:number): IEditorRange[];\n\t/**\n\t * Search the model.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchScope Limit the searching to only search inside this range.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wholeWord Force the matching to match entire words only.\n\t * @param limitResultCount Limit the number of results\n\t * @return The ranges where the matches are. It is empty if no matches have been found.\n\t */\n\tfindMatches(searchString:string, searchScope:IRange, isRegex:boolean, matchCase:boolean, wholeWord:boolean, limitResultCount?:number): IEditorRange[];\n\t/**\n\t * Search the model for the next match. Loops to the beginning of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wholeWord Force the matching to match entire words only.\n\t * @return The range where the next match is. It is null if no next match has been found.\n\t */\n\tfindNextMatch(searchString:string, searchStart:IPosition, isRegex:boolean, matchCase:boolean, wholeWord:boolean): IEditorRange;\n\t/**\n\t * Search the model for the previous match. Loops to the end of the model if needed.\n\t * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.\n\t * @param searchStart Start the searching at the specified position.\n\t * @param isRegex Used to indicate that `searchString` is a regular expression.\n\t * @param matchCase Force the matching to match lower/upper case exactly.\n\t * @param wholeWord Force the matching to match entire words only.\n\t * @return The range where the previous match is. It is null if no previous match has been found.\n\t */\n\tfindPreviousMatch(searchString:string, searchStart:IPosition, isRegex:boolean, matchCase:boolean, wholeWord:boolean): IEditorRange;\n\n\t/**\n\t * Replace the entire text buffer value contained in this model.\n\t * Optionally, the language mode of the model can be changed.\n\t * This call clears all of the undo / redo stack,\n\t * removes all decorations or tracked ranges, emits a\n\t * ModelContentChanged(ModelContentChangedFlush) event and\n\t * unbinds the mirror model from the previous mode to the new\n\t * one if the mode has changed.\n\t */\n\tsetValue(newValue:string, newMode?:IMode): void;\n\tsetValue(newValue:string, newModePromise:TPromise<IMode>): void;\n\n\tsetValueFromRawText(newValue:IRawText, newMode?:IMode): void;\n\tsetValueFromRawText(newValue:IRawText, newModePromise:TPromise<IMode>): void;\n\n\tonBeforeAttached(): void;\n\n\tonBeforeDetached(): void;\n\n\tgetModeId(): string;\n\n\t/**\n\t * Returns iff this model is attached to an editor or not.\n\t */\n\tisAttachedToEditor(): boolean;\n}\n\nexport interface IRangeWithText {\n\ttext:string;\n\trange:IRange;\n}\n\nexport interface IMirrorModel extends IEventEmitter, ITokenizedModel {\n\tgetEmbeddedAtPosition(position:IPosition): IMirrorModel;\n\tgetAllEmbedded(): IMirrorModel[];\n\n\tgetAssociatedResource(): URI;\n\n\tgetOffsetFromPosition(position:IPosition): number;\n\tgetPositionFromOffset(offset:number): IPosition;\n\tgetOffsetAndLengthFromRange(range:IRange): {offset:number; length:number;};\n\tgetRangeFromOffsetAndLength(offset:number, length:number): IRange;\n\tgetLineStart(lineNumber:number): number;\n\n\tgetAllWordsWithRange(): IRangeWithText[];\n\tgetAllUniqueWords(skipWordOnce?:string): string[];\n}\n\n/**\n * An event describing that the current mode associated with a model has changed.\n */\nexport interface IModelModeChangedEvent {\n\t/**\n\t * Previous mode\n\t */\n\toldMode:IMode;\n\t/**\n\t * New mode\n\t */\n\tnewMode:IMode;\n}\n\n/**\n * An event describing a change in the text of a model.\n */\nexport interface IModelContentChangedEvent2 {\n\t/**\n\t * The range that got replaced.\n\t */\n\trange: IRange;\n\t/**\n\t * The length of the range that got replaced.\n\t */\n\trangeLength: number;\n\t/**\n\t * The new text for the range.\n\t */\n\ttext: string;\n\t/**\n\t * The end-of-line character.\n\t */\n\teol: string;\n\t/**\n\t * The new version id the model has transitioned to.\n\t */\n\tversionId: number;\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\tisUndoing: boolean;\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\tisRedoing: boolean;\n}\n/**\n * An event describing a change in the text of a model.\n */\nexport interface IModelContentChangedEvent {\n\t/**\n\t * The event type. It can be used to detect the actual event type:\n\t * \t\tEditorCommon.EventType.ModelContentChangedFlush => IModelContentChangedFlushEvent\n\t * \t\tEditorCommon.EventType.ModelContentChangedLinesDeleted => IModelContentChangedLineChangedEvent\n\t * \t\tEditorCommon.EventType.ModelContentChangedLinesInserted => IModelContentChangedLinesDeletedEvent\n\t * \t\tEditorCommon.EventType.ModelContentChangedLineChanged => IModelContentChangedLinesInsertedEvent\n\t */\n\tchangeType: string;\n\t/**\n\t * The new version id the model has transitioned to.\n\t */\n\tversionId: number;\n\t/**\n\t * Flag that indicates that this event was generated while undoing.\n\t */\n\tisUndoing: boolean;\n\t/**\n\t * Flag that indicates that this event was generated while redoing.\n\t */\n\tisRedoing: boolean;\n}\nexport interface IRawText {\n\tlength: number;\n\tlines: string[];\n\tBOM: string;\n\tEOL: string;\n\toptions: ITextModelResolvedOptions;\n}\n/**\n * An event describing that a model has been reset to a new value.\n */\nexport interface IModelContentChangedFlushEvent extends IModelContentChangedEvent {\n\t/**\n\t * The new text content of the model.\n\t */\n\tdetail: IRawText;\n}\n/**\n * An event describing that a line has changed in a model.\n */\nexport interface IModelContentChangedLineChangedEvent extends IModelContentChangedEvent {\n\t/**\n\t * The line that has changed.\n\t */\n\tlineNumber: number;\n\t/**\n\t * The new value of the line.\n\t */\n\tdetail: string;\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n */\nexport interface IModelContentChangedLinesDeletedEvent extends IModelContentChangedEvent {\n\t/**\n\t * At what line the deletion began (inclusive).\n\t */\n\tfromLineNumber: number;\n\t/**\n\t * At what line the deletion stopped (inclusive).\n\t */\n\ttoLineNumber: number;\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n */\nexport interface IModelContentChangedLinesInsertedEvent extends IModelContentChangedEvent {\n\t/**\n\t * Before what line did the insertion begin\n\t */\n\tfromLineNumber: number;\n\t/**\n\t * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted\n\t */\n\ttoLineNumber: number;\n\t/**\n\t * The text that was inserted\n\t */\n\tdetail: string;\n}\n/**\n * Decoration data associated with a model decorations changed event.\n */\nexport interface IModelDecorationsChangedEventDecorationData {\n\tid:string;\n\townerId:number;\n\trange:IRange;\n\tisForValidation:boolean;\n\toptions:IModelDecorationOptions;\n}\n/**\n * An event describing that model decorations have changed.\n */\nexport interface IModelDecorationsChangedEvent {\n\t/**\n\t * A summary with ids of decorations that have changed.\n\t */\n\tids:string[];\n\t/**\n\t * Lists of details\n\t */\n\taddedOrChangedDecorations:IModelDecorationsChangedEventDecorationData[];\n\tremovedDecorations:string[];\n\toldOptions:{[decorationId:string]:IModelDecorationOptions;};\n\toldRanges:{[decorationId:string]:IRange;};\n}\n/**\n * An event describing that a range of lines has been tokenized\n */\nexport interface IModelTokensChangedEvent {\n\t/**\n\t * The start of the range (inclusive)\n\t */\n\tfromLineNumber:number;\n\t/**\n\t * The end of the range (inclusive)\n\t */\n\ttoLineNumber:number;\n}\n/**\n * An event describing that the cursor position has changed.\n */\nexport interface ICursorPositionChangedEvent {\n\t/**\n\t * Primary cursor's position.\n\t */\n\tposition:IEditorPosition;\n\t/**\n\t * Primary cursor's view position\n\t */\n\tviewPosition:IEditorPosition;\n\t/**\n\t * Secondary cursors' position.\n\t */\n\tsecondaryPositions:IEditorPosition[];\n\t/**\n\t * Secondary cursors' view position.\n\t */\n\tsecondaryViewPositions:IEditorPosition[];\n\t/**\n\t * Reason.\n\t */\n\treason:string;\n\t/**\n\t * Source of the call that caused the event.\n\t */\n\tsource:string;\n\t/**\n\t * Is the primary cursor in the editable range?\n\t */\n\tisInEditableRange:boolean;\n}\n/**\n * An event describing that the cursor selection has changed.\n */\nexport interface ICursorSelectionChangedEvent {\n\t/**\n\t * The primary selection.\n\t */\n\tselection:IEditorSelection;\n\t/**\n\t * The primary selection in view coordinates.\n\t */\n\tviewSelection:IEditorSelection;\n\t/**\n\t * The secondary selections.\n\t */\n\tsecondarySelections:IEditorSelection[];\n\t/**\n\t * The secondary selections in view coordinates.\n\t */\n\tsecondaryViewSelections:IEditorSelection[];\n\t/**\n\t * Source of the call that caused the event.\n\t */\n\tsource:string;\n\t/**\n\t * Reason.\n\t */\n\treason:string;\n}\nexport enum VerticalRevealType {\n\tSimple = 0,\n\tCenter = 1,\n\tCenterIfOutsideViewport = 2\n}\n/**\n * An event describing a request to reveal a specific range in the view of the editor.\n */\nexport interface ICursorRevealRangeEvent {\n\t/**\n\t * Range to be reavealed.\n\t */\n\trange:IEditorRange;\n\t/**\n\t * View range to be reavealed.\n\t */\n\tviewRange:IEditorRange;\n\n\tverticalType: VerticalRevealType;\n\t/**\n\t * If true: there should be a horizontal & vertical revealing\n\t * If false: there should be just a vertical revealing\n\t */\n\trevealHorizontal:boolean;\n}\n\nexport interface ICursorScrollRequestEvent {\n\tdeltaLines: number;\n}\n\nexport interface IModelChangedEvent {\n\toldModelUrl: string;\n\tnewModelUrl: string;\n}\n\nexport interface IEditorWhitespace {\n\tid:number;\n\tafterLineNumber:number;\n\theightInLines:number;\n}\n\n/**\n * A description for the overview ruler position.\n */\nexport interface IOverviewRulerPosition {\n\t/**\n\t * Width of the overview ruler\n\t */\n\twidth:number;\n\t/**\n\t * Height of the overview ruler\n\t */\n\theight:number;\n\t/**\n\t * Top position for the overview ruler\n\t */\n\ttop:number;\n\t/**\n\t * Right position for the overview ruler\n\t */\n\tright:number;\n}\n\n/**\n * The internal layout details of the editor.\n */\nexport interface IEditorLayoutInfo {\n\t/**\n\t * Full editor width.\n\t */\n\twidth:number;\n\t/**\n\t * Full editor height.\n\t */\n\theight:number;\n\n\t/**\n\t * Left position for the glyph margin.\n\t */\n\tglyphMarginLeft:number;\n\t/**\n\t * The width of the glyph margin.\n\t */\n\tglyphMarginWidth:number;\n\t/**\n\t * The height of the glyph margin.\n\t */\n\tglyphMarginHeight:number;\n\n\t/**\n\t * Left position for the line numbers.\n\t */\n\tlineNumbersLeft:number;\n\t/**\n\t * The width of the line numbers.\n\t */\n\tlineNumbersWidth:number;\n\t/**\n\t * The height of the line numbers.\n\t */\n\tlineNumbersHeight:number;\n\n\t/**\n\t * Left position for the line decorations.\n\t */\n\tdecorationsLeft:number;\n\t/**\n\t * The width of the line decorations.\n\t */\n\tdecorationsWidth:number;\n\t/**\n\t * The height of the line decorations.\n\t */\n\tdecorationsHeight:number;\n\n\t/**\n\t * Left position for the content (actual text)\n\t */\n\tcontentLeft:number;\n\t/**\n\t * The width of the content (actual text)\n\t */\n\tcontentWidth:number;\n\t/**\n\t * The height of the content (actual height)\n\t */\n\tcontentHeight:number;\n\n\t/**\n\t * The width of the vertical scrollbar.\n\t */\n\tverticalScrollbarWidth:number;\n\t/**\n\t * The height of the horizontal scrollbar.\n\t */\n\thorizontalScrollbarHeight:number;\n\n\t/**\n\t * The position of the overview ruler.\n\t */\n\toverviewRuler:IOverviewRulerPosition;\n}\n\n/**\n * Options for creating the editor.\n */\nexport interface ICodeEditorWidgetCreationOptions extends IEditorOptions {\n\tmodel?:IModel;\n}\n\n/**\n * An editor model.\n */\nexport interface IEditorModel {\n}\n/**\n * An editor view state.\n */\nexport interface IEditorViewState {\n}\nexport interface IDimension {\n\twidth:number;\n\theight:number;\n}\n/**\n * Conditions describing action enablement\n */\nexport interface IActionEnablement {\n\t/**\n\t * The action is enabled only if text in the editor is focused (e.g. blinking cursor).\n\t * Warning: This condition will be disabled if the action is marked to be displayed in the context menu\n\t * Defaults to false.\n\t */\n\ttextFocus?: boolean;\n\t/**\n\t * The action is enabled only if the editor or its widgets have focus (e.g. focus is in find widget).\n\t * Defaults to false.\n\t */\n\twidgetFocus?: boolean;\n\t/**\n\t * The action is enabled only if the editor is not in read only mode.\n\t * Defaults to false.\n\t */\n\twriteableEditor?: boolean;\n\t/**\n\t * The action is enabled only if the cursor position is over tokens of a certain kind.\n\t * Defaults to no tokens required.\n\t */\n\ttokensAtPosition?: string[];\n\t/**\n\t * The action is enabled only if the cursor position is over a word (i.e. not whitespace).\n\t * Defaults to false.\n\t */\n\twordAtPosition?: boolean;\n}\n\n/**\n * A (serializable) state of the cursors.\n */\nexport interface ICursorState {\n\tinSelectionMode:boolean;\n\tselectionStart:IPosition;\n\tposition:IPosition;\n}\n/**\n * A (serializable) state of the view.\n */\nexport interface IViewState {\n\tscrollTop: number;\n\tscrollTopWithoutViewZones: number;\n\tscrollLeft: number;\n}\n/**\n * A (serializable) state of the code editor.\n */\nexport interface ICodeEditorViewState extends IEditorViewState {\n\tcursorState:ICursorState[];\n\tviewState:IViewState;\n\tcontributionsState: {[id:string]:any};\n}\n\n/**\n * Type of hit element with the mouse in the editor.\n */\nexport enum MouseTargetType {\n\t/**\n\t * Mouse is on top of an unknown element.\n\t */\n\tUNKNOWN,\n\t/**\n\t * Mouse is on top of the textarea used for input.\n\t */\n\tTEXTAREA,\n\t/**\n\t * Mouse is on top of the glyph margin\n\t */\n\tGUTTER_GLYPH_MARGIN,\n\t/**\n\t * Mouse is on top of the line numbers\n\t */\n\tGUTTER_LINE_NUMBERS,\n\t/**\n\t * Mouse is on top of the line decorations\n\t */\n\tGUTTER_LINE_DECORATIONS,\n\t/**\n\t * Mouse is on top of the whitespace left in the gutter by a view zone.\n\t */\n\tGUTTER_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of text in the content.\n\t */\n\tCONTENT_TEXT,\n\t/**\n\t * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n\t */\n\tCONTENT_EMPTY,\n\t/**\n\t * Mouse is on top of a view zone in the content.\n\t */\n\tCONTENT_VIEW_ZONE,\n\t/**\n\t * Mouse is on top of a content widget.\n\t */\n\tCONTENT_WIDGET,\n\t/**\n\t * Mouse is on top of the decorations overview ruler.\n\t */\n\tOVERVIEW_RULER,\n\t/**\n\t * Mouse is on top of a scrollbar.\n\t */\n\tSCROLLBAR,\n\t/**\n\t * Mouse is on top of an overlay widget.\n\t */\n\tOVERLAY_WIDGET\n}\n\n/**\n * A model for the diff editor.\n */\nexport interface IDiffEditorModel extends IEditorModel {\n\t/**\n\t * Original model.\n\t */\n\toriginal: IModel;\n\t/**\n\t * Modified model.\n\t */\n\tmodified: IModel;\n}\n/**\n * (Serializable) View state for the diff editor.\n */\nexport interface IDiffEditorViewState extends IEditorViewState {\n\toriginal: ICodeEditorViewState;\n\tmodified: ICodeEditorViewState;\n}\n/**\n * A change\n */\nexport interface IChange {\n\toriginalStartLineNumber:number;\n\toriginalEndLineNumber:number;\n\tmodifiedStartLineNumber:number;\n\tmodifiedEndLineNumber:number;\n}\n/**\n * A character level change.\n */\nexport interface ICharChange extends IChange {\n\toriginalStartColumn:number;\n\toriginalEndColumn:number;\n\tmodifiedStartColumn:number;\n\tmodifiedEndColumn:number;\n}\n/**\n * A line change\n */\nexport interface ILineChange extends IChange {\n\tcharChanges:ICharChange[];\n}\n/**\n * Information about a line in the diff editor\n */\nexport interface IDiffLineInformation {\n\tequivalentLineNumber: number;\n}\n\nexport const KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS = 'editorTextFocus';\nexport const KEYBINDING_CONTEXT_EDITOR_FOCUS = 'editorFocus';\nexport const KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS = 'editorTabMovesFocus';\nexport const KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS = 'editorHasMultipleSelections';\nexport const KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION = 'editorHasSelection';\nexport const KEYBINDING_CONTEXT_EDITOR_LANGUAGE_ID = 'editorLangId';\nexport const SHOW_ACCESSIBILITY_HELP_ACTION_ID = 'editor.action.showAccessibilityHelp';\n\nexport interface IDispatcherEvent {\n\tgetSource(): string;\n\tgetData(): any;\n}\n\nexport interface IHandler {\n\t(e:IDispatcherEvent): boolean;\n}\n\nexport interface IHandlerDispatcher {\n\tsetHandler(handlerId:string, handlerCallback:IHandler): void;\n\tclearHandlers(): void;\n\ttrigger(source:string, handlerId:string, payload:any): boolean;\n}\n\nexport interface IEditorStyling {\n\teditorClassName: string;\n\tfontFamily: string;\n\tfontSize: number;\n\tlineHeight: number;\n}\n\nexport interface IConfiguration {\n\tonDidChange: Event<IConfigurationChangedEvent>;\n\n\teditor:IInternalEditorOptions;\n\n\tsetLineCount(lineCount:number): void;\n\n\thandlerDispatcher: IHandlerDispatcher;\n}\n\n// --- view\n\nexport class ViewLineTokens {\n\t_viewLineTokensTrait: void;\n\n\tprivate _lineTokens:ViewLineToken[];\n\tprivate _fauxIndentLength:number;\n\tprivate _textLength:number;\n\n\tconstructor(lineTokens:ViewLineToken[], fauxIndentLength:number, textLength:number) {\n\t\tthis._lineTokens = lineTokens;\n\t\tthis._fauxIndentLength = fauxIndentLength|0;\n\t\tthis._textLength = textLength|0;\n\t}\n\n\tpublic getTokens(): ViewLineToken[] {\n\t\treturn this._lineTokens;\n\t}\n\n\tpublic getFauxIndentLength(): number {\n\t\treturn this._fauxIndentLength;\n\t}\n\n\tpublic getTextLength(): number {\n\t\treturn this._textLength;\n\t}\n\n\tpublic equals(other:ViewLineTokens): boolean {\n\t\treturn (\n\t\t\tthis._fauxIndentLength === other._fauxIndentLength\n\t\t\t&& this._textLength === other._textLength\n\t\t\t&& ViewLineToken.equalsArray(this._lineTokens, other._lineTokens)\n\t\t);\n\t}\n\n\tpublic findIndexOfOffset(offset:number): number {\n\t\treturn ViewLineToken.findIndexInSegmentsArray(this._lineTokens, offset);\n\t}\n}\n\nexport interface IDecorationsViewportData {\n\tdecorations: IModelDecoration[];\n\tinlineDecorations: IModelDecoration[][];\n}\n\nexport interface IViewEventBus {\n\temit(eventType:string, data?:any): void;\n}\n\nexport interface IWhitespaceManager {\n\t/**\n\t * Reserve rendering space.\n\t * @param height is specified in pixels.\n\t * @return an identifier that can be later used to remove or change the whitespace.\n\t */\n\taddWhitespace(afterLineNumber:number, ordinal:number, height:number): number;\n\n\t/**\n\t * Change the properties of a whitespace.\n\t * @param height is specified in pixels.\n\t */\n\tchangeWhitespace(id:number, newAfterLineNumber:number, newHeight:number): boolean;\n\n\t/**\n\t * Remove rendering space\n\t */\n\tremoveWhitespace(id:number): boolean;\n\n\t/**\n\t * Get the layout information for whitespaces currently in the viewport\n\t */\n\tgetWhitespaceViewportData(): IViewWhitespaceViewportData[];\n\n\tgetWhitespaces(): IEditorWhitespace[];\n}\n\nexport interface IViewModel extends IEventEmitter, IDisposable {\n\n\tgetTabSize(): number;\n\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber:number): string;\n\tgetLineMinColumn(lineNumber:number): number;\n\tgetLineMaxColumn(lineNumber:number): number;\n\tgetLineFirstNonWhitespaceColumn(lineNumber:number): number;\n\tgetLineLastNonWhitespaceColumn(lineNumber:number): number;\n\tgetLineTokens(lineNumber:number): ViewLineTokens;\n\tgetDecorationsViewportData(startLineNumber:number, endLineNumber:number): IDecorationsViewportData;\n\tgetLineRenderLineNumber(lineNumber:number): string;\n\tgetAllDecorations(): IModelDecoration[];\n\tgetEOL(): string;\n\tgetValueInRange(range:IRange, eol:EndOfLinePreference): string;\n\tdispose(): void;\n\n\tgetSelections(): IEditorSelection[];\n\n\tgetModelLineContent(modelLineNumber:number): string;\n\tgetModelLineMaxColumn(modelLineNumber:number): number;\n\tvalidateModelPosition(position:IPosition): IEditorPosition;\n\tconvertViewPositionToModelPosition(viewLineNumber:number, viewColumn:number): IEditorPosition;\n\tconvertViewRangeToModelRange(viewRange:IRange): IEditorRange;\n\tconvertModelPositionToViewPosition(modelLineNumber:number, modelColumn:number): IEditorPosition;\n\tconvertModelSelectionToViewSelection(modelSelection:IEditorSelection): IEditorSelection;\n\tmodelPositionIsVisible(position:IPosition): boolean;\n}\n\nexport interface IViewEventNames {\n\tModelFlushedEvent: string;\n\tLinesDeletedEvent: string;\n\tLinesInsertedEvent: string;\n\tLineChangedEvent: string;\n\tTokensChangedEvent: string;\n\tDecorationsChangedEvent: string;\n\tCursorPositionChangedEvent: string;\n\tCursorSelectionChangedEvent: string;\n\tRevealRangeEvent: string;\n\tLineMappingChangedEvent: string;\n}\n\nexport var ViewEventNames = {\n\tModelFlushedEvent: 'modelFlushedEvent',\n\tLinesDeletedEvent: 'linesDeletedEvent',\n\tLinesInsertedEvent: 'linesInsertedEvent',\n\tLineChangedEvent: 'lineChangedEvent',\n\tTokensChangedEvent: 'tokensChangedEvent',\n\tDecorationsChangedEvent: 'decorationsChangedEvent',\n\tCursorPositionChangedEvent: 'cursorPositionChangedEvent',\n\tCursorSelectionChangedEvent: 'cursorSelectionChangedEvent',\n\tRevealRangeEvent: 'revealRangeEvent',\n\tLineMappingChangedEvent: 'lineMappingChangedEvent',\n\tScrollRequestEvent: 'scrollRequestEvent'\n};\n\nexport interface IScrollEvent {\n\tvertical: boolean;\n\thorizontal: boolean;\n\tscrollTop:number;\n\tscrollLeft:number;\n}\n\nexport interface IViewLinesDeletedEvent {\n\t/**\n\t * At what line the deletion began (inclusive).\n\t */\n\tfromLineNumber: number;\n\t/**\n\t * At what line the deletion stopped (inclusive).\n\t */\n\ttoLineNumber: number;\n}\n\nexport interface IViewLinesInsertedEvent {\n\t/**\n\t * Before what line did the insertion begin\n\t */\n\tfromLineNumber: number;\n\t/**\n\t * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted\n\t */\n\ttoLineNumber: number;\n}\n\nexport interface IViewLineChangedEvent {\n\t/**\n\t * The line that has changed.\n\t */\n\tlineNumber: number;\n}\n\nexport interface IViewTokensChangedEvent {\n\t/**\n\t * Start line number of range\n\t */\n\tfromLineNumber: number;\n\t/**\n\t * End line number of range\n\t */\n\ttoLineNumber: number;\n}\n\nexport interface IViewDecorationsChangedEvent {\n\t/**\n\t * signals that at least one inline decoration has changed\n\t */\n\tinlineDecorationsChanged: boolean;\n}\n\nexport interface IViewCursorPositionChangedEvent {\n\t/**\n\t * Primary cursor's position.\n\t */\n\tposition: IEditorPosition;\n\t/**\n\t * Secondary cursors' position.\n\t */\n\tsecondaryPositions: IEditorPosition[];\n\t/**\n\t * Is the primary cursor in the editable range?\n\t */\n\tisInEditableRange: boolean;\n}\n\nexport interface IViewCursorSelectionChangedEvent {\n\t/**\n\t * The primary selection.\n\t */\n\tselection: IEditorSelection;\n\t/**\n\t * The secondary selections.\n\t */\n\tsecondarySelections: IEditorSelection[];\n}\n\nexport interface IViewRevealRangeEvent {\n\t/**\n\t * Range to be reavealed.\n\t */\n\trange: IEditorRange;\n\n\tverticalType: VerticalRevealType;\n\t/**\n\t * If true: there should be a horizontal & vertical revealing\n\t * If false: there should be just a vertical revealing\n\t */\n\trevealHorizontal: boolean;\n}\n\nexport interface IViewScrollRequestEvent {\n\tdeltaLines: number;\n}\n\nexport interface IViewWhitespaceViewportData {\n\tid:number;\n\tafterLineNumber:number;\n\tverticalOffset:number;\n\theight:number;\n}\n\nexport interface IPartialViewLinesViewportData {\n\tviewportTop: number;\n\tviewportHeight: number;\n\tbigNumbersDelta: number;\n\tvisibleRangesDeltaTop: number;\n\tstartLineNumber: number;\n\tendLineNumber: number;\n\trelativeVerticalOffset: number[];\n}\n\nexport class ViewLinesViewportData {\n\t_viewLinesViewportDataTrait: void;\n\n\tviewportTop: number;\n\tviewportHeight: number;\n\tbigNumbersDelta: number;\n\tvisibleRangesDeltaTop: number;\n\t/**\n\t * The line number at which to start rendering (inclusive).\n\t */\n\tstartLineNumber: number;\n\t/**\n\t * The line number at which to end rendering (inclusive).\n\t */\n\tendLineNumber: number;\n\t/**\n\t * relativeVerticalOffset[i] is the gap that must be left between line at\n\t * i - 1 + `startLineNumber` and i + `startLineNumber`.\n\t */\n\trelativeVerticalOffset: number[];\n\t/**\n\t * The viewport as a range (`startLineNumber`,1) -> (`endLineNumber`,maxColumn(`endLineNumber`)).\n\t */\n\tvisibleRange:IEditorRange;\n\n\tprivate _decorations: IModelDecoration[];\n\tprivate _inlineDecorations: IModelDecoration[][];\n\n\tconstructor(partialData:IPartialViewLinesViewportData, visibleRange:IEditorRange, decorationsData:IDecorationsViewportData) {\n\t\tthis.viewportTop = partialData.viewportTop|0;\n\t\tthis.viewportHeight = partialData.viewportHeight|0;\n\t\tthis.bigNumbersDelta = partialData.bigNumbersDelta|0;\n\t\tthis.visibleRangesDeltaTop = partialData.visibleRangesDeltaTop|0;\n\t\tthis.startLineNumber = partialData.startLineNumber|0;\n\t\tthis.endLineNumber = partialData.endLineNumber|0;\n\t\tthis.relativeVerticalOffset = partialData.relativeVerticalOffset;\n\t\tthis.visibleRange = visibleRange;\n\t\tthis._decorations = decorationsData.decorations;\n\t\tthis._inlineDecorations = decorationsData.inlineDecorations;\n\t}\n\n\tpublic getDecorationsInViewport(): IModelDecoration[] {\n\t\treturn this._decorations;\n\t}\n\n\tpublic getInlineDecorationsForLineInViewport(lineNumber:number): IModelDecoration[] {\n\t\tlineNumber = lineNumber|0;\n\t\treturn this._inlineDecorations[lineNumber - this.startLineNumber];\n\t}\n}\n\nexport class Viewport {\n\t_viewportTrait: void;\n\n\ttop: number;\n\tleft: number;\n\twidth: number;\n\theight: number;\n\n\tconstructor(top:number, left:number, width:number, height:number) {\n\t\tthis.top = top|0;\n\t\tthis.left = left|0;\n\t\tthis.width = width|0;\n\t\tthis.height = height|0;\n\t}\n}\n\n/**\n * Description of an action contribution\n */\nexport interface IActionDescriptor {\n\t/**\n\t * An unique identifier of the contributed action.\n\t */\n\tid: string;\n\t/**\n\t * A label of the action that will be presented to the user.\n\t */\n\tlabel: string;\n\t/**\n\t * An array of keybindings for the action.\n\t */\n\tkeybindings?: number[];\n\tkeybindingContext?: string;\n\t/**\n\t * A set of enablement conditions.\n\t */\n\tenablement?: IActionEnablement;\n\t/**\n\t * Control if the action should show up in the context menu and where.\n\t * Built-in groups:\n\t *   1_goto/* => e.g. 1_goto/1_peekDefinition\n\t *   2_change/* => e.g. 2_change/2_format\n\t *   3_edit/* => e.g. 3_edit/1_copy\n\t *   4_tools/* => e.g. 4_tools/1_commands\n\t * You can also create your own group.\n\t * Defaults to null (don't show in context menu).\n\t */\n\tcontextMenuGroupId?: string;\n\t/**\n\t * Method that will be executed when the action is triggered.\n\t * @param editor The editor instance is passed in as a convinience\n\t */\n\trun:(editor:ICommonCodeEditor)=>TPromise<void>;\n}\n\n/**\n * Data associated with an editor action contribution\n */\nexport interface IEditorActionDescriptorData {\n\tid:string;\n\tlabel:string;\n}\n\nexport type IEditorActionContributionCtor = IConstructorSignature2<IEditorActionDescriptorData, ICommonCodeEditor, IEditorContribution>;\n\nexport type ICommonEditorContributionCtor = IConstructorSignature1<ICommonCodeEditor, IEditorContribution>;\n\n/**\n * An editor contribution descriptor that will be used to construct editor contributions\n */\nexport interface ICommonEditorContributionDescriptor {\n\t/**\n\t * Create an instance of the contribution\n\t */\n\tcreateInstance(instantiationService:IInstantiationService, editor:ICommonCodeEditor): IEditorContribution;\n}\n\n/**\n * An editor.\n */\nexport interface IEditor extends IEventEmitter {\n\n\tgetId(): string;\n\n\t/**\n\t * Get the editor type. Current supported types:\n\t * \t\t\tEditorCommon.EditorType.ICodeEditor => ICodeEditor;\n\t * \t\t\tEditorCommon.EditorType.IDiffEditor => IDiffEditor;\n\t * This is to avoid an instanceof check\n\t */\n\tgetEditorType(): string;\n\n\t/**\n\t * Destroy the editor.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Update the editor's options after the editor has been created.\n\t */\n\tupdateOptions(newOptions: IEditorOptions): void;\n\n\t/**\n\t * Indicates that the editor becomes visible.\n\t */\n\tonVisible(): void;\n\n\t/**\n\t * Indicates that the editor becomes hidden.\n\t */\n\tonHide(): void;\n\n\t/**\n\t * Instructs the editor to remeasure its container. This method should\n\t * be called when the container of the editor gets resized.\n\t */\n\tlayout(dimension?:IDimension): void;\n\n\t/**\n\t * Brings browser focus to the editor\n\t */\n\tfocus(): void;\n\n\t/**\n\t * Returns true if this editor has keyboard focus.\n\t */\n\tisFocused(): boolean;\n\n\t/**\n\t * Add a new action to this editor.\n\t */\n\taddAction(descriptor:IActionDescriptor): void;\n\n\t/**\n\t * Returns all actions associated with this editor.\n\t */\n\tgetActions(): IAction[];\n\n\t/**\n\t * Saves current view state of the editor in a serializable object.\n\t */\n\tsaveViewState(): IEditorViewState;\n\n\t/**\n\t * Restores the view state of the editor from a serializable object generated by `saveViewState`.\n\t */\n\trestoreViewState(state: IEditorViewState): void;\n\n\t/**\n\t * Given a position, returns a column number that takes tab-widths into account.\n\t */\n\tgetVisibleColumnFromPosition(position:IPosition): number;\n\n\t/**\n\t * Returns the primary position of the cursor.\n\t */\n\tgetPosition(): IEditorPosition;\n\n\t/**\n\t * Set the primary position of the cursor. This will remove any secondary cursors.\n\t * @param position New primary cursor's position\n\t */\n\tsetPosition(position:IPosition): void;\n\n\t/**\n\t * Scroll vertically as necessary and reveal a line.\n\t */\n\trevealLine(lineNumber: number): void;\n\n\t/**\n\t * Scroll vertically as necessary and reveal a line centered vertically.\n\t */\n\trevealLineInCenter(lineNumber: number): void;\n\n\t/**\n\t * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.\n\t */\n\trevealLineInCenterIfOutsideViewport(lineNumber: number): void;\n\n\t/**\n\t * Scroll vertically or horizontally as necessary and reveal a position.\n\t */\n\trevealPosition(position: IPosition): void;\n\n\t/**\n\t * Scroll vertically or horizontally as necessary and reveal a position centered vertically.\n\t */\n\trevealPositionInCenter(position: IPosition): void;\n\n\t/**\n\t * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.\n\t */\n\trevealPositionInCenterIfOutsideViewport(position: IPosition): void;\n\n\t/**\n\t * Returns the primary selection of the editor.\n\t */\n\tgetSelection(): IEditorSelection;\n\n\t/**\n\t * Returns all the selections of the editor.\n\t */\n\tgetSelections(): IEditorSelection[];\n\n\t/**\n\t * Set the primary selection of the editor. This will remove any secondary cursors.\n\t * @param selection The new selection\n\t */\n\tsetSelection(selection:IRange): void;\n\tsetSelection(selection:IEditorRange): void;\n\tsetSelection(selection:ISelection): void;\n\tsetSelection(selection:IEditorSelection): void;\n\n\t/**\n\t * Set the selections for all the cursors of the editor.\n\t * Cursors will be removed or added, as necessary.\n\t */\n\tsetSelections(selections:ISelection[]): void;\n\n\t/**\n\t * Scroll vertically as necessary and reveal lines.\n\t */\n\trevealLines(startLineNumber: number, endLineNumber: number): void;\n\n\t/**\n\t * Scroll vertically as necessary and reveal lines centered vertically.\n\t */\n\trevealLinesInCenter(lineNumber: number, endLineNumber: number): void;\n\n\t/**\n\t * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.\n\t */\n\trevealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number): void;\n\n\t/**\n\t * Scroll vertically or horizontally as necessary and reveal a range.\n\t */\n\trevealRange(range: IRange): void;\n\n\t/**\n\t * Scroll vertically or horizontally as necessary and reveal a range centered vertically.\n\t */\n\trevealRangeInCenter(range: IRange): void;\n\n\t/**\n\t * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.\n\t */\n\trevealRangeInCenterIfOutsideViewport(range: IRange): void;\n\n\n\t/**\n\t * Directly trigger a handler or an editor action.\n\t * @param source The source of the call.\n\t * @param handlerId The id of the handler or the id of a contribution.\n\t * @param payload Extra data to be sent to the handler.\n\t */\n\ttrigger(source:string, handlerId:string, payload:any): void;\n\n\t/**\n\t * Gets the current model attached to this editor.\n\t */\n\tgetModel(): IEditorModel;\n\n\t/**\n\t * Sets the current model attached to this editor.\n\t * If the previous model was created by the editor via the value key in the options\n\t * literal object, it will be destroyed. Otherwise, if the previous model was set\n\t * via setModel, or the model key in the options literal object, the previous model\n\t * will not be destroyed.\n\t * It is safe to call setModel(null) to simply detach the current model from the editor.\n\t */\n\tsetModel(model:IEditorModel): void;\n\n\t/**\n\t * Change the decorations. All decorations added through this changeAccessor\n\t * will get the ownerId of the editor (meaning they will not show up in other\n\t * editors).\n\t * @see IModel.changeDecorations\n\t */\n\tchangeDecorations(callback: (changeAccessor:IModelDecorationsChangeAccessor)=>any): any;\n}\n\nexport interface ICodeEditorState {\n\tvalidate(editor:ICommonCodeEditor): boolean;\n}\n\nexport enum CodeEditorStateFlag {\n\tValue,\n\tSelection,\n\tPosition,\n\tScroll\n}\n\n/**\n * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.\n */\nexport interface IEditorContribution {\n\t/**\n\t * Get a unique identifier for this contribution.\n\t */\n\tgetId(): string;\n\t/**\n\t * Dispose this contribution.\n\t */\n\tdispose(): void;\n\t/**\n\t * Store view state.\n\t */\n\tsaveViewState?(): any;\n\t/**\n\t * Restore view state.\n\t */\n\trestoreViewState?(state: any): void;\n}\n\nexport type MarkedString = string | { language: string; value: string };\n\nexport interface IThemeDecorationRenderOptions {\n\tbackgroundColor?: string;\n\n\toutlineColor?: string;\n\toutlineStyle?: string;\n\toutlineWidth?: string;\n\n\tborderColor?: string;\n\tborderRadius?: string;\n\tborderSpacing?: string;\n\tborderStyle?: string;\n\tborderWidth?: string;\n\n\ttextDecoration?: string;\n\tcursor?: string;\n\tcolor?: string;\n\tletterSpacing?: string;\n\n\tgutterIconPath?: string;\n\n\toverviewRulerColor?: string;\n}\n\nexport interface IDecorationRenderOptions extends IThemeDecorationRenderOptions {\n\tisWholeLine?: boolean;\n\toverviewRulerLane?: OverviewRulerLane;\n\n\tlight?: IThemeDecorationRenderOptions;\n\tdark?: IThemeDecorationRenderOptions;\n}\n\nexport interface IRangeWithMessage {\n\trange: IRange;\n\thoverMessage?: IHTMLContentElement[];\n}\n\nexport interface ICommonCodeEditor extends IEditor {\n\n\t/**\n\t * Get a contribution of this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The contribution or null if contribution not found.\n\t */\n\tgetContribution(id: string): IEditorContribution;\n\n\tcaptureState(...flags:CodeEditorStateFlag[]): ICodeEditorState;\n\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): IModel;\n\n\t/**\n\t * Returns the current editor's configuration\n\t */\n\tgetConfiguration(): IInternalEditorOptions;\n\n\t/**\n\t * Returns the 'raw' editor's configuration, as it was applied over the defaults, but without any computed members.\n\t */\n\tgetRawConfiguration(): IEditorOptions;\n\n\t/**\n\t * Get value of the current model attached to this editor.\n\t * @see IModel.getValue\n\t */\n\tgetValue(options?: { preserveBOM: boolean; lineEnding: string; }): string;\n\n\t/**\n\t * Set the value of the current model attached to this editor.\n\t * @see IModel.setValue\n\t */\n\tsetValue(newValue: string): void;\n\n\t/**\n\t * Change the scrollTop of the editor's viewport.\n\t */\n\tsetScrollTop(newScrollTop: number): void;\n\t/**\n\t * Get the scrollTop of the editor's viewport.\n\t */\n\tgetScrollTop(): number;\n\n\t/**\n\t * Change the scrollLeft of the editor's viewport.\n\t */\n\tsetScrollLeft(newScrollLeft: number): void;\n\t/**\n\t * Get the scrollLeft of the editor's viewport.\n\t */\n\tgetScrollLeft(): number;\n\n\t/**\n\t * Get the scrollWidth of the editor's viewport.\n\t */\n\tgetScrollWidth(): number;\n\n\t/**\n\t * Get the scrollHeight of the editor's viewport.\n\t */\n\tgetScrollHeight(): number;\n\n\t/**\n\t * Get an action that is a contribution to this editor.\n\t * @id Unique identifier of the contribution.\n\t * @return The action or null if action not found.\n\t */\n\tgetAction(id: string): IAction;\n\n\t/**\n\t * Execute a command on the editor.\n\t * @param source The source of the call.\n\t * @param command The command to execute\n\t */\n\texecuteCommand(source: string, command: ICommand): boolean;\n\n\t/**\n\t * Execute a command on the editor.\n\t * @param source The source of the call.\n\t * @param command The command to execute\n\t */\n\texecuteEdits(source: string, edits: IIdentifiedSingleEditOperation[]): boolean;\n\n\t/**\n\t * Execute multiple (concommitent) commands on the editor.\n\t * @param source The source of the call.\n\t * @param command The commands to execute\n\t */\n\texecuteCommands(source: string, commands: ICommand[]): boolean;\n\n\t/**\n\t * Get all the decorations on a line (filtering out decorations from other editors).\n\t */\n\tgetLineDecorations(lineNumber: number): IModelDecoration[];\n\n\t/**\n\t * All decorations added through this call wii get the ownerId of this editor.\n\t * @see IModel.deltaDecorations\n\t */\n\tdeltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];\n\n\tsetDecorations(decorationTypeKey: string, ranges:IRangeWithMessage[]): void;\n\n\tremoveDecorations(decorationTypeKey:string): void;\n\n\t/**\n\t * Get the layout info for the editor.\n\t */\n\tgetLayoutInfo(): IEditorLayoutInfo;\n\n\t/**\n\t * Prevent the editor from sending a widgetFocusLost event,\n\t * set it in a state where it believes that focus is in one of its widgets.\n\t * Use this method with care and always add a matching `endForcedWidgetFocus`\n\t */\n\tbeginForcedWidgetFocus(): void;\n\n\t/**\n\t * End the preventing of sending a widgetFocusLost event.\n\t */\n\tendForcedWidgetFocus(): void;\n\n\t/**\n\t * This listener is notified when a keypress produces a visible character.\n\t * The callback should not do operations on the view, as the view might not be updated to reflect previous typed characters.\n\t * @param character Character to listen to.\n\t * @param callback Function to call when `character` is typed.\n\t */\n\taddTypingListener(character: string, callback: () => void): ListenerUnbind;\n\n}\n\nexport interface ICommonDiffEditor extends IEditor {\n\t/**\n\t * Type the getModel() of IEditor.\n\t */\n\tgetModel(): IDiffEditorModel;\n\n\tgetOriginalEditor(): ICommonCodeEditor;\n\tgetModifiedEditor(): ICommonCodeEditor;\n\n\tgetLineChanges(): ILineChange[];\n\n\t/**\n\t * Get information based on computed diff about a line number from the original model.\n\t * If the diff computation is not finished or the model is missing, will return null.\n\t */\n\tgetDiffLineInformationForOriginal(lineNumber:number): IDiffLineInformation;\n\t/**\n\t * Get information based on computed diff about a line number from the modified model.\n\t * If the diff computation is not finished or the model is missing, will return null.\n\t */\n\tgetDiffLineInformationForModified(lineNumber:number): IDiffLineInformation;\n\n\t/**\n\t * @see ICodeEditor.getValue\n\t */\n\tgetValue(options?:{ preserveBOM:boolean; lineEnding:string; }): string;\n\n\t/**\n\t * Returns whether the diff editor is ignoring trim whitespace or not.\n\t */\n\tignoreTrimWhitespace: boolean;\n\t/**\n\t * Returns whether the diff editor is rendering side by side or not.\n\t */\n\trenderSideBySide: boolean;\n}\n\nexport var EditorType = {\n\tICodeEditor: 'vs.editor.ICodeEditor',\n\tIDiffEditor: 'vs.editor.IDiffEditor'\n};\n\nexport var ClassName = {\n\tEditorWarningDecoration: 'greensquiggly',\n\tEditorErrorDecoration: 'redsquiggly'\n};\n\nexport var EventType = {\n\tDisposed: 'disposed',\n\n\tConfigurationChanged: 'configurationChanged',\n\n\tModelDispose: 'modelDispose',\n\n\tModelChanged: 'modelChanged',\n\n\tModelTokensChanged: 'modelTokensChanged',\n\tModelModeChanged: 'modelsModeChanged',\n\tModelModeSupportChanged: 'modelsModeSupportChanged',\n\tModelOptionsChanged: 'modelOptionsChanged',\n\tModelContentChanged: 'contentChanged',\n\tModelContentChanged2: 'contentChanged2',\n\tModelContentChangedFlush: 'flush',\n\tModelContentChangedLinesDeleted: 'linesDeleted',\n\tModelContentChangedLinesInserted: 'linesInserted',\n\tModelContentChangedLineChanged: 'lineChanged',\n\n\tEditorTextBlur: 'blur',\n\tEditorTextFocus: 'focus',\n\tEditorFocus: 'widgetFocus',\n\tEditorBlur: 'widgetBlur',\n\n\tModelDecorationsChanged: 'decorationsChanged',\n\n\tCursorPositionChanged: 'positionChanged',\n\tCursorSelectionChanged: 'selectionChanged',\n\tCursorRevealRange: 'revealRange',\n\tCursorScrollRequest: 'scrollRequest',\n\n\tViewFocusGained: 'focusGained',\n\tViewFocusLost: 'focusLost',\n\tViewFocusChanged: 'focusChanged',\n\tViewScrollWidthChanged: 'scrollWidthChanged',\n\tViewScrollHeightChanged: 'scrollHeightChanged',\n\tViewScrollChanged: 'scrollChanged',\n\tViewZonesChanged: 'zonesChanged',\n\n\tViewLayoutChanged: 'viewLayoutChanged',\n\n\tContextMenu: 'contextMenu',\n\tMouseDown: 'mousedown',\n\tMouseUp: 'mouseup',\n\tMouseMove: 'mousemove',\n\tMouseLeave: 'mouseleave',\n\tKeyDown: 'keydown',\n\tKeyUp: 'keyup',\n\n\tEditorLayout: 'editorLayout',\n\n\tDiffUpdated: 'diffUpdated'\n};\n\nexport var Handler = {\n\tExecuteCommand:\t\t\t\t'executeCommand',\n\tExecuteCommands:\t\t\t'executeCommands',\n\n\tCursorLeft:\t\t\t\t\t'cursorLeft',\n\tCursorLeftSelect:\t\t\t'cursorLeftSelect',\n\n\tCursorWordLeft:\t\t\t\t'cursorWordLeft',\n\tCursorWordStartLeft:\t\t'cursorWordStartLeft',\n\tCursorWordEndLeft:\t\t\t'cursorWordEndLeft',\n\n\tCursorWordLeftSelect:\t\t'cursorWordLeftSelect',\n\tCursorWordStartLeftSelect:\t'cursorWordStartLeftSelect',\n\tCursorWordEndLeftSelect:\t'cursorWordEndLeftSelect',\n\n\tCursorRight:\t\t\t\t'cursorRight',\n\tCursorRightSelect:\t\t\t'cursorRightSelect',\n\n\tCursorWordRight:\t\t\t'cursorWordRight',\n\tCursorWordStartRight:\t\t'cursorWordStartRight',\n\tCursorWordEndRight:\t\t\t'cursorWordEndRight',\n\n\tCursorWordRightSelect:\t\t'cursorWordRightSelect',\n\tCursorWordStartRightSelect:\t'cursorWordStartRightSelect',\n\tCursorWordEndRightSelect:\t'cursorWordEndRightSelect',\n\n\tCursorUp:\t\t\t\t\t'cursorUp',\n\tCursorUpSelect:\t\t\t\t'cursorUpSelect',\n\tCursorDown:\t\t\t\t\t'cursorDown',\n\tCursorDownSelect:\t\t\t'cursorDownSelect',\n\n\tCursorPageUp:\t\t\t\t'cursorPageUp',\n\tCursorPageUpSelect:\t\t\t'cursorPageUpSelect',\n\tCursorPageDown:\t\t\t\t'cursorPageDown',\n\tCursorPageDownSelect:\t\t'cursorPageDownSelect',\n\n\tCursorHome:\t\t\t\t\t'cursorHome',\n\tCursorHomeSelect:\t\t\t'cursorHomeSelect',\n\n\tCursorEnd:\t\t\t\t\t'cursorEnd',\n\tCursorEndSelect:\t\t\t'cursorEndSelect',\n\n\tExpandLineSelection:\t\t'expandLineSelection',\n\n\tCursorTop:\t\t\t\t\t'cursorTop',\n\tCursorTopSelect:\t\t\t'cursorTopSelect',\n\tCursorBottom:\t\t\t\t'cursorBottom',\n\tCursorBottomSelect:\t\t\t'cursorBottomSelect',\n\n\tCursorColumnSelectLeft:\t\t'cursorColumnSelectLeft',\n\tCursorColumnSelectRight:\t'cursorColumnSelectRight',\n\tCursorColumnSelectUp:\t\t'cursorColumnSelectUp',\n\tCursorColumnSelectPageUp:\t'cursorColumnSelectPageUp',\n\tCursorColumnSelectDown:\t\t'cursorColumnSelectDown',\n\tCursorColumnSelectPageDown:\t'cursorColumnSelectPageDown',\n\n\tAddCursorDown:\t\t\t\t'addCursorDown',\n\tAddCursorUp:\t\t\t\t'addCursorUp',\n\tCursorUndo:\t\t\t\t\t'cursorUndo',\n\tMoveTo:\t\t\t\t\t\t'moveTo',\n\tMoveToSelect:\t\t\t\t'moveToSelect',\n\tColumnSelect:\t\t\t\t'columnSelect',\n\tCreateCursor:\t\t\t\t'createCursor',\n\tLastCursorMoveToSelect:\t\t'lastCursorMoveToSelect',\n\n\tJumpToBracket:\t\t\t\t'jumpToBracket',\n\n\tType:\t\t\t\t\t\t'type',\n\tReplacePreviousChar:\t\t'replacePreviousChar',\n\tPaste:\t\t\t\t\t\t'paste',\n\n\tTab:\t\t\t\t\t\t'tab',\n\tIndent:\t\t\t\t\t\t'indent',\n\tOutdent:\t\t\t\t\t'outdent',\n\n\tDeleteLeft:\t\t\t\t\t'deleteLeft',\n\tDeleteRight:\t\t\t\t'deleteRight',\n\n\tDeleteWordLeft:\t\t\t\t'deleteWordLeft',\n\tDeleteWordStartLeft:\t\t'deleteWordStartLeft',\n\tDeleteWordEndLeft:\t\t\t'deleteWordEndLeft',\n\n\tDeleteWordRight:\t\t\t'deleteWordRight',\n\tDeleteWordStartRight:\t\t'deleteWordStartRight',\n\tDeleteWordEndRight:\t\t\t'deleteWordEndRight',\n\n\tDeleteAllLeft:\t\t\t\t'deleteAllLeft',\n\tDeleteAllRight:\t\t\t\t'deleteAllRight',\n\n\tRemoveSecondaryCursors: \t'removeSecondaryCursors',\n\tCancelSelection:\t\t\t'cancelSelection',\n\n\tCut:\t\t\t\t\t\t'cut',\n\n\tUndo:\t\t\t\t\t\t'undo',\n\tRedo:\t\t\t\t\t\t'redo',\n\n\tWordSelect:\t\t\t\t\t'wordSelect',\n\tWordSelectDrag:\t\t\t\t'wordSelectDrag',\n\tLastCursorWordSelect: \t\t'lastCursorWordSelect',\n\n\tLineSelect:\t\t\t\t\t'lineSelect',\n\tLineSelectDrag:\t\t\t\t'lineSelectDrag',\n\tLastCursorLineSelect:\t\t'lastCursorLineSelect',\n\tLastCursorLineSelectDrag:\t'lastCursorLineSelectDrag',\n\tLineInsertBefore:\t\t\t'lineInsertBefore',\n\tLineInsertAfter:\t\t\t'lineInsertAfter',\n\tLineBreakInsert:\t\t\t'lineBreakInsert',\n\n\tSelectAll:\t\t\t\t\t'selectAll',\n\n\tScrollLineUp:\t\t\t\t'scrollLineUp',\n\tScrollLineDown:\t\t\t\t'scrollLineDown',\n\n\tScrollPageUp:\t\t\t\t'scrollPageUp',\n\tScrollPageDown:\t\t\t\t'scrollPageDown'\n};\n\nexport class VisibleRange {\n\n\tpublic top:number;\n\tpublic left:number;\n\tpublic width:number;\n\n\tconstructor(top:number, left:number, width:number) {\n\t\tthis.top = top|0;\n\t\tthis.left = left|0;\n\t\tthis.width = width|0;\n\t}\n}\n\nexport enum TextEditorCursorStyle {\n\tLine = 1,\n\tBlock = 2,\n\tUnderline = 3\n}\n\nexport function cursorStyleFromString(cursorStyle:string): TextEditorCursorStyle {\n\tif (cursorStyle === 'line') {\n\t\treturn TextEditorCursorStyle.Line;\n\t} else if (cursorStyle === 'block') {\n\t\treturn TextEditorCursorStyle.Block;\n\t} else if (cursorStyle === 'underline') {\n\t\treturn TextEditorCursorStyle.Underline;\n\t}\n\treturn TextEditorCursorStyle.Line;\n}\n\nexport function cursorStyleToString(cursorStyle:TextEditorCursorStyle): string {\n\tif (cursorStyle === TextEditorCursorStyle.Line) {\n\t\treturn 'line';\n\t} else if (cursorStyle === TextEditorCursorStyle.Block) {\n\t\treturn 'block';\n\t} else if (cursorStyle === TextEditorCursorStyle.Underline) {\n\t\treturn 'underline';\n\t} else {\n\t\tthrow new Error('cursorStyleToString: Unknown cursorStyle');\n\t}\n}\n\nexport class HorizontalRange {\n\n\tpublic left: number;\n\tpublic width: number;\n\n\tconstructor(left:number, width:number) {\n\t\tthis.left = left|0;\n\t\tthis.width = width|0;\n\t}\n}\n\nexport class LineVisibleRanges {\n\n\tpublic lineNumber: number;\n\tpublic ranges: HorizontalRange[];\n\n\tconstructor(lineNumber:number, ranges:HorizontalRange[]) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.ranges = ranges;\n\t}\n}\n"]}