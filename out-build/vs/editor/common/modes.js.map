{"version":3,"file":"vs/editor/common/modes.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/editor/common/modes.ts"],"names":[],"mappings":";IAAA;;;oGAGgG;IAChG,YAAY,CAAC;IA2pBb,WAAY,YAAY;QACvB,+CAAI,CAAA;QACJ,mDAAM,CAAA;QACN,iEAAa,CAAA;QACb,qDAAO,CAAA;IACR,CAAC,EALW,oBAAY,KAAZ,oBAAY,QAKvB;IALD,IAAY,YAAY,GAAZ,oBAKX,CAAA;IAoFD,gCAAgC;IAEnB,+BAAuB,GAAG,IAAI,iCAAuB,CAAoB,kBAAkB,CAAC,CAAC;IAE7F,sBAAc,GAAG,IAAI,iCAAuB,CAAiB,eAAe,CAAC,CAAC;IAE9E,uBAAe,GAAG,IAAI,iCAAuB,CAAkB,gBAAgB,CAAC,CAAC;IAEjF,8BAAsB,GAAG,IAAI,iCAAuB,CAAyB,uBAAuB,CAAC,CAAC;IAEtG,yBAAiB,GAAG,IAAI,iCAAuB,CAAoB,kBAAkB,CAAC,CAAC;IAEvF,uBAAe,GAAG,IAAI,iCAAuB,CAAkB,gBAAgB,CAAC,CAAC;IAEjF,2BAAmB,GAAG,IAAI,iCAAuB,CAAsB,oBAAoB,CAAC,CAAC;IAE7F,2BAAmB,GAAG,IAAI,iCAAuB,CAAsB,oBAAoB,CAAC,CAAC;IAE7F,wBAAgB,GAAG,IAAI,iCAAuB,CAAmB,iBAAiB,CAAC,CAAC;IAEpF,wBAAgB,GAAG,IAAI,iCAAuB,CAAmB,iBAAiB,CAAC,CAAC;IAEpF,sBAAc,GAAG,IAAI,iCAAuB,CAAqB,mBAAmB,CAAC,CAAC;IAEtF,4BAAoB,GAAG,IAAI,iCAAuB,CAAqB,mBAAmB,CAAC,CAAC","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IHTMLContentElement} from 'vs/base/common/htmlContent';\nimport {IDisposable} from 'vs/base/common/lifecycle';\nimport URI from 'vs/base/common/uri';\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport {IFilter} from 'vs/base/common/filters';\nimport {IMarker} from 'vs/platform/markers/common/markers';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport {ModeTransition} from 'vs/editor/common/core/modeTransition';\nimport LanguageFeatureRegistry from 'vs/editor/common/modes/languageFeatureRegistry';\n\nexport interface ITokenizationResult {\n\ttype?:string;\n\tdontMergeWithPrev?:boolean;\n\tnextState?:IState;\n}\n\nexport interface IState {\n\tclone():IState;\n\tequals(other:IState):boolean;\n\tgetMode():IMode;\n\ttokenize(stream:IStream):ITokenizationResult;\n\tgetStateData(): IState;\n\tsetStateData(state:IState):void;\n}\n\n/**\n * An IStream is a character & token stream abstraction over a line of text. It\n *  is never multi-line. The stream can be navigated character by character, or\n *  token by token, given some token rules.\n */\nexport interface IStream {\n\n\t/**\n\t * Returns the current character position of the stream on the line.\n\t */\n\tpos():number;\n\n\t/**\n\t * Returns true iff the stream is at the end of the line.\n\t */\n\teos():boolean;\n\n\t/**\n\t * Returns the next character in the stream.\n\t */\n\tpeek():string;\n\n\t/**\n\t * Returns the next character in the stream, and advances it by one character.\n\t */\n\tnext(): string;\n\tnext2(): void;\n\n\t/**\n\t * Advances the stream by `n` characters.\n\t */\n\tadvance(n:number):string;\n\n\t/**\n\t * Advances the stream until the end of the line.\n\t */\n\tadvanceToEOS():string;\n\n\t/**\n\t * Brings the stream back `n` characters.\n\t */\n\tgoBack(n:number):void;\n\n\t/**\n\t *  Advances the stream if the next characters validate a condition. A condition can be\n\t *\n\t *      - a regular expression (always starting with ^)\n\t * \t\t\tEXAMPLES: /^\\d+/, /^function|var|interface|class/\n\t *\n\t *  \t- a string\n\t * \t\t\tEXAMPLES: \"1954\", \"albert\"\n\t */\n\tadvanceIfCharCode(charCode: number): string;\n\tadvanceIfCharCode2(charCode:number): number;\n\n\tadvanceIfString(condition: string): string;\n\tadvanceIfString2(condition: string): number;\n\n\tadvanceIfStringCaseInsensitive(condition: string): string;\n\tadvanceIfStringCaseInsensitive2(condition: string): number;\n\n\tadvanceIfRegExp(condition: RegExp): string;\n\tadvanceIfRegExp2(condition:RegExp): number;\n\n\n\t/**\n\t * Advances the stream while the next characters validate a condition. Check #advanceIf for\n\t * details on the possible types for condition.\n\t */\n\tadvanceWhile(condition:string):string;\n\tadvanceWhile(condition:RegExp):string;\n\n\t/**\n\t * Advances the stream until the some characters validate a condition. Check #advanceIf for\n\t * details on the possible types for condition. The `including` boolean value indicates\n\t * whether the stream will advance the characters that matched the condition as well, or not.\n\t */\n\tadvanceUntil(condition: string, including: boolean): string;\n\tadvanceUntil(condition: RegExp, including: boolean): string;\n\n\tadvanceUntilString(condition: string, including: boolean): string;\n\tadvanceUntilString2(condition: string, including: boolean): number;\n\n\t/**\n\t * The token rules define how consecutive characters should be put together as a token,\n\t * or separated into two different tokens. They are given through a separator characters\n\t * string and a whitespace characters string. A separator is always one token. Consecutive\n\t * whitespace is always one token. Everything in between these two token types, is also a token.\n\t *\n\t * \tEXAMPLE: stream.setTokenRules(\"+-\", \" \");\n\t * \tSetting these token rules defines the tokens for the string \"123+456 -    7\" as being\n\t * \t\t[\"123\", \"+\", \"456\", \" \", \"-\", \"    \", \"7\"]\n\t */\n\tsetTokenRules(separators:string, whitespace:string):void;\n\n\t/**\n\t * Returns the next token, given that the stream was configured with token rules.\n\t */\n\tpeekToken():string;\n\n\t/**\n\t * Returns the next token, given that the stream was configured with token rules, and advances the\n\t * stream by the exact length of the found token.\n\t */\n\tnextToken():string;\n\n\t/**\n\t * Returns the next whitespace, if found. Returns an empty string otherwise.\n\t */\n\tpeekWhitespace():string;\n\n\t/**\n\t * Returns the next whitespace, if found, and advances the stream by the exact length of the found\n\t * whitespace. Returns an empty string otherwise.\n\t */\n\tskipWhitespace(): string;\n\tskipWhitespace2(): number;\n}\n\nexport interface IModeDescriptor {\n\tid:string;\n}\n\nexport interface ILineContext {\n\tgetLineContent(): string;\n\n\tmodeTransitions: ModeTransition[];\n\n\tgetTokenCount(): number;\n\tgetTokenStartIndex(tokenIndex:number): number;\n\tgetTokenType(tokenIndex:number): string;\n\tgetTokenText(tokenIndex:number): string;\n\tgetTokenEndIndex(tokenIndex:number): number;\n\tfindIndexOfOffset(offset:number): number;\n}\n\nexport interface IMode {\n\n\tgetId(): string;\n\n\t/**\n\t * Return a mode \"similar\" to this one that strips any \"smart\" supports.\n\t */\n\ttoSimplifiedMode(): IMode;\n\n\taddSupportChangedListener?(callback: (e: editorCommon.IModeSupportChangedEvent) => void): IDisposable;\n\n\t/**\n\t * Register a support by name. Only optional.\n\t */\n\tregisterSupport?<T>(support:string, callback:(mode:IMode)=>T): IDisposable;\n\n\t/**\n\t * Optional adapter to support tokenization.\n\t */\n\ttokenizationSupport?: ITokenizationSupport;\n\n\t/**\n\t * Optional adapter to support showing occurrences of words or such.\n\t */\n\toccurrencesSupport?:IOccurrencesSupport;\n\n\t/**\n\t * Optional adapter to support revealing the declaration of a symbol.\n\t */\n\tdeclarationSupport?: IDeclarationSupport;\n\n\t/**\n\t * Optional adapter to support revealing the type declaration of a symbol.\n\t */\n\ttypeDeclarationSupport?: ITypeDeclarationSupport;\n\n\t/**\n\t * Optional adapter to support finding references to a symbol.\n\t */\n\treferenceSupport?:IReferenceSupport;\n\n\t/**\n\t * Optional adapter to support intellisense.\n\t */\n\tsuggestSupport?:ISuggestSupport;\n\n\t/**\n\t * Optional adapter to support intellisense.\n\t */\n\tparameterHintsSupport?:IParameterHintsSupport;\n\n\t/**\n\t * Optional adapter to support showing extra info in tokens.\n\t */\n\textraInfoSupport?:IExtraInfoSupport;\n\n\t/**\n\t * Optional adapter to support showing an outline.\n\t */\n\toutlineSupport?:IOutlineSupport;\n\n\t/**\n\t * Optional adapter to support logical selection.\n\t */\n\tlogicalSelectionSupport?:ILogicalSelectionSupport;\n\n\t/**\n\t * Optional adapter to support formatting.\n\t */\n\tformattingSupport?:IFormattingSupport;\n\n\t/**\n\t * Optional adapter to support inplace-replace.\n\t */\n\tinplaceReplaceSupport?:IInplaceReplaceSupport;\n\n\t/**\n\t * Optional adapter to support output for a model (e.g. markdown -> html)\n\t */\n\temitOutputSupport?:IEmitOutputSupport;\n\n\t/**\n\t * Optional adapter to support detecting links.\n\t */\n\tlinkSupport?:ILinkSupport;\n\n\t/**\n\t * Optional adapter to support configuring this mode.\n\t */\n\tconfigSupport?:IConfigurationSupport;\n\n\t/**\n\t * Optional adapter to support quick fix of typing errors.\n\t */\n\tquickFixSupport?:IQuickFixSupport;\n\n\t/**\n\t * Optional adapter to show code lens\n\t */\n\tcodeLensSupport?:ICodeLensSupport;\n\n\t/**\n\t * Optional adapter to support renaming\n\t */\n\trenameSupport?: IRenameSupport;\n\n\t/**\n\t * Optional adapter to support task running\n\t */\n\ttaskSupport?: ITaskSupport;\n\n\t/**\n\t * Optional adapter to support rich editing.\n\t */\n\trichEditSupport?: IRichEditSupport;\n}\n\n/**\n * Interface used for tokenization\n */\nexport interface IToken {\n\tstartIndex:number;\n\ttype:string;\n}\n\nexport interface IModeTransition {\n\tstartIndex: number;\n\tmode: IMode;\n}\n\nexport interface ILineTokens {\n\ttokens: IToken[];\n\tactualStopOffset: number;\n\tendState: IState;\n\tmodeTransitions: IModeTransition[];\n\tretokenize?:TPromise<void>;\n}\n\nexport interface ITokenizationSupport {\n\n\tshouldGenerateEmbeddedModels: boolean;\n\n\tgetInitialState():IState;\n\n\t// add offsetDelta to each of the returned indices\n\t// stop tokenizing at absolute value stopAtOffset (i.e. stream.pos() + offsetDelta > stopAtOffset)\n\ttokenize(line:string, state:IState, offsetDelta?:number, stopAtOffset?:number):ILineTokens;\n}\n\n/**\n * Interface used to get extra info for a symbol\n */\nexport interface IComputeExtraInfoResult {\n\trange: editorCommon.IRange;\n\tvalue?: string;\n\thtmlContent?: IHTMLContentElement[];\n\tclassName?: string;\n}\nexport interface IExtraInfoSupport {\n\tcomputeInfo(resource:URI, position:editorCommon.IPosition):TPromise<IComputeExtraInfoResult>;\n}\n\nexport type SuggestionType = 'method'\n\t| 'function'\n\t| 'constructor'\n\t| 'field'\n\t| 'variable'\n\t| 'class'\n\t| 'interface'\n\t| 'module'\n\t| 'property'\n\t| 'unit'\n\t| 'value'\n\t| 'enum'\n\t| 'keyword'\n\t| 'snippet'\n\t| 'text'\n\t| 'color'\n\t| 'file'\n\t| 'reference'\n\t| 'customcolor';\n\nexport interface ISuggestion {\n\tlabel: string;\n\tcodeSnippet: string;\n\ttype: SuggestionType;\n\ttypeLabel?: string;\n\tdocumentationLabel?: string;\n\tfilterText?: string;\n\tsortText?: string;\n\tnoAutoAccept?: boolean;\n\toverwriteBefore?: number;\n\toverwriteAfter?: number;\n}\n\nexport interface ISuggestResult {\n\tcurrentWord: string;\n\tsuggestions:ISuggestion[];\n\tincomplete?: boolean;\n}\n\n/**\n * Interface used to get completion suggestions at a specific location.\n */\nexport interface ISuggestSupport {\n\n\t/**\n\t * Compute all completions for the given resource at the given position.\n\t */\n\tsuggest(resource: URI, position: editorCommon.IPosition, triggerCharacter?: string): TPromise<ISuggestResult[]>;\n\n\t/**\n\t * Compute more details for the given suggestion.\n\t */\n\tgetSuggestionDetails?: (resource: URI, position: editorCommon.IPosition, suggestion: ISuggestion) => TPromise<ISuggestion>;\n\n\tfilter?: IFilter;\n\tgetTriggerCharacters(): string[];\n\tshouldShowEmptySuggestionList(): boolean;\n\tshouldAutotriggerSuggest(context: ILineContext, offset: number, triggeredByCharacter: string): boolean;\n}\n\n/**\n * Interface used to quick fix typing errors while accesing member fields.\n */\nexport interface IQuickFix {\n\tcommand: ICommand;\n\tscore: number;\n}\n\nexport interface IQuickFixResult {\n\tedits?: IResourceEdit[];\n\tmessage?: string;\n}\n\nexport interface IQuickFixSupport {\n\tgetQuickFixes(resource: URI, range: IMarker | editorCommon.IRange): TPromise<IQuickFix[]>;\n\t//TODO@joh this should be removed in the furture such that we can trust the command and it's args\n\trunQuickFixAction(resource: URI, range: editorCommon.IRange, quickFix: IQuickFix):TPromise<IQuickFixResult>;\n}\n\nexport interface IParameter {\n\tlabel:string;\n\tdocumentation?:string;\n\tsignatureLabelOffset?:number;\n\tsignatureLabelEnd?:number;\n}\n\nexport interface ISignature {\n\tlabel:string;\n\tdocumentation?:string;\n\tparameters:IParameter[];\n}\n\nexport interface IParameterHints {\n\tcurrentSignature:number;\n\tcurrentParameter:number;\n\tsignatures:ISignature[];\n}\n\n/**\n * Interface used to get parameter hints.\n */\nexport interface IParameterHintsSupport {\n\tgetParameterHintsTriggerCharacters(): string[];\n\tshouldTriggerParameterHints(context: ILineContext, offset: number): boolean;\n\tgetParameterHints(resource: URI, position: editorCommon.IPosition, triggerCharacter?: string): TPromise<IParameterHints>;\n}\n\n\nexport interface IOccurence {\n\tkind?: 'write' | 'text' | string;\n\trange: editorCommon.IRange;\n}\n\n/**\n * Interface used to find occurrences of a symbol\n */\nexport interface IOccurrencesSupport {\n\tfindOccurrences(resource:URI, position:editorCommon.IPosition, strict?:boolean):TPromise<IOccurence[]>;\n}\n\n\n/**\n * Interface used to find declarations on a symbol\n */\nexport interface IReference {\n\tresource: URI;\n\trange: editorCommon.IRange;\n}\n\n/**\n * Interface used to find references to a symbol\n */\nexport interface IReferenceSupport {\n\n\t/**\n\t * @returns true if on the given line (and its tokens) at the given\n\t * \toffset reference search can be invoked.\n\t */\n\tcanFindReferences(context:ILineContext, offset:number):boolean;\n\n\t/**\n\t * @returns a list of reference of the symbol at the position in the\n\t * \tgiven resource.\n\t */\n\tfindReferences(resource:URI, position:editorCommon.IPosition, includeDeclaration:boolean):TPromise<IReference[]>;\n}\n\n/**\n * Interface used to find declarations on a symbol\n */\nexport interface IDeclarationSupport {\n\tcanFindDeclaration(context:ILineContext, offset:number):boolean;\n\tfindDeclaration(resource:URI, position:editorCommon.IPosition):TPromise<IReference|IReference[]>;\n}\n\nexport interface ITypeDeclarationSupport {\n\tcanFindTypeDeclaration(context:ILineContext, offset:number):boolean;\n\tfindTypeDeclaration(resource:URI, position:editorCommon.IPosition):TPromise<IReference>;\n}\n\n/**\n * Interface used to compute an outline\n */\nexport interface IOutlineEntry {\n\tlabel: string;\n\tcontainerLabel?: string;\n\ttype: string;\n\ticon?: string; // icon class or null to use the default images based on the type\n\trange: editorCommon.IRange;\n\tchildren?: IOutlineEntry[];\n}\n\nexport interface IOutlineSupport {\n\tgetOutline(resource:URI):TPromise<IOutlineEntry[]>;\n\toutlineGroupLabel?: { [name: string]: string; };\n}\n\n/**\n * Interface used to compute a hierachry of logical ranges.\n */\nexport interface ILogicalSelectionEntry {\n\ttype:string;\n\trange:editorCommon.IRange;\n}\nexport interface ILogicalSelectionSupport {\n\tgetRangesToPosition(resource:URI, position:editorCommon.IPosition):TPromise<ILogicalSelectionEntry[]>;\n}\n\n/**\n * Interface used to format a model\n */\nexport interface IFormattingOptions {\n\ttabSize:number;\n\tinsertSpaces:boolean;\n}\n\n/**\n * Supports to format source code. There are three levels\n * on which formatting can be offered:\n * (1) format a document\n * (2) format a selectin\n * (3) format on keystroke\n */\nexport interface IFormattingSupport {\n\n\tformatDocument?: (resource: URI, options: IFormattingOptions) => TPromise<editorCommon.ISingleEditOperation[]>;\n\n\tformatRange?: (resource: URI, range: editorCommon.IRange, options: IFormattingOptions) => TPromise<editorCommon.ISingleEditOperation[]>;\n\n\tautoFormatTriggerCharacters?: string[];\n\n\tformatAfterKeystroke?: (resource: URI, position: editorCommon.IPosition, ch: string, options: IFormattingOptions) => TPromise<editorCommon.ISingleEditOperation[]>;\n}\n\nexport interface IInplaceReplaceSupportResult {\n\tvalue: string;\n\trange:editorCommon.IRange;\n}\n\n/**\n * Interface used to navigate with a value-set.\n */\nexport interface IInplaceReplaceSupport {\n\tnavigateValueSet(resource:URI, range:editorCommon.IRange, up:boolean):TPromise<IInplaceReplaceSupportResult>;\n}\n\n/**\n * Interface used to get output for a language that supports transformation (e.g. markdown -> html)\n */\nexport interface IEmitOutputSupport {\n\tgetEmitOutput(resource:URI):TPromise<IEmitOutput>;\n}\n\nexport interface IEmitOutput {\n\tfilename?:string;\n\tcontent:string;\n}\n\n/**\n * Interface used to detect links.\n */\nexport interface ILink {\n\n\trange: editorCommon.IRange;\n\n\t/**\n\t * The url of the link.\n\t * The url should be absolute and will not get any special treatment.\n\t */\n\turl: string;\n\n\textraInlineClassName?: string;\n}\n\nexport interface ILinkSupport {\n\tcomputeLinks(resource:URI):TPromise<ILink[]>;\n}\n\n/**\n * Interface used to define a configurable editor mode.\n */\nexport interface IConfigurationSupport {\n\tconfigure(options:any):TPromise<void>;\n}\n\nexport interface IResourceEdit {\n\tresource: URI;\n\trange?: editorCommon.IRange;\n\tnewText: string;\n}\n\nexport interface IRenameResult {\n\tcurrentName: string;\n\tedits: IResourceEdit[];\n\trejectReason?: string;\n}\n\n/**\n * Interface used to support renaming of symbols\n */\nexport interface IRenameSupport {\n\n\tfilter?: string[];\n\n\trename(resource: URI, position: editorCommon.IPosition, newName: string): TPromise<IRenameResult>;\n}\n\nexport interface ICommand {\n\tid: string;\n\ttitle: string;\n\targuments?: any[];\n}\n\nexport interface ICodeLensSymbol {\n\trange: editorCommon.IRange;\n\tid?: string;\n\tcommand?: ICommand;\n}\n\n/**\n * Interface used for the code lense support\n */\nexport interface ICodeLensSupport {\n\tfindCodeLensSymbols(resource: URI): TPromise<ICodeLensSymbol[]>;\n\tresolveCodeLensSymbol(resource: URI, symbol: ICodeLensSymbol): TPromise<ICodeLensSymbol>;\n}\n\nexport interface ITaskSummary {\n}\n\n/**\n * Interface to support building via a langauge service\n */\nexport interface ITaskSupport {\n\tbuild?():TPromise<ITaskSummary>;\n\trebuild?():TPromise<ITaskSummary>;\n\tclean?():TPromise<void>;\n}\n\nexport type CharacterPair = [string, string];\n\nexport interface IAutoClosingPairConditional extends IAutoClosingPair {\n\tnotIn?: string[];\n}\n\n/**\n * Interface used to support electric characters\n */\nexport interface IElectricAction {\n\t// Only one of the following properties should be defined:\n\n\t// The line will be indented at the same level of the line\n\t// which contains the matching given bracket type.\n\tmatchOpenBracket?:string;\n\n\t// The text will be appended after the electric character.\n\tappendText?:string;\n\n\t// The number of characters to advance the cursor, useful with appendText\n\tadvanceCount?:number;\n}\n\nexport enum IndentAction {\n\tNone,\n\tIndent,\n\tIndentOutdent,\n\tOutdent\n}\n\n/**\n * An action the editor executes when 'enter' is being pressed\n */\nexport interface IEnterAction {\n\tindentAction:IndentAction;\n\tappendText?:string;\n\tremoveText?:number;\n}\n\nexport interface IRichEditElectricCharacter {\n\tgetElectricCharacters():string[];\n\t// Should return opening bracket type to match indentation with\n\tonElectricCharacter(context:ILineContext, offset:number):IElectricAction;\n}\n\nexport interface IRichEditOnEnter {\n\tonEnter(model:editorCommon.ITokenizedModel, position: editorCommon.IPosition): IEnterAction;\n}\n\n/**\n * Interface used to support insertion of mode specific comments.\n */\nexport interface ICommentsConfiguration {\n\tlineCommentToken?:string;\n\tblockCommentStartToken?:string;\n\tblockCommentEndToken?:string;\n}\n\n/**\n * Interface used to support insertion of matching characters like brackets and qoutes.\n */\nexport interface IAutoClosingPair {\n\topen:string;\n\tclose:string;\n}\nexport interface IRichEditCharacterPair {\n\tgetAutoClosingPairs():IAutoClosingPairConditional[];\n\tshouldAutoClosePair(character:string, context:ILineContext, offset:number):boolean;\n\tgetSurroundingPairs():IAutoClosingPair[];\n}\n\nexport interface IRichEditBrackets {\n\tmaxBracketLength: number;\n\tforwardRegex: RegExp;\n\treversedRegex: RegExp;\n\tbrackets: editorCommon.IRichEditBracket[];\n\ttextIsBracket: {[text:string]:editorCommon.IRichEditBracket;};\n\ttextIsOpenBracket: {[text:string]:boolean;};\n}\n\nexport interface IRichEditSupport {\n\t/**\n\t * Optional adapter for electric characters.\n\t */\n\telectricCharacter?:IRichEditElectricCharacter;\n\n\t/**\n\t * Optional adapter for comment insertion.\n\t */\n\tcomments?:ICommentsConfiguration;\n\n\t/**\n\t * Optional adapter for insertion of character pair.\n\t */\n\tcharacterPair?:IRichEditCharacterPair;\n\n\t/**\n\t * Optional adapter for classification of tokens.\n\t */\n\twordDefinition?: RegExp;\n\n\t/**\n\t * Optional adapter for custom Enter handling.\n\t */\n\tonEnter?: IRichEditOnEnter;\n\n\t/**\n\t * Optional adapter for brackets.\n\t */\n\tbrackets?: IRichEditBrackets;\n}\n\n// --- feature registries ------\n\nexport const ReferenceSearchRegistry = new LanguageFeatureRegistry<IReferenceSupport>('referenceSupport');\n\nexport const RenameRegistry = new LanguageFeatureRegistry<IRenameSupport>('renameSupport');\n\nexport const SuggestRegistry = new LanguageFeatureRegistry<ISuggestSupport>('suggestSupport');\n\nexport const ParameterHintsRegistry = new LanguageFeatureRegistry<IParameterHintsSupport>('parameterHintsSupport');\n\nexport const ExtraInfoRegistry = new LanguageFeatureRegistry<IExtraInfoSupport>('extraInfoSupport');\n\nexport const OutlineRegistry = new LanguageFeatureRegistry<IOutlineSupport>('outlineSupport');\n\nexport const OccurrencesRegistry = new LanguageFeatureRegistry<IOccurrencesSupport>('occurrencesSupport');\n\nexport const DeclarationRegistry = new LanguageFeatureRegistry<IDeclarationSupport>('declarationSupport');\n\nexport const CodeLensRegistry = new LanguageFeatureRegistry<ICodeLensSupport>('codeLensSupport');\n\nexport const QuickFixRegistry = new LanguageFeatureRegistry<IQuickFixSupport>('quickFixSupport');\n\nexport const FormatRegistry = new LanguageFeatureRegistry<IFormattingSupport>('formattingSupport');\n\nexport const FormatOnTypeRegistry = new LanguageFeatureRegistry<IFormattingSupport>('formattingSupport');\n"]}