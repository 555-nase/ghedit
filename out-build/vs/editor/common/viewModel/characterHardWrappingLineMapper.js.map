{"version":3,"file":"vs/editor/common/viewModel/characterHardWrappingLineMapper.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/editor/common/viewModel/characterHardWrappingLineMapper.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as strings from 'vs/base/common/strings';\nimport {WrappingIndent} from 'vs/editor/common/editorCommon';\nimport {PrefixSumComputer} from 'vs/editor/common/viewModel/prefixSumComputer';\nimport {ILineMapperFactory, ILineMapping, OutputPosition} from 'vs/editor/common/viewModel/splitLinesCollection';\n\nenum CharacterClass {\n\tNONE = 0,\n\tBREAK_BEFORE = 1,\n\tBREAK_AFTER = 2,\n\tBREAK_OBTRUSIVE = 3,\n\tBREAK_IDEOGRAPHIC = 4 // for Han and Kana.\n}\n\nclass CharacterClassifier {\n\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprivate _asciiMap: CharacterClass[];\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprivate _map: CharacterClass[];\n\n\tconstructor(BREAK_BEFORE:string, BREAK_AFTER:string, BREAK_OBTRUSIVE:string) {\n\n\t\tthis._asciiMap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tthis._asciiMap[i] = CharacterClass.NONE;\n\t\t}\n\n\t\tthis._map = [];\n\n\t\tfor (let i = 0; i < BREAK_BEFORE.length; i++) {\n\t\t\tthis._set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);\n\t\t}\n\n\t\tfor (let i = 0; i < BREAK_AFTER.length; i++) {\n\t\t\tthis._set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);\n\t\t}\n\n\t\tfor (let i = 0; i < BREAK_OBTRUSIVE.length; i++) {\n\t\t\tthis._set(BREAK_OBTRUSIVE.charCodeAt(i), CharacterClass.BREAK_OBTRUSIVE);\n\t\t}\n\t}\n\n\tprivate _set(charCode:number, charClass:CharacterClass): void {\n\t\tif (charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = charClass;\n\t\t}\n\t\tthis._map[charCode] = charClass;\n\t}\n\n\tpublic classify(charCode:number): CharacterClass {\n\t\tif (charCode < 256) {\n\t\t\treturn this._asciiMap[charCode];\n\t\t}\n\n\t\tlet charClass = this._map[charCode];\n\t\tif (charClass) {\n\t\t\treturn charClass;\n\t\t}\n\n\t\t// Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:\n\t\t// 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)\n\t\t// 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)\n\t\t// 3. Hiragana and Katakana (0x3040 -- 0x30FF)\n\t\tif (\n\t\t\t(charCode >= 0x3040 && charCode <= 0x30FF)\n\t\t\t|| (charCode >= 0x3400 && charCode <= 0x4DBF)\n\t\t\t|| (charCode >= 0x4E00 && charCode <= 0x9FFF)\n\t\t) {\n\t\t\treturn CharacterClass.BREAK_IDEOGRAPHIC;\n\t\t}\n\n\t\treturn CharacterClass.NONE;\n\t}\n}\n\nexport class CharacterHardWrappingLineMapperFactory implements ILineMapperFactory {\n\n\tprivate classifier:CharacterClassifier;\n\n\tconstructor(breakBeforeChars:string, breakAfterChars:string, breakObtrusiveChars:string) {\n\t\tthis.classifier = new CharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);\n\t}\n\n\t// TODO@Alex -> duplicated in lineCommentCommand\n\tprivate static nextVisibleColumn(currentVisibleColumn:number, tabSize:number, isTab:boolean, columnSize:number): number {\n\t\tcurrentVisibleColumn = +currentVisibleColumn; //@perf\n\t\ttabSize = +tabSize; //@perf\n\t\tcolumnSize = +columnSize; //@perf\n\n\t\tif (isTab) {\n\t\t\treturn currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));\n\t\t}\n\t\treturn currentVisibleColumn + columnSize;\n\t}\n\n\tpublic createLineMapping(lineText: string, tabSize: number, breakingColumn: number, columnsForFullWidthChar:number, hardWrappingIndent:WrappingIndent): ILineMapping {\n\t\tif (breakingColumn === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttabSize = +tabSize; //@perf\n\t\tbreakingColumn = +breakingColumn; //@perf\n\t\tcolumnsForFullWidthChar = +columnsForFullWidthChar; //@perf\n\t\thardWrappingIndent = +hardWrappingIndent; //@perf\n\n\t\tlet wrappedTextIndentVisibleColumn = 0;\n\t\tlet wrappedTextIndent = '';\n\t\tconst TAB_CHAR_CODE = '\\t'.charCodeAt(0);\n\n\t\tif (hardWrappingIndent !== WrappingIndent.None) {\n\t\t\tlet firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);\n\t\t\tif (firstNonWhitespaceIndex !== -1) {\n\t\t\t\twrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);\n\t\t\t\tfor (let i = 0; i < firstNonWhitespaceIndex; i++) {\n\t\t\t\t\twrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === TAB_CHAR_CODE, 1);\n\t\t\t\t}\n\t\t\t\tif (hardWrappingIndent === WrappingIndent.Indent) {\n\t\t\t\t\twrappedTextIndent += '\\t';\n\t\t\t\t\twrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);\n\t\t\t\t}\n\t\t\t\t// Force sticking to beginning of line if indentColumn > 66% breakingColumn\n\t\t\t\tif (wrappedTextIndentVisibleColumn > 1/2 * breakingColumn) {\n\t\t\t\t\twrappedTextIndent = '';\n\t\t\t\t\twrappedTextIndentVisibleColumn = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet classifier = this.classifier;\n\t\tlet lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened\n\t\tlet breakingLengths:number[] = []; // The length of each broken-up line text\n\t\tlet breakingLengthsIndex:number = 0; // The count of breaks already done\n\t\tlet visibleColumn = 0; // Visible column since the beginning of the current line\n\t\tlet breakBeforeOffset:number; // 0-based offset in the lineText before which breaking\n\t\tlet restoreVisibleColumnFrom:number;\n\t\tlet niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)\n\t\tlet niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`\n\t\tlet obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)\n\t\tlet obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`\n\t\tlet len = lineText.length;\n\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\t// At this point, there is a certainty that the character before `i` fits on the current line,\n\t\t\t// but the character at `i` might not fit\n\n\t\t\tlet charCode = lineText.charCodeAt(i);\n\t\t\tlet charCodeIsTab = (charCode === TAB_CHAR_CODE);\n\t\t\tlet charCodeClass = classifier.classify(charCode);\n\n\t\t\tif (charCodeClass === CharacterClass.BREAK_BEFORE) {\n\t\t\t\t// This is a character that indicates that a break should happen before it\n\t\t\t\t// Since we are certain the character before `i` fits, there's no extra checking needed,\n\t\t\t\t// just mark it as a nice breaking opportunity\n\t\t\t\tniceBreakOffset = i;\n\t\t\t\tniceBreakVisibleColumn = 0;\n\t\t\t}\n\n\t\t\t// CJK breaking : before break\n\t\t\tif (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i > 0) {\n\t\t\t\tlet prevCode = lineText.charCodeAt(i - 1);\n\t\t\t\tlet prevClass = classifier.classify(prevCode);\n\t\t\t\tif (prevClass !== CharacterClass.BREAK_BEFORE) { // Kinsoku Shori: Don't break after a leading character, like an open bracket\n\t\t\t\t\tniceBreakOffset = i;\n\t\t\t\t\tniceBreakVisibleColumn = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet charColumnSize = 1;\n\t\t\tif (strings.isFullWidthCharacter(charCode)) {\n\t\t\t\tcharColumnSize = columnsForFullWidthChar;\n\t\t\t}\n\n\t\t\t// Advance visibleColumn with character at `i`\n\t\t\tvisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\n\t\t\tif (visibleColumn > breakingColumn && i !== 0) {\n\t\t\t\t// We need to break at least before character at `i`:\n\t\t\t\t//  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))\n\t\t\t\t//  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))\n\t\t\t\t//  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))\n\n\t\t\t\tif (niceBreakOffset !== -1) {\n\n\t\t\t\t\t// We will break before `niceBreakLastOffset`\n\t\t\t\t\tbreakBeforeOffset = niceBreakOffset;\n\t\t\t\t\trestoreVisibleColumnFrom = niceBreakVisibleColumn + wrappedTextIndentVisibleColumn;\n\n\t\t\t\t} else if (obtrusiveBreakOffset !== -1) {\n\n\t\t\t\t\t// We will break before `obtrusiveBreakLastOffset`\n\t\t\t\t\tbreakBeforeOffset = obtrusiveBreakOffset;\n\t\t\t\t\trestoreVisibleColumnFrom = obtrusiveBreakVisibleColumn + wrappedTextIndentVisibleColumn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// We will break before `i`\n\t\t\t\t\tbreakBeforeOffset = i;\n\t\t\t\t\trestoreVisibleColumnFrom = 0 + wrappedTextIndentVisibleColumn;\n\n\t\t\t\t}\n\n\t\t\t\t// Break before character at `breakBeforeOffset`\n\t\t\t\tbreakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;\n\t\t\t\tlastBreakingOffset = breakBeforeOffset;\n\n\t\t\t\t// Re-establish visibleColumn by taking character at `i` into account\n\t\t\t\tvisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);\n\n\t\t\t\t// Reset markers\n\t\t\t\tniceBreakOffset = -1;\n\t\t\t\tniceBreakVisibleColumn = 0;\n\t\t\t\tobtrusiveBreakOffset = -1;\n\t\t\t\tobtrusiveBreakVisibleColumn = 0;\n\t\t\t}\n\n\t\t\t// At this point, there is a certainty that the character at `i` fits on the current line\n\n\t\t\tif (niceBreakOffset !== -1) {\n\t\t\t\t// Advance niceBreakVisibleColumn\n\t\t\t\tniceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\t\t\t}\n\t\t\tif (obtrusiveBreakOffset !== -1) {\n\t\t\t\t// Advance obtrusiveBreakVisibleColumn\n\t\t\t\tobtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);\n\t\t\t}\n\n\t\t\tif (charCodeClass === CharacterClass.BREAK_AFTER) {\n\t\t\t\t// This is a character that indicates that a break should happen after it\n\t\t\t\tniceBreakOffset = i + 1;\n\t\t\t\tniceBreakVisibleColumn = 0;\n\t\t\t}\n\n\t\t\t// CJK breaking : after break\n\t\t\tif (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i < len - 1) {\n\t\t\t\tlet nextCode = lineText.charCodeAt(i + 1);\n\t\t\t\tlet nextClass = classifier.classify(nextCode);\n\t\t\t\tif (nextClass !== CharacterClass.BREAK_AFTER) { // Kinsoku Shori: Don't break before a trailing character, like a period\n\t\t\t\t\tniceBreakOffset = i + 1;\n\t\t\t\t\tniceBreakVisibleColumn = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (charCodeClass === CharacterClass.BREAK_OBTRUSIVE) {\n\t\t\t\t// This is an obtrusive character that indicates that a break should happen after it\n\t\t\t\tobtrusiveBreakOffset = i + 1;\n\t\t\t\tobtrusiveBreakVisibleColumn = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (breakingLengthsIndex === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Add last segment\n\t\tbreakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;\n\n\t\treturn new CharacterHardWrappingLineMapping(new PrefixSumComputer(breakingLengths), wrappedTextIndent);\n\t}\n}\n\nexport class CharacterHardWrappingLineMapping implements ILineMapping {\n\n\tprivate _prefixSums:PrefixSumComputer;\n\tprivate _wrappedLinesIndent:string;\n\n\tconstructor(prefixSums:PrefixSumComputer, wrappedLinesIndent:string) {\n\t\tthis._prefixSums = prefixSums;\n\t\tthis._wrappedLinesIndent = wrappedLinesIndent;\n\t}\n\n\tpublic getOutputLineCount(): number {\n\t\treturn this._prefixSums.getCount();\n\t}\n\n\tpublic getWrappedLinesIndent(): string {\n\t\treturn this._wrappedLinesIndent;\n\t}\n\n\tpublic getInputOffsetOfOutputPosition(outputLineIndex:number, outputOffset:number): number {\n\t\tif (outputLineIndex === 0) {\n\t\t\treturn outputOffset;\n\t\t} else {\n\t\t\treturn this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;\n\t\t}\n\t}\n\n\tpublic getOutputPositionOfInputOffset(inputOffset:number): OutputPosition {\n\t\tlet r = this._prefixSums.getIndexOf(inputOffset);\n\t\treturn new OutputPosition(r.index, r.remainder);\n\t}\n}\n"]}