{"version":3,"file":"githubFileService.js","sourceRoot":"","sources":["../src/githubFileService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\n// This is a port of vs/workbench/services/files/node/fileService.ts with Node dependencies\n// removed/replaced.\n\n// TODO: import paths = require('path');\n// TODO: import fs = require('fs');\n// TODO: import os = require('os');\n// TODO: import crypto = require('crypto');\n// TODO: import assert = require('assert');\n\nimport files = require('vs/platform/files/common/files');\nimport strings = require('vs/base/common/strings');\nimport arrays = require('vs/base/common/arrays');\nimport baseMime = require('vs/base/common/mime');\nimport basePaths = require('vs/base/common/paths');\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport types = require('vs/base/common/types');\nimport objects = require('vs/base/common/objects');\n// TODO: import extfs = require('vs/base/node/extfs');\nimport {nfcall, Limiter, ThrottledDelayer} from 'vs/base/common/async';\nimport uri from 'vs/base/common/uri';\nimport nls = require('vs/nls');\n\n// TODO: import pfs = require('vs/base/node/pfs');\n// TODO: import encoding = require('vs/base/node/encoding');\n// TODO: import mime = require('vs/base/node/mime');\n// TODO: import flow = require('vs/base/node/flow');\n// TODO: import {FileWatcher as UnixWatcherService} from 'vs/workbench/services/files/node/watcher/unix/watcherService';\n// TODO: import {FileWatcher as WindowsWatcherService} from 'vs/workbench/services/files/node/watcher/win32/watcherService';\n// TODO: import {toFileChangesEvent, normalize, IRawFileChange} from 'vs/workbench/services/files/node/watcher/common';\nimport {IEventService} from 'vs/platform/event/common/event';\n\nexport interface IEncodingOverride {\n\tresource: uri;\n\tencoding: string;\n}\n\nexport interface IFileServiceOptions {\n\ttmpDir?: string;\n\terrorLogger?: (msg: string) => void;\n\tencoding?: string;\n\tbom?: string;\n\tencodingOverride?: IEncodingOverride[];\n\twatcherIgnoredPatterns?: string[];\n\tdisableWatcher?: boolean;\n\tverboseLogging?: boolean;\n}\n\n/* TODO:\nfunction etag(stat: fs.Stats): string;\nfunction etag(size: number, mtime: number): string;\nfunction etag(arg1: any, arg2?: any): string {\n\tlet size: number;\n\tlet mtime: number;\n\tif (typeof arg2 === 'number') {\n\t\tsize = arg1;\n\t\tmtime = arg2;\n\t} else {\n\t\tsize = (<fs.Stats>arg1).size;\n\t\tmtime = (<fs.Stats>arg1).mtime.getTime();\n\t}\n\n\treturn '\"' + crypto.createHash('sha1').update(String(size) + String(mtime)).digest('hex') + '\"';\n}\n*/\n\nexport class FileService implements files.IFileService {\n\n\tpublic serviceId = files.IFileService;\n\n\tprivate static FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n\tprivate static MAX_DEGREE_OF_PARALLEL_FS_OPS = 10; // degree of parallel fs calls that we accept at the same time\n\n\tprivate basePath: string;\n\tprivate tmpPath: string;\n\tprivate options: IFileServiceOptions;\n\n\tprivate workspaceWatcherToDispose: () => void;\n\n\t// TODO: private activeFileChangesWatchers: { [resource: string]: fs.FSWatcher; };\n\tprivate fileChangesWatchDelayer: ThrottledDelayer<void>;\n\t// TODO: private undeliveredRawFileChangesEvents: IRawFileChange[];\n\n\tconstructor(basePath: string, options: IFileServiceOptions, private eventEmitter: IEventService) {\n\t\t/* TODO:\n\t\tthis.basePath = basePath ? paths.normalize(basePath) : void 0;\n\n\t\tif (this.basePath && this.basePath.indexOf('\\\\\\\\') === 0 && strings.endsWith(this.basePath, paths.sep)) {\n\t\t\t// for some weird reason, node adds a trailing slash to UNC paths\n\t\t\t// we never ever want trailing slashes as our base path unless\n\t\t\t// someone opens root (\"/\").\n\t\t\t// See also https://github.com/nodejs/io.js/issues/1765\n\t\t\tthis.basePath = strings.rtrim(this.basePath, paths.sep);\n\t\t}\n\n\t\tif (this.basePath && !paths.isAbsolute(basePath)) {\n\t\t\tthrow new Error('basePath has to be an absolute path');\n\t\t}\n\n\t\tthis.options = options || Object.create(null);\n\t\tthis.tmpPath = this.options.tmpDir || os.tmpdir();\n\n\t\tif (this.options && !this.options.errorLogger) {\n\t\t\tthis.options.errorLogger = console.error;\n\t\t}\n\n\t\tif (this.basePath && !this.options.disableWatcher) {\n\t\t\tif (process.platform === 'win32') {\n\t\t\t\tthis.setupWin32WorkspaceWatching();\n\t\t\t} else {\n\t\t\t\tthis.setupUnixWorkspaceWatching();\n\t\t\t}\n\t\t}\n\n\t\tthis.activeFileChangesWatchers = Object.create(null);\n\t\tthis.fileChangesWatchDelayer = new ThrottledDelayer<void>(FileService.FS_EVENT_DELAY);\n\t\tthis.undeliveredRawFileChangesEvents = [];\n\t\t*/\n\t}\n\n\tpublic updateOptions(options: IFileServiceOptions): void {\n\t\tif (options) {\n\t\t\tobjects.mixin(this.options, options); // overwrite current options\n\t\t}\n\t}\n\n\tprivate setupWin32WorkspaceWatching(): void {\n\t\t/* TODO:\n\t\tthis.workspaceWatcherToDispose = new WindowsWatcherService(this.basePath, this.options.watcherIgnoredPatterns, this.eventEmitter, this.options.errorLogger, this.options.verboseLogging).startWatching();\n\t\t*/\n\t}\n\n\tprivate setupUnixWorkspaceWatching(): void {\n\t\t/* TODO:\n\t\tthis.workspaceWatcherToDispose = new UnixWatcherService(this.basePath, this.options.watcherIgnoredPatterns, this.eventEmitter, this.options.errorLogger, this.options.verboseLogging).startWatching();\n\t\t*/\n\t}\n\n\tpublic resolveFile(resource: uri, options?: files.IResolveFileOptions): TPromise<files.IFileStat> {\n\t\treturn this.resolve(resource, options);\n\t}\n\n\tpublic resolveContent(resource: uri, options?: files.IResolveContentOptions): TPromise<files.IContent> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.resolveContent not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) detect mimes\n\t\treturn nfcall(mime.detectMimesFromFile, absolutePath).then((detected: mime.IMimeAndEncoding) => {\n\t\t\tlet isText = detected.mimes.indexOf(baseMime.MIME_BINARY) === -1;\n\n\t\t\t// Return error early if client only accepts text and this is not text\n\t\t\tif (options && options.acceptTextOnly && !isText) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tmessage: nls.localize('fileBinaryError', \"File seems to be binary and cannot be opened as text\"),\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_IS_BINARY\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet preferredEncoding: string;\n\t\t\tif (options && options.encoding) {\n\t\t\t\tif (detected.encoding === encoding.UTF8 && options.encoding === encoding.UTF8) {\n\t\t\t\t\tpreferredEncoding = encoding.UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\n\t\t\t\t} else {\n\t\t\t\t\tpreferredEncoding = options.encoding; // give passed in encoding highest priority\n\t\t\t\t}\n\t\t\t} else if (detected.encoding) {\n\t\t\t\tif (detected.encoding === encoding.UTF8) {\n\t\t\t\t\tpreferredEncoding = encoding.UTF8_with_bom; // if we detected UTF-8, it can only be because of a BOM\n\t\t\t\t} else {\n\t\t\t\t\tpreferredEncoding = detected.encoding;\n\t\t\t\t}\n\t\t\t} else if (this.options.encoding === encoding.UTF8_with_bom) {\n\t\t\t\tpreferredEncoding = encoding.UTF8; // if we did not detect UTF 8 BOM before, this can only be UTF 8 then\n\t\t\t}\n\n\t\t\t// 2.) get content\n\t\t\treturn this.resolveFileContent(resource, options && options.etag, preferredEncoding).then((content) => {\n\n\t\t\t\t// set our knowledge about the mime on the content obj\n\t\t\t\tcontent.mime = detected.mimes.join(', ');\n\n\t\t\t\treturn content;\n\t\t\t});\n\t\t}, (error) => {\n\n\t\t\t// bubble up existing file operation results\n\t\t\tif (!types.isUndefinedOrNull((<files.IFileOperationResult>error).fileOperationResult)) {\n\t\t\t\treturn TPromise.wrapError(error);\n\t\t\t}\n\n\t\t\t// on error check if the file does not exist or is a folder and return with proper error result\n\t\t\treturn pfs.exists(absolutePath).then((exists) => {\n\n\t\t\t\t// Return if file not found\n\t\t\t\tif (!exists) {\n\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\tmessage: nls.localize('fileNotFoundError', \"File not found ({0})\", absolutePath),\n\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Otherwise check for file being a folder?\n\t\t\t\treturn pfs.stat(absolutePath).then((stat) => {\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\t\tmessage: nls.localize('fileIsDirectoryError', \"File is directory ({0})\", absolutePath),\n\t\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_IS_DIRECTORY\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise just give up\n\t\t\t\t\treturn TPromise.wrapError(error);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic resolveContents(resources: uri[]): TPromise<files.IContent[]> {\n\t\tlet limiter = new Limiter(FileService.MAX_DEGREE_OF_PARALLEL_FS_OPS);\n\n\t\tlet contentPromises = <TPromise<files.IContent>[]>[];\n\t\tresources.forEach((resource) => {\n\t\t\tcontentPromises.push(limiter.queue(() => this.resolveFileContent(resource).then((content) => content, (error) => TPromise.as(null /* ignore errors gracefully */))));\n\t\t});\n\n\t\treturn TPromise.join(contentPromises).then((contents) => {\n\t\t\treturn arrays.coalesce(contents);\n\t\t});\n\t}\n\n\tpublic updateContent(resource: uri, value: string, options: files.IUpdateContentOptions = Object.create(null)): TPromise<files.IFileStat> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.updateContent not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) check file\n\t\treturn this.checkFile(absolutePath, options).then((exists) => {\n\t\t\tlet createParentsPromise: TPromise<boolean>;\n\t\t\tif (exists) {\n\t\t\t\tcreateParentsPromise = TPromise.as(null);\n\t\t\t} else {\n\t\t\t\tcreateParentsPromise = pfs.mkdirp(paths.dirname(absolutePath));\n\t\t\t}\n\n\t\t\t// 2.) create parents as needed\n\t\t\treturn createParentsPromise.then(() => {\n\t\t\t\tlet encodingToWrite = this.getEncoding(resource, options.encoding);\n\t\t\t\tlet addBomPromise: TPromise<boolean> = TPromise.as(false);\n\n\t\t\t\t// UTF_16 BE and LE as well as UTF_8 with BOM always have a BOM\n\t\t\t\tif (encodingToWrite === encoding.UTF16be || encodingToWrite === encoding.UTF16le || encodingToWrite === encoding.UTF8_with_bom) {\n\t\t\t\t\taddBomPromise = TPromise.as(true);\n\t\t\t\t}\n\n\t\t\t\t// Existing UTF-8 file: check for options regarding BOM\n\t\t\t\telse if (exists && encodingToWrite === encoding.UTF8) {\n\t\t\t\t\tif (options.overwriteEncoding) {\n\t\t\t\t\t\taddBomPromise = TPromise.as(false); // if we are to overwrite the encoding, we do not preserve it if found\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddBomPromise = nfcall(encoding.detectEncodingByBOM, absolutePath).then((enc) => enc === encoding.UTF8); // otherwise preserve it if found\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 3.) check to add UTF BOM\n\t\t\t\treturn addBomPromise.then((addBom) => {\n\t\t\t\t\tlet writeFilePromise: TPromise<void>;\n\n\t\t\t\t\t// Write fast if we do UTF 8 without BOM\n\t\t\t\t\tif (!addBom && encodingToWrite === encoding.UTF8) {\n\t\t\t\t\t\twriteFilePromise = pfs.writeFile(absolutePath, value, encoding.UTF8);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise use encoding lib\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet encoded = encoding.encode(value, encodingToWrite, { addBOM: addBom });\n\t\t\t\t\t\twriteFilePromise = pfs.writeFile(absolutePath, encoded);\n\t\t\t\t\t}\n\n\t\t\t\t\t// 4.) set contents\n\t\t\t\t\treturn writeFilePromise.then(() => {\n\n\t\t\t\t\t\t// 5.) resolve\n\t\t\t\t\t\treturn this.resolve(resource);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic createFile(resource: uri, content: string = ''): TPromise<files.IFileStat> {\n\t\treturn this.updateContent(resource, content);\n\t}\n\n\tpublic createFolder(resource: uri): TPromise<files.IFileStat> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.createFolder not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\n\t\t/* TODO:\n\t\t// 1.) create folder\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\t\treturn pfs.mkdirp(absolutePath).then(() => {\n\n\t\t\t// 2.) resolve\n\t\t\treturn this.resolve(resource);\n\t\t});\n\t\t*/\n\t}\n\n\tpublic rename(resource: uri, newName: string): TPromise<files.IFileStat> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.rename not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet newPath = paths.join(paths.dirname(resource.fsPath), newName);\n\n\t\treturn this.moveFile(resource, uri.file(newPath));\n\t\t*/\n\t}\n\n\tpublic moveFile(source: uri, target: uri, overwrite?: boolean): TPromise<files.IFileStat> {\n\t\treturn this.moveOrCopyFile(source, target, false, overwrite);\n\t}\n\n\tpublic copyFile(source: uri, target: uri, overwrite?: boolean): TPromise<files.IFileStat> {\n\t\treturn this.moveOrCopyFile(source, target, true, overwrite);\n\t}\n\n\tprivate moveOrCopyFile(source: uri, target: uri, keepCopy: boolean, overwrite: boolean): TPromise<files.IFileStat> {\n\t\tlet sourcePath = this.toAbsolutePath(source);\n\t\tlet targetPath = this.toAbsolutePath(target);\n\n\t\t// 1.) move / copy\n\t\treturn this.doMoveOrCopyFile(sourcePath, targetPath, keepCopy, overwrite).then(() => {\n\n\t\t\t// 2.) resolve\n\t\t\treturn this.resolve(target);\n\t\t});\n\t}\n\n\tprivate doMoveOrCopyFile(sourcePath: string, targetPath: string, keepCopy: boolean, overwrite: boolean): TPromise<boolean /* exists */> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.doMoveOrCopyFile not implemented (' + sourcePath + ' -> ' + targetPath + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\n\t\t/* TODO:\n\t\t// 1.) check if target exists\n\t\treturn pfs.exists(targetPath).then((exists) => {\n\t\t\tlet isCaseRename = sourcePath.toLowerCase() === targetPath.toLowerCase();\n\t\t\tlet isSameFile = sourcePath === targetPath;\n\n\t\t\t// Return early with conflict if target exists and we are not told to overwrite\n\t\t\tif (exists && !isCaseRename && !overwrite) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_MOVE_CONFLICT\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// 2.) make sure target is deleted before we move/copy unless this is a case rename of the same file\n\t\t\tlet deleteTargetPromise = TPromise.as(null);\n\t\t\tif (exists && !isCaseRename) {\n\t\t\t\tif (basePaths.isEqualOrParent(sourcePath, targetPath)) {\n\t\t\t\t\treturn TPromise.wrapError(nls.localize('unableToMoveCopyError', \"Unable to move/copy. File would replace folder it is contained in.\")); // catch this corner case!\n\t\t\t\t}\n\n\t\t\t\tdeleteTargetPromise = this.del(uri.file(targetPath));\n\t\t\t}\n\n\t\t\treturn deleteTargetPromise.then(() => {\n\n\t\t\t\t// 3.) make sure parents exists\n\t\t\t\treturn pfs.mkdirp(paths.dirname(targetPath)).then(() => {\n\n\t\t\t\t\t// 4.) copy/move\n\t\t\t\t\tif (isSameFile) {\n\t\t\t\t\t\treturn TPromise.as(null);\n\t\t\t\t\t} else if (keepCopy) {\n\t\t\t\t\t\treturn nfcall(extfs.copy, sourcePath, targetPath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn nfcall(extfs.mv, sourcePath, targetPath);\n\t\t\t\t\t}\n\t\t\t\t}).then(() => exists);\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic importFile(source: uri, targetFolder: uri): TPromise<files.IImportResult> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.importFile not implemented (' + source.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet sourcePath = this.toAbsolutePath(source);\n\t\tlet targetResource = uri.file(paths.join(targetFolder.fsPath, paths.basename(source.fsPath)));\n\t\tlet targetPath = this.toAbsolutePath(targetResource);\n\n\t\t// 1.) resolve\n\t\treturn pfs.stat(sourcePath).then((stat) => {\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\treturn TPromise.wrapError(nls.localize('foldersCopyError', \"Folders cannot be copied into the workspace. Please select individual files to copy them.\")); // for now we do not allow to import a folder into a workspace\n\t\t\t}\n\n\t\t\t// 2.) copy\n\t\t\treturn this.doMoveOrCopyFile(sourcePath, targetPath, true, true).then((exists) => {\n\n\t\t\t\t// 3.) resolve\n\t\t\t\treturn this.resolve(targetResource).then((stat) => <files.IImportResult>{ isNew: !exists, stat: stat });\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic del(resource: uri): TPromise<void> {\n\t\tconsole.log('githubFileService.del not implemented (' + resource.toString(true) + ')');\n\t\treturn TPromise.as<void>(null);\n\t\t/* TODO:\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\treturn nfcall(extfs.del, absolutePath, this.tmpPath);\n\t\t*/\n\t}\n\n\t// Helpers\n\n\tprivate toAbsolutePath(arg1: uri | files.IFileStat): string {\n\t\tconsole.log('githubFileService.toAbsolutePath not implemented (' + arg1.toString(true) + ')');\n\t\treturn null;\n\t\t/* TODO:\n\t\tlet resource: uri;\n\t\tif (arg1 instanceof uri) {\n\t\t\tresource = <uri>arg1;\n\t\t} else {\n\t\t\tresource = (<files.IFileStat>arg1).resource;\n\t\t}\n\n\t\tassert.ok(resource && resource.scheme === 'file', 'Invalid resource: ' + resource);\n\n\t\treturn paths.normalize(resource.fsPath);\n\t\t*/\n\t}\n\n\tprivate resolve(resource: uri, options: files.IResolveFileOptions = Object.create(null)): TPromise<files.IFileStat> {\n\t\treturn this.toStatResolver(resource)\n\t\t\t.then(model => model.resolve(options));\n\t}\n\n\tprivate toStatResolver(resource: uri): TPromise<StatResolver> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.toStatResolver not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\treturn pfs.stat(absolutePath).then((stat: fs.Stats) => {\n\t\t\treturn new StatResolver(resource, stat.isDirectory(), stat.mtime.getTime(), stat.size, this.options.verboseLogging);\n\t\t});\n\t\t*/\n\t}\n\n\tprivate resolveFileContent(resource: uri, etag?: string, enc?: string): TPromise<files.IContent> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.resolveFileContent not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\t\t\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) stat\n\t\treturn this.resolve(resource).then((model) => {\n\n\t\t\t// Return early if file not modified since\n\t\t\tif (etag && etag === model.etag) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_MODIFIED_SINCE\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return early if file is too large to load\n\t\t\tif (types.isNumber(model.size) && model.size > files.MAX_FILE_SIZE) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_TOO_LARGE\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// 2.) read contents\n\t\t\treturn new TPromise<files.IContent>((c, e) => {\n\t\t\t\tlet done = false;\n\t\t\t\tlet chunks: NodeBuffer[] = [];\n\t\t\t\tlet fileEncoding = this.getEncoding(model.resource, enc);\n\n\t\t\t\tconst reader = fs.createReadStream(absolutePath).pipe(encoding.decodeStream(fileEncoding)); // decode takes care of stripping any BOMs from the file content\n\n\t\t\t\treader.on('data', (buf) => {\n\t\t\t\t\tchunks.push(buf);\n\t\t\t\t});\n\n\t\t\t\treader.on('error', (error) => {\n\t\t\t\t\tif (!done) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\te(error);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treader.on('end', () => {\n\t\t\t\t\tlet content: files.IContent = <any>model;\n\t\t\t\t\tcontent.value = chunks.join('');\n\t\t\t\t\tcontent.encoding = fileEncoding; // make sure to store the encoding in the model to restore it later when writing\n\n\t\t\t\t\tif (!done) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\tc(content);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tprivate getEncoding(resource: uri, preferredEncoding?: string): string {\n\t\tlet fileEncoding: string;\n\n\t\tlet override = this.getEncodingOverride(resource);\n\t\tif (override) {\n\t\t\tfileEncoding = override;\n\t\t} else if (preferredEncoding) {\n\t\t\tfileEncoding = preferredEncoding;\n\t\t} else {\n\t\t\tfileEncoding = this.options.encoding;\n\t\t}\n\n\t\t/* TODO:\n\t\tif (!fileEncoding || !encoding.encodingExists(fileEncoding)) {\n\t\t\tfileEncoding = encoding.UTF8; // the default is UTF 8\n\t\t}\n\t\t*/\n\n\t\treturn fileEncoding;\n\t}\n\n\tprivate getEncodingOverride(resource: uri): string {\n\t\tif (resource && this.options.encodingOverride && this.options.encodingOverride.length) {\n\t\t\tfor (let i = 0; i < this.options.encodingOverride.length; i++) {\n\t\t\t\tlet override = this.options.encodingOverride[i];\n\n\t\t\t\t// check if the resource is a child of the resource with override and use\n\t\t\t\t// the provided encoding in that case\n\t\t\t\tif (resource.toString().indexOf(override.resource.toString() + '/') === 0) {\n\t\t\t\t\treturn override.encoding;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate checkFile(absolutePath: string, options: files.IUpdateContentOptions): TPromise<boolean /* exists */> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.resolveFileContent not implemented (' + absolutePath + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t\n\t\t/* TODO:\n\t\treturn pfs.exists(absolutePath).then((exists) => {\n\t\t\tif (exists) {\n\t\t\t\treturn pfs.stat(absolutePath).then((stat: fs.Stats) => {\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\treturn TPromise.wrapError(new Error('Expected file is actually a directory'));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dirty write prevention\n\t\t\t\t\tif (typeof options.mtime === 'number' && typeof options.etag === 'string' && options.mtime < stat.mtime.getTime()) {\n\n\t\t\t\t\t\t// Find out if content length has changed\n\t\t\t\t\t\tif (options.etag !== etag(stat.size, options.mtime)) {\n\t\t\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\t\t\tmessage: 'File Modified Since',\n\t\t\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_MODIFIED_SINCE\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet mode = stat.mode;\n\t\t\t\t\tlet readonly = !(mode & 128);\n\n\t\t\t\t\t// Throw if file is readonly and we are not instructed to overwrite\n\t\t\t\t\tif (readonly && !options.overwriteReadonly) {\n\t\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\t\tmessage: nls.localize('fileReadOnlyError', \"File is Read Only\"),\n\t\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_READ_ONLY\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (readonly) {\n\t\t\t\t\t\tmode = mode | 128;\n\t\t\t\t\t\treturn pfs.chmod(absolutePath, mode).then(() => exists);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn TPromise.as<boolean>(exists);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn TPromise.as<boolean>(exists);\n\t\t});\n\t\t*/\n\t}\n\n\tpublic watchFileChanges(resource: uri): void {\n\t\tconsole.log('githubFileService.watchFileChanges not implemented (' + resource.toString(true) + ')');\n\t\t/* TODO:\n\t\tassert.ok(resource && resource.scheme === 'file', 'Invalid resource for watching: ' + resource);\n\n\t\tlet fsPath = resource.fsPath;\n\n\t\t// Create or get watcher for provided path\n\t\tlet watcher = this.activeFileChangesWatchers[resource.toString()];\n\t\tif (!watcher) {\n\t\t\ttry {\n\t\t\t\twatcher = fs.watch(fsPath); // will be persistent but not recursive\n\t\t\t} catch (error) {\n\t\t\t\t// the path might not exist anymore, ignore this error and return\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.activeFileChangesWatchers[resource.toString()] = watcher;\n\n\t\t\t// eventType is either 'rename' or 'change'\n\t\t\twatcher.on('change', (eventType: string) => {\n\t\t\t\tif (eventType !== 'change') {\n\t\t\t\t\treturn; // only care about changes for now ('rename' is not reliable and can be send even if the file is still there with some tools)\n\t\t\t\t}\n\n\t\t\t\t// add to bucket of undelivered events\n\t\t\t\tthis.undeliveredRawFileChangesEvents.push({\n\t\t\t\t\ttype: files.FileChangeType.UPDATED,\n\t\t\t\t\tpath: fsPath\n\t\t\t\t});\n\n\t\t\t\t// handle emit through delayer to accommodate for bulk changes\n\t\t\t\tthis.fileChangesWatchDelayer.trigger(() => {\n\t\t\t\t\tlet buffer = this.undeliveredRawFileChangesEvents;\n\t\t\t\t\tthis.undeliveredRawFileChangesEvents = [];\n\n\t\t\t\t\t// Normalize\n\t\t\t\t\tlet normalizedEvents = normalize(buffer);\n\n\t\t\t\t\t// Emit\n\t\t\t\t\tthis.eventEmitter.emit(files.EventType.FILE_CHANGES, toFileChangesEvent(normalizedEvents));\n\n\t\t\t\t\treturn TPromise.as(null);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t*/\n\t}\n\n\tpublic unwatchFileChanges(resource: uri): void;\n\tpublic unwatchFileChanges(path: string): void;\n\tpublic unwatchFileChanges(arg1: any): void {\n\t\tlet resource = (typeof arg1 === 'string') ? uri.parse(arg1) : arg1;\n\t\tconsole.log('githubFileService.unwatchFileChanges not implemented (' + resource + ')');\n\t\t\n\t\t/* TODO:\n\t\tlet watcher = this.activeFileChangesWatchers[resource.toString()];\n\t\tif (watcher) {\n\t\t\twatcher.close();\n\t\t\tdelete this.activeFileChangesWatchers[resource.toString()];\n\t\t}\n\t\t*/\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.workspaceWatcherToDispose) {\n\t\t\tthis.workspaceWatcherToDispose();\n\t\t\tthis.workspaceWatcherToDispose = null;\n\t\t}\n\n\t\t/* TODO:\n\t\tfor (let key in this.activeFileChangesWatchers) {\n\t\t\tlet watcher = this.activeFileChangesWatchers[key];\n\t\t\twatcher.close();\n\t\t}\n\t\tthis.activeFileChangesWatchers = Object.create(null);\n\t\t*/\n\t}\n}\n\nexport class StatResolver {\n\tprivate resource: uri;\n\tprivate isDirectory: boolean;\n\tprivate mtime: number;\n\tprivate name: string;\n\tprivate mime: string;\n\tprivate etag: string;\n\tprivate size: number;\n\tprivate verboseLogging: boolean;\n\n\tconstructor(resource: uri, isDirectory: boolean, mtime: number, size: number, verboseLogging: boolean) {\n\t\tconsole.log('githubFileService.StarResolver constructor not implemented');\n\t\t/* TODO:\n\t\tassert.ok(resource && resource.scheme === 'file', 'Invalid resource: ' + resource);\n\n\t\tthis.resource = resource;\n\t\tthis.isDirectory = isDirectory;\n\t\tthis.mtime = mtime;\n\t\tthis.name = paths.basename(resource.fsPath);\n\t\tthis.mime = !this.isDirectory ? baseMime.guessMimeTypes(resource.fsPath).join(', ') : null;\n\t\tthis.etag = etag(size, mtime);\n\t\tthis.size = size;\n\n\t\tthis.verboseLogging = verboseLogging;\n\t\t*/\n\t}\n\n\tpublic resolve(options: files.IResolveFileOptions): TPromise<files.IFileStat> {\n\n\t\t// General Data\n\t\tlet fileStat: files.IFileStat = {\n\t\t\tresource: this.resource,\n\t\t\tisDirectory: this.isDirectory,\n\t\t\thasChildren: undefined,\n\t\t\tname: this.name,\n\t\t\tetag: this.etag,\n\t\t\tsize: this.size,\n\t\t\tmtime: this.mtime,\n\t\t\tmime: this.mime\n\t\t};\n\n\t\t// File Specific Data\n\t\tif (!this.isDirectory) {\n\t\t\treturn TPromise.as(fileStat);\n\t\t}\n\n\t\t// Directory Specific Data\n\t\telse {\n\n\t\t\t// Convert the paths from options.resolveTo to absolute paths\n\t\t\tlet absoluteTargetPaths: string[] = null;\n\t\t\tif (options && options.resolveTo) {\n\t\t\t\tabsoluteTargetPaths = [];\n\t\t\t\toptions.resolveTo.forEach((resource) => {\n\t\t\t\t\tabsoluteTargetPaths.push(resource.fsPath);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new TPromise((c, e) => {\n\n\t\t\t\t// Load children\n\t\t\t\tthis.resolveChildren(this.resource.fsPath, absoluteTargetPaths, options && options.resolveSingleChildDescendants, (children) => {\n\t\t\t\t\tchildren = arrays.coalesce(children); // we don't want those null children (could be permission denied when reading a child)\n\t\t\t\t\tfileStat.hasChildren = children && children.length > 0;\n\t\t\t\t\tfileStat.children = children || [];\n\n\t\t\t\t\tc(fileStat);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate resolveChildren(absolutePath: string, absoluteTargetPaths: string[], resolveSingleChildDescendants: boolean, callback: (children: files.IFileStat[]) => void): void {\n\t\tconsole.log('githubFileService.resolveChildren not implemented (' + absolutePath + ')');\n\t\t\n\t\t/* TODO:\n\t\textfs.readdir(absolutePath, (error: Error, files: string[]) => {\n\t\t\tif (error) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\n\t\t\t\treturn callback(null); // return - we might not have permissions to read the folder\n\t\t\t}\n\n\t\t\t// for each file in the folder\n\t\t\tflow.parallel(files, (file: string, clb: (error: Error, children: files.IFileStat) => void) => {\n\t\t\t\tlet fileResource = uri.file(paths.resolve(absolutePath, file));\n\t\t\t\tlet fileStat: fs.Stats;\n\t\t\t\tlet $this = this;\n\n\t\t\t\tflow.sequence(\n\t\t\t\t\tfunction onError(error: Error): void {\n\t\t\t\t\t\tif ($this.verboseLogging) {\n\t\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclb(null, null); // return - we might not have permissions to read the folder or stat the file\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction stat(): void {\n\t\t\t\t\t\tfs.stat(fileResource.fsPath, this);\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction countChildren(fsstat: fs.Stats): void {\n\t\t\t\t\t\tfileStat = fsstat;\n\n\t\t\t\t\t\tif (fileStat.isDirectory()) {\n\t\t\t\t\t\t\textfs.readdir(fileResource.fsPath, (error, result) => {\n\t\t\t\t\t\t\t\tthis(null, result ? result.length : 0);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis(null, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction resolve(childCount: number): void {\n\t\t\t\t\t\tlet childStat: files.IFileStat = {\n\t\t\t\t\t\t\tresource: fileResource,\n\t\t\t\t\t\t\tisDirectory: fileStat.isDirectory(),\n\t\t\t\t\t\t\thasChildren: childCount > 0,\n\t\t\t\t\t\t\tname: file,\n\t\t\t\t\t\t\tmtime: fileStat.mtime.getTime(),\n\t\t\t\t\t\t\tetag: etag(fileStat),\n\t\t\t\t\t\t\tsize: fileStat.size,\n\t\t\t\t\t\t\tmime: !fileStat.isDirectory() ? baseMime.guessMimeTypes(fileResource.fsPath).join(', ') : undefined\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Return early for files\n\t\t\t\t\t\tif (!fileStat.isDirectory()) {\n\t\t\t\t\t\t\treturn clb(null, childStat);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle Folder\n\t\t\t\t\t\tlet resolveFolderChildren = false;\n\t\t\t\t\t\tif (files.length === 1 && resolveSingleChildDescendants) {\n\t\t\t\t\t\t\tresolveFolderChildren = true;\n\t\t\t\t\t\t} else if (childCount > 0 && absoluteTargetPaths && absoluteTargetPaths.some((targetPath) => basePaths.isEqualOrParent(targetPath, fileResource.fsPath))) {\n\t\t\t\t\t\t\tresolveFolderChildren = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Continue resolving children based on condition\n\t\t\t\t\t\tif (resolveFolderChildren) {\n\t\t\t\t\t\t\t$this.resolveChildren(fileResource.fsPath, absoluteTargetPaths, resolveSingleChildDescendants, (children) => {\n\t\t\t\t\t\t\t\tchildren = arrays.coalesce(children);  // we don't want those null children\n\t\t\t\t\t\t\t\tchildStat.hasChildren = children && children.length > 0;\n\t\t\t\t\t\t\t\tchildStat.children = children || [];\n\n\t\t\t\t\t\t\t\tclb(null, childStat);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise return result\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tclb(null, childStat);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}, (errors, result) => {\n\t\t\t\tcallback(result);\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n}"]}