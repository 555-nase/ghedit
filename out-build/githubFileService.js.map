{"version":3,"file":"githubFileService.js","sourceRoot":"","sources":["../src/githubFileService.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\n// This is a port of vs/workbench/services/files/node/fileService.ts with Node dependencies\n// removed/replaced.\n\n// TODO: import paths = require('path');\n// TODO: import fs = require('fs');\n// TODO: import os = require('os');\n// TODO: import crypto = require('crypto');\n// TODO: import assert = require('assert');\n\nimport files = require('vs/platform/files/common/files');\nimport strings = require('vs/base/common/strings');\nimport arrays = require('vs/base/common/arrays');\nimport baseMime = require('vs/base/common/mime');\nimport paths = require('vs/base/common/paths');\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport types = require('vs/base/common/types');\nimport objects = require('vs/base/common/objects');\n// TODO: import extfs = require('vs/base/node/extfs');\nimport {nfcall, Limiter, ThrottledDelayer} from 'vs/base/common/async';\nimport uri from 'vs/base/common/uri';\nimport nls = require('vs/nls');\n\n// TODO: import pfs = require('vs/base/node/pfs');\n// TODO: import encoding = require('vs/base/node/encoding');\n// TODO: import mime = require('vs/base/node/mime');\n// TODO: import flow = require('vs/base/node/flow');\n// TODO: import {FileWatcher as UnixWatcherService} from 'vs/workbench/services/files/node/watcher/unix/watcherService';\n// TODO: import {FileWatcher as WindowsWatcherService} from 'vs/workbench/services/files/node/watcher/win32/watcherService';\n// TODO: import {toFileChangesEvent, normalize, IRawFileChange} from 'vs/workbench/services/files/node/watcher/common';\nimport {IEventService} from 'vs/platform/event/common/event';\nimport {Github, Repository, Error as GithubError} from 'github';\n\n// TODO: Use vs/base/node/encoding replacement.\nconst encoding = {\n\tUTF8: 'utf8',\n\tUTF8_with_bom: 'utf8bom',\n\tUTF16be: 'utf16be',\n\tUTF16le: 'utf16le',\n};\n\nexport interface IEncodingOverride {\n\tresource: uri;\n\tencoding: string;\n}\n\nexport interface IFileServiceOptions {\n\ttmpDir?: string;\n\terrorLogger?: (msg: string) => void;\n\tencoding?: string;\n\tbom?: string;\n\tencodingOverride?: IEncodingOverride[];\n\twatcherIgnoredPatterns?: string[];\n\tdisableWatcher?: boolean;\n\tverboseLogging?: boolean;\n}\n\n/* TODO:\nfunction etag(stat: fs.Stats): string;\nfunction etag(size: number, mtime: number): string;\nfunction etag(arg1: any, arg2?: any): string {\n\tlet size: number;\n\tlet mtime: number;\n\tif (typeof arg2 === 'number') {\n\t\tsize = arg1;\n\t\tmtime = arg2;\n\t} else {\n\t\tsize = (<fs.Stats>arg1).size;\n\t\tmtime = (<fs.Stats>arg1).mtime.getTime();\n\t}\n\n\treturn '\"' + crypto.createHash('sha1').update(String(size) + String(mtime)).digest('hex') + '\"';\n}\n*/\nfunction etag(size: number, mtime: number): string;\nfunction etag(arg1: any, arg2?: any): string {\n\tlet size: number;\n\tlet mtime: number;\n\tif (typeof arg2 === 'number') {\n\t\tsize = arg1;\n\t\tmtime = arg2;\n\t} else {\n\t\tthrow new Error('etag(fs.Stat) not implemented');\n//\t\tsize = (<fs.Stats>arg1).size;\n//\t\tmtime = (<fs.Stats>arg1).mtime.getTime();\n\t}\n\t// TODO: non-Node crypto\n\treturn '\"' + String(size) + String(mtime) + '\"';\n}\n\nexport class FileService implements files.IFileService {\n\n\tpublic serviceId = files.IFileService;\n\n\tprivate static FS_EVENT_DELAY = 50; // aggregate and only emit events when changes have stopped for this duration (in ms)\n\tprivate static MAX_DEGREE_OF_PARALLEL_FS_OPS = 10; // degree of parallel fs calls that we accept at the same time\n\n\tprivate basePath: string;\n\tprivate tmpPath: string;\n\tprivate options: IFileServiceOptions;\n\tprivate repo: Repository;\n\tprivate ref: string;\n\n\tprivate workspaceWatcherToDispose: () => void;\n\n\t// TODO: private activeFileChangesWatchers: { [resource: string]: fs.FSWatcher; };\n\tprivate fileChangesWatchDelayer: ThrottledDelayer<void>;\n\t// TODO: private undeliveredRawFileChangesEvents: IRawFileChange[];\n\n\tconstructor(basePath: string, options: IFileServiceOptions, private eventEmitter: IEventService, private githubService: Github) {\n\t\tthis.basePath = basePath ? paths.normalize(basePath) : void 0;\n\n\t\tthis.options = options || Object.create(null);\n\t\t/* TODO:\n\t\tthis.tmpPath = this.options.tmpDir || os.tmpdir();\n\n\t\tif (this.options && !this.options.errorLogger) {\n\t\t\tthis.options.errorLogger = console.error;\n\t\t}\n\n\t\tif (this.basePath && !this.options.disableWatcher) {\n\t\t\tif (process.platform === 'win32') {\n\t\t\t\tthis.setupWin32WorkspaceWatching();\n\t\t\t} else {\n\t\t\t\tthis.setupUnixWorkspaceWatching();\n\t\t\t}\n\t\t}\n\n\t\tthis.activeFileChangesWatchers = Object.create(null);\n\t\tthis.fileChangesWatchDelayer = new ThrottledDelayer<void>(FileService.FS_EVENT_DELAY);\n\t\tthis.undeliveredRawFileChangesEvents = [];\n\t\t*/\n\t\tthis.repo = this.githubService.getRepo(this.githubService.repo);\n\t\tthis.ref = this.githubService.ref;\n\t}\n\n\tpublic updateOptions(options: IFileServiceOptions): void {\n\t\tif (options) {\n\t\t\tobjects.mixin(this.options, options); // overwrite current options\n\t\t}\n\t}\n\n\tprivate setupWin32WorkspaceWatching(): void {\n\t\t/* TODO:\n\t\tthis.workspaceWatcherToDispose = new WindowsWatcherService(this.basePath, this.options.watcherIgnoredPatterns, this.eventEmitter, this.options.errorLogger, this.options.verboseLogging).startWatching();\n\t\t*/\n\t}\n\n\tprivate setupUnixWorkspaceWatching(): void {\n\t\t/* TODO:\n\t\tthis.workspaceWatcherToDispose = new UnixWatcherService(this.basePath, this.options.watcherIgnoredPatterns, this.eventEmitter, this.options.errorLogger, this.options.verboseLogging).startWatching();\n\t\t*/\n\t}\n\n\tpublic resolveFile(resource: uri, options?: files.IResolveFileOptions): TPromise<files.IFileStat> {\n\t\treturn this.resolve(resource, options);\n\t}\n\n\tpublic resolveContent(resource: uri, options?: files.IResolveContentOptions): TPromise<files.IContent> {\n\t\tlet preferredEncoding: string;\n\t\tif (options && options.encoding) {\n\t\t\tpreferredEncoding = options.encoding; // give passed in encoding highest priority\n\t\t} else if (this.options.encoding === encoding.UTF8_with_bom) {\n\t\t\tpreferredEncoding = encoding.UTF8; // if we did not detect UTF 8 BOM before, this can only be UTF 8 then\n\t\t}\n\t\treturn this.resolveFileContent(resource, options && options.etag, preferredEncoding).then((content) => {\n\n\t\t\t// set our knowledge about the mime on the content obj\n// TODO:\t\t\tcontent.mime = detected.mimes.join(', ');\n\n\t\t\treturn content;\n\t\t});\n\n\t\t/* TODO:\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\t\t\n\t\t// 1.) detect mimes\n\t\treturn nfcall(mime.detectMimesFromFile, absolutePath).then((detected: mime.IMimeAndEncoding) => {\n\t\t\tlet isText = detected.mimes.indexOf(baseMime.MIME_BINARY) === -1;\n\n\t\t\t// Return error early if client only accepts text and this is not text\n\t\t\tif (options && options.acceptTextOnly && !isText) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tmessage: nls.localize('fileBinaryError', \"File seems to be binary and cannot be opened as text\"),\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_IS_BINARY\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet preferredEncoding: string;\n\t\t\tif (options && options.encoding) {\n\t\t\t\tif (detected.encoding === encoding.UTF8 && options.encoding === encoding.UTF8) {\n\t\t\t\t\tpreferredEncoding = encoding.UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\n\t\t\t\t} else {\n\t\t\t\t\tpreferredEncoding = options.encoding; // give passed in encoding highest priority\n\t\t\t\t}\n\t\t\t} else if (detected.encoding) {\n\t\t\t\tif (detected.encoding === encoding.UTF8) {\n\t\t\t\t\tpreferredEncoding = encoding.UTF8_with_bom; // if we detected UTF-8, it can only be because of a BOM\n\t\t\t\t} else {\n\t\t\t\t\tpreferredEncoding = detected.encoding;\n\t\t\t\t}\n\t\t\t} else if (this.options.encoding === encoding.UTF8_with_bom) {\n\t\t\t\tpreferredEncoding = encoding.UTF8; // if we did not detect UTF 8 BOM before, this can only be UTF 8 then\n\t\t\t}\n\n\t\t\t// 2.) get content\n\t\t\treturn this.resolveFileContent(resource, options && options.etag, preferredEncoding).then((content) => {\n\n\t\t\t\t// set our knowledge about the mime on the content obj\n\t\t\t\tcontent.mime = detected.mimes.join(', ');\n\n\t\t\t\treturn content;\n\t\t\t});\n\t\t}, (error) => {\n\n\t\t\t// bubble up existing file operation results\n\t\t\tif (!types.isUndefinedOrNull((<files.IFileOperationResult>error).fileOperationResult)) {\n\t\t\t\treturn TPromise.wrapError(error);\n\t\t\t}\n\n\t\t\t// on error check if the file does not exist or is a folder and return with proper error result\n\t\t\treturn pfs.exists(absolutePath).then((exists) => {\n\n\t\t\t\t// Return if file not found\n\t\t\t\tif (!exists) {\n\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\tmessage: nls.localize('fileNotFoundError', \"File not found ({0})\", absolutePath),\n\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Otherwise check for file being a folder?\n\t\t\t\treturn pfs.stat(absolutePath).then((stat) => {\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\t\tmessage: nls.localize('fileIsDirectoryError', \"File is directory ({0})\", absolutePath),\n\t\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_IS_DIRECTORY\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// otherwise just give up\n\t\t\t\t\treturn TPromise.wrapError(error);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic resolveContents(resources: uri[]): TPromise<files.IContent[]> {\n\t\tlet limiter = new Limiter(FileService.MAX_DEGREE_OF_PARALLEL_FS_OPS);\n\n\t\tlet contentPromises = <TPromise<files.IContent>[]>[];\n\t\tresources.forEach((resource) => {\n\t\t\tcontentPromises.push(limiter.queue(() => this.resolveFileContent(resource).then((content) => content, (error) => TPromise.as(null /* ignore errors gracefully */))));\n\t\t});\n\n\t\treturn TPromise.join(contentPromises).then((contents) => {\n\t\t\treturn arrays.coalesce(contents);\n\t\t});\n\t}\n\n\tpublic updateContent(resource: uri, value: string, options: files.IUpdateContentOptions = Object.create(null)): TPromise<files.IFileStat> {\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) check file\n\t\treturn this.checkFile(absolutePath, options).then((exists) => {\n\t\t\tlet encodingToWrite = this.getEncoding(resource, options.encoding);\n\t\t\tlet addBomPromise: TPromise<boolean> = TPromise.as(false);\n\n\t\t\t// UTF_16 BE and LE as well as UTF_8 with BOM always have a BOM\n\t\t\tif (encodingToWrite === encoding.UTF16be || encodingToWrite === encoding.UTF16le || encodingToWrite === encoding.UTF8_with_bom) {\n\t\t\t\taddBomPromise = TPromise.as(true);\n\t\t\t}\n\n\t\t\t// Existing UTF-8 file: check for options regarding BOM\n\t\t\telse if (exists && encodingToWrite === encoding.UTF8) {\n\t\t\t\t/* TODO: Node-independent detectEncodingByBOM\n\t\t\t\tif (options.overwriteEncoding) {\n\t\t\t\t\taddBomPromise = TPromise.as(false); // if we are to overwrite the encoding, we do not preserve it if found\n\t\t\t\t} else {\n\t\t\t\t\taddBomPromise = nfcall(encoding.detectEncodingByBOM, absolutePath).then((enc) => enc === encoding.UTF8); // otherwise preserve it if found\n\t\t\t\t}*/\n\t\t\t\taddBomPromise = TPromise.as(false);\n\t\t\t}\n\n\t\t\t// 3.) check to add UTF BOM\n\t\t\treturn addBomPromise.then((addBom) => {\n\t\t\t\tlet writeFilePromise: TPromise<void>;\n\n\t\t\t\t// Write fast if we do UTF 8 without BOM\n\t\t\t\tif (!addBom && encodingToWrite === encoding.UTF8) {\n// TODO:\t\t\twriteFilePromise = pfs.writeFile(absolutePath, value, encoding.UTF8);\n\t\t\t\t\twriteFilePromise = new TPromise<void>((c, e) => {\n\t\t\t\t\t\tthis.repo.write(this.ref, resource.path.slice(1), value, 'Update ' + resource.path, { encode: true }, (err: GithubError) => {\n\t\t\t\t\t\t\terr ? e(err) : c(null);\n\t\t\t\t\t\t});\n\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}, (error: GithubError) => {\n\t\t\t\t\t\tconsole.log('failed to repo.write ' + resource.toString(true));\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Otherwise use encoding lib\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error('githubFileService.updateContent with non-UTF8 encoding not implemented yet');\n\t\t\t\t\t/* TODO:\n\t\t\t\t\tlet encoded = encoding.encode(value, encodingToWrite, { addBOM: addBom });\n\t\t\t\t\twriteFilePromise = pfs.writeFile(absolutePath, encoded);\n\t\t\t\t\t*/\n\t\t\t\t}\n\n\t\t\t\t// 4.) set contents\n\t\t\t\treturn writeFilePromise.then(() => {\n\n\t\t\t\t\t// 5.) resolve\n\t\t\t\t\treturn this.resolve(resource);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tpublic createFile(resource: uri, content: string = ''): TPromise<files.IFileStat> {\n\t\treturn this.updateContent(resource, content);\n\t}\n\n\tpublic createFolder(resource: uri): TPromise<files.IFileStat> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.createFolder not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\n\t\t/* TODO:\n\t\t// 1.) create folder\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\t\treturn pfs.mkdirp(absolutePath).then(() => {\n\n\t\t\t// 2.) resolve\n\t\t\treturn this.resolve(resource);\n\t\t});\n\t\t*/\n\t}\n\n\tpublic rename(resource: uri, newName: string): TPromise<files.IFileStat> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.rename not implemented (' + resource.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet newPath = paths.join(paths.dirname(resource.fsPath), newName);\n\n\t\treturn this.moveFile(resource, uri.file(newPath));\n\t\t*/\n\t}\n\n\tpublic moveFile(source: uri, target: uri, overwrite?: boolean): TPromise<files.IFileStat> {\n\t\treturn this.moveOrCopyFile(source, target, false, overwrite);\n\t}\n\n\tpublic copyFile(source: uri, target: uri, overwrite?: boolean): TPromise<files.IFileStat> {\n\t\treturn this.moveOrCopyFile(source, target, true, overwrite);\n\t}\n\n\tprivate moveOrCopyFile(source: uri, target: uri, keepCopy: boolean, overwrite: boolean): TPromise<files.IFileStat> {\n\t\tlet sourcePath = this.toAbsolutePath(source);\n\t\tlet targetPath = this.toAbsolutePath(target);\n\n\t\t// 1.) move / copy\n\t\treturn this.doMoveOrCopyFile(sourcePath, targetPath, keepCopy, overwrite).then(() => {\n\n\t\t\t// 2.) resolve\n\t\t\treturn this.resolve(target);\n\t\t});\n\t}\n\n\tprivate doMoveOrCopyFile(sourcePath: string, targetPath: string, keepCopy: boolean, overwrite: boolean): TPromise<boolean /* exists */> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.doMoveOrCopyFile not implemented (' + sourcePath + ' -> ' + targetPath + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\n\t\t/* TODO:\n\t\t// 1.) check if target exists\n\t\treturn pfs.exists(targetPath).then((exists) => {\n\t\t\tlet isCaseRename = sourcePath.toLowerCase() === targetPath.toLowerCase();\n\t\t\tlet isSameFile = sourcePath === targetPath;\n\n\t\t\t// Return early with conflict if target exists and we are not told to overwrite\n\t\t\tif (exists && !isCaseRename && !overwrite) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_MOVE_CONFLICT\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// 2.) make sure target is deleted before we move/copy unless this is a case rename of the same file\n\t\t\tlet deleteTargetPromise = TPromise.as(null);\n\t\t\tif (exists && !isCaseRename) {\n\t\t\t\tif (paths.isEqualOrParent(sourcePath, targetPath)) {\n\t\t\t\t\treturn TPromise.wrapError(nls.localize('unableToMoveCopyError', \"Unable to move/copy. File would replace folder it is contained in.\")); // catch this corner case!\n\t\t\t\t}\n\n\t\t\t\tdeleteTargetPromise = this.del(uri.file(targetPath));\n\t\t\t}\n\n\t\t\treturn deleteTargetPromise.then(() => {\n\n\t\t\t\t// 3.) make sure parents exists\n\t\t\t\treturn pfs.mkdirp(paths.dirname(targetPath)).then(() => {\n\n\t\t\t\t\t// 4.) copy/move\n\t\t\t\t\tif (isSameFile) {\n\t\t\t\t\t\treturn TPromise.as(null);\n\t\t\t\t\t} else if (keepCopy) {\n\t\t\t\t\t\treturn nfcall(extfs.copy, sourcePath, targetPath);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn nfcall(extfs.mv, sourcePath, targetPath);\n\t\t\t\t\t}\n\t\t\t\t}).then(() => exists);\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic importFile(source: uri, targetFolder: uri): TPromise<files.IImportResult> {\n\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\tmessage: 'githubFileService.importFile not implemented (' + source.toString(true) + ')',\n\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_FOUND\n\t\t});\n\t\t/* TODO:\n\t\tlet sourcePath = this.toAbsolutePath(source);\n\t\tlet targetResource = uri.file(paths.join(targetFolder.fsPath, paths.basename(source.fsPath)));\n\t\tlet targetPath = this.toAbsolutePath(targetResource);\n\n\t\t// 1.) resolve\n\t\treturn pfs.stat(sourcePath).then((stat) => {\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\treturn TPromise.wrapError(nls.localize('foldersCopyError', \"Folders cannot be copied into the workspace. Please select individual files to copy them.\")); // for now we do not allow to import a folder into a workspace\n\t\t\t}\n\n\t\t\t// 2.) copy\n\t\t\treturn this.doMoveOrCopyFile(sourcePath, targetPath, true, true).then((exists) => {\n\n\t\t\t\t// 3.) resolve\n\t\t\t\treturn this.resolve(targetResource).then((stat) => <files.IImportResult>{ isNew: !exists, stat: stat });\n\t\t\t});\n\t\t});\n\t\t*/\n\t}\n\n\tpublic del(resource: uri): TPromise<void> {\n\t\tconsole.log('githubFileService.del not implemented (' + resource.toString(true) + ')');\n\t\treturn TPromise.as<void>(null);\n\t\t/* TODO:\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\treturn nfcall(extfs.del, absolutePath, this.tmpPath);\n\t\t*/\n\t}\n\n\t// Helpers\n\n\tprivate toAbsolutePath(arg1: uri | files.IFileStat): string {\n\t\tlet resource: uri;\n\t\tif (arg1 instanceof uri) {\n\t\t\tresource = <uri>arg1;\n\t\t} else {\n\t\t\tresource = (<files.IFileStat>arg1).resource;\n\t\t}\n\n\t\treturn paths.normalize(resource.fsPath);\n\t}\n\t\n\t// TODO: options\n\tprivate resolve(resource: uri, options: files.IResolveFileOptions = Object.create(null)): TPromise<files.IFileStat> {\n\t\tconsole.log('resolve ' + resource.toString(true));\n\t\treturn new TPromise<files.IFileStat>((c, e) => {\n\t\t\t// TODO: This API has an upper limit of 1,000 files per directory.\n\t\t\t// TODO: This API only supports files up to 1 MB in size. So use,\n\t\t\t//\t\thttps://raw.githubusercontent.com/:owner/:repo/master/:path\n\t\t\t//\t\tor download_url of directory entry\n\t\t\t//\t\tor curl -H 'Authorization: token INSERTACCESSTOKENHERE' -H 'Accept: application/vnd.github.v3.raw' -O -L https://api.github.com/repos/owner/repo/contents/path\n\t\t\t// TODO: GET /repos/:owner/:repo/git/trees/:sha for directories\n\t\t\tthis.repo.contents(this.ref, resource.path.slice(1), (err: GithubError, contents?: any) => {\n\t\t\t\terr ? e(err) : c(contents);\n\t\t\t});\n\t\t}).then((contents: any) => {\n\t\t\tif (!Array.isArray(contents)) {\n\t\t\t\t// TODO: switch on contents.type (file | symlink | submodule)\n\t\t\t\treturn {\n\t\t\t\t\tresource: uri.file(contents.path),\n\t\t\t\t\tisDirectory: false,\n\t\t\t\t\thasChildren: false,\n\t\t\t\t\tname: contents.name,\n\t\t\t\t\tmtime: contents.updated_at, // TODO:\n\t\t\t\t\tetag: contents.sha,\n\t\t\t\t\tsize: contents.size,\n\t\t\t\t\tmime: baseMime.guessMimeTypes(contents.name).join(', '),\n\t\t\t\t\tcontent: contents.content\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// TODO: recurse subdirs\n\t\t\tvar stats: files.IFileStat[] = [];\n\t\t\tfor (var i = 0; i < contents.length; i++) {\n\t\t\t\tlet content = contents[i];\n\t\t\t\tstats.push({\n\t\t\t\t\tresource: uri.file(content.path),\n\t\t\t\t\tisDirectory: content.type == \"dir\", // TODO: symlink, submodule\n\t\t\t\t\thasChildren: content.type == \"dir\",\n\t\t\t\t\tname: content.name,\n\t\t\t\t\tmtime: content.updated_at, // TODO:\n\t\t\t\t\tetag: content.sha,\n\t\t\t\t\tsize: content.size,\n\t\t\t\t\tmime: baseMime.guessMimeTypes(content.name).join(', ')\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tresource: resource,\n\t\t\t\tisDirectory: true,\n\t\t\t\thasChildren: true,\n\t\t\t\tname: resource.path, // TODO:\n\t\t\t\tmtime: 0, // TODO:\n\t\t\t\tetag: '', // TODO: etag(fileStat),\n\t\t\t\tchildren: stats,\n\t\t\t\tmime: undefined\n\t\t\t}\n\t\t}, (error: GithubError) => {\n\t\t\tconsole.log('unable to repo.contents ' + resource.toString(true));\n\t\t});\n\t}\n\t\n\tprivate resolveFileContent(resource: uri, etag?: string, enc?: string): TPromise<files.IContent> {\n\t\tlet absolutePath = this.toAbsolutePath(resource);\n\n\t\t// 1.) stat\n\t\treturn this.resolve(resource).then((model) => {\n\n\t\t\t// Return early if file not modified since\n\t\t\tif (etag && etag === model.etag) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_NOT_MODIFIED_SINCE\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Return early if file is too large to load\n\t\t\tif (types.isNumber(model.size) && model.size > files.MAX_FILE_SIZE) {\n\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_TOO_LARGE\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// 2.) read contents\n\t\t\treturn new TPromise<files.IContent>((c, e) => {\n\t\t\t\tvar content: files.IContent = {\n\t\t\t\t\tresource: model.resource,\n\t\t\t\t\tname: model.name,\n\t\t\t\t\tmtime: model.mtime,\n\t\t\t\t\tetag: model.etag,\n\t\t\t\t\tmime: model.mime,\n\t\t\t\t\tvalue: atob((<any>model).content),\n\t\t\t\t\tencoding: encoding.UTF8 // TODO:\n\t\t\t\t}\n\t\t\t\tc(content);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate getEncoding(resource: uri, preferredEncoding?: string): string {\n\t\tlet fileEncoding: string;\n\n\t\tlet override = this.getEncodingOverride(resource);\n\t\tif (override) {\n\t\t\tfileEncoding = override;\n\t\t} else if (preferredEncoding) {\n\t\t\tfileEncoding = preferredEncoding;\n\t\t} else {\n\t\t\tfileEncoding = this.options.encoding;\n\t\t}\n\n\t\t/* TODO:\n\t\tif (!fileEncoding || !encoding.encodingExists(fileEncoding)) {\n\t\t\tfileEncoding = encoding.UTF8; // the default is UTF 8\n\t\t}\n\t\t*/\n\n\t\treturn fileEncoding;\n\t}\n\n\tprivate getEncodingOverride(resource: uri): string {\n\t\tif (resource && this.options.encodingOverride && this.options.encodingOverride.length) {\n\t\t\tfor (let i = 0; i < this.options.encodingOverride.length; i++) {\n\t\t\t\tlet override = this.options.encodingOverride[i];\n\n\t\t\t\t// check if the resource is a child of the resource with override and use\n\t\t\t\t// the provided encoding in that case\n\t\t\t\tif (resource.toString().indexOf(override.resource.toString() + '/') === 0) {\n\t\t\t\t\treturn override.encoding;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate checkFile(absolutePath: string, options: files.IUpdateContentOptions): TPromise<boolean /* exists */> {\n\t\treturn TPromise.as(true);\n\t\t\n\t\t/* TODO: full implementation\n\t\treturn pfs.exists(absolutePath).then((exists) => {\n\t\t\tif (exists) {\n\t\t\t\treturn pfs.stat(absolutePath).then((stat: fs.Stats) => {\n\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\treturn TPromise.wrapError(new Error('Expected file is actually a directory'));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Dirty write prevention\n\t\t\t\t\tif (typeof options.mtime === 'number' && typeof options.etag === 'string' && options.mtime < stat.mtime.getTime()) {\n\n\t\t\t\t\t\t// Find out if content length has changed\n\t\t\t\t\t\tif (options.etag !== etag(stat.size, options.mtime)) {\n\t\t\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\t\t\tmessage: 'File Modified Since',\n\t\t\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_MODIFIED_SINCE\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet mode = stat.mode;\n\t\t\t\t\tlet readonly = !(mode & 128);\n\n\t\t\t\t\t// Throw if file is readonly and we are not instructed to overwrite\n\t\t\t\t\tif (readonly && !options.overwriteReadonly) {\n\t\t\t\t\t\treturn TPromise.wrapError(<files.IFileOperationResult>{\n\t\t\t\t\t\t\tmessage: nls.localize('fileReadOnlyError', \"File is Read Only\"),\n\t\t\t\t\t\t\tfileOperationResult: files.FileOperationResult.FILE_READ_ONLY\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (readonly) {\n\t\t\t\t\t\tmode = mode | 128;\n\t\t\t\t\t\treturn pfs.chmod(absolutePath, mode).then(() => exists);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn TPromise.as<boolean>(exists);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn TPromise.as<boolean>(exists);\n\t\t});\n\t\t*/\n\t}\n\n\tpublic watchFileChanges(resource: uri): void {\n\t\tconsole.log('githubFileService.watchFileChanges not implemented (' + resource.toString(true) + ')');\n\t\t/* TODO:\n\t\tassert.ok(resource && resource.scheme === 'file', 'Invalid resource for watching: ' + resource);\n\n\t\tlet fsPath = resource.fsPath;\n\n\t\t// Create or get watcher for provided path\n\t\tlet watcher = this.activeFileChangesWatchers[resource.toString()];\n\t\tif (!watcher) {\n\t\t\ttry {\n\t\t\t\twatcher = fs.watch(fsPath); // will be persistent but not recursive\n\t\t\t} catch (error) {\n\t\t\t\t// the path might not exist anymore, ignore this error and return\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.activeFileChangesWatchers[resource.toString()] = watcher;\n\n\t\t\t// eventType is either 'rename' or 'change'\n\t\t\twatcher.on('change', (eventType: string) => {\n\t\t\t\tif (eventType !== 'change') {\n\t\t\t\t\treturn; // only care about changes for now ('rename' is not reliable and can be send even if the file is still there with some tools)\n\t\t\t\t}\n\n\t\t\t\t// add to bucket of undelivered events\n\t\t\t\tthis.undeliveredRawFileChangesEvents.push({\n\t\t\t\t\ttype: files.FileChangeType.UPDATED,\n\t\t\t\t\tpath: fsPath\n\t\t\t\t});\n\n\t\t\t\t// handle emit through delayer to accommodate for bulk changes\n\t\t\t\tthis.fileChangesWatchDelayer.trigger(() => {\n\t\t\t\t\tlet buffer = this.undeliveredRawFileChangesEvents;\n\t\t\t\t\tthis.undeliveredRawFileChangesEvents = [];\n\n\t\t\t\t\t// Normalize\n\t\t\t\t\tlet normalizedEvents = normalize(buffer);\n\n\t\t\t\t\t// Emit\n\t\t\t\t\tthis.eventEmitter.emit(files.EventType.FILE_CHANGES, toFileChangesEvent(normalizedEvents));\n\n\t\t\t\t\treturn TPromise.as(null);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t*/\n\t}\n\n\tpublic unwatchFileChanges(resource: uri): void;\n\tpublic unwatchFileChanges(path: string): void;\n\tpublic unwatchFileChanges(arg1: any): void {\n\t\tlet resource = (typeof arg1 === 'string') ? uri.parse(arg1) : arg1;\n\t\tconsole.log('githubFileService.unwatchFileChanges not implemented (' + resource + ')');\n\t\t\n\t\t/* TODO:\n\t\tlet watcher = this.activeFileChangesWatchers[resource.toString()];\n\t\tif (watcher) {\n\t\t\twatcher.close();\n\t\t\tdelete this.activeFileChangesWatchers[resource.toString()];\n\t\t}\n\t\t*/\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.workspaceWatcherToDispose) {\n\t\t\tthis.workspaceWatcherToDispose();\n\t\t\tthis.workspaceWatcherToDispose = null;\n\t\t}\n\n\t\t/* TODO:\n\t\tfor (let key in this.activeFileChangesWatchers) {\n\t\t\tlet watcher = this.activeFileChangesWatchers[key];\n\t\t\twatcher.close();\n\t\t}\n\t\tthis.activeFileChangesWatchers = Object.create(null);\n\t\t*/\n\t}\n}\n\n/*\nexport class StatResolver {\n\tprivate resource: uri;\n\tprivate isDirectory: boolean;\n\tprivate mtime: number;\n\tprivate name: string;\n\tprivate mime: string;\n\tprivate etag: string;\n\tprivate size: number;\n\tprivate verboseLogging: boolean;\n\n\tconstructor(resource: uri, isDirectory: boolean, mtime: number, size: number, verboseLogging: boolean) {\n\t\t// TODO: assert.ok(resource && resource.scheme === 'file', 'Invalid resource: ' + resource);\n\n\t\tthis.resource = resource;\n\t\tthis.isDirectory = isDirectory;\n\t\tthis.mtime = mtime;\n\t\tthis.name = paths.basename(resource.fsPath);\n\t\tthis.mime = !this.isDirectory ? baseMime.guessMimeTypes(resource.fsPath).join(', ') : null;\n\t\tthis.etag = etag(size, mtime);\n\t\tthis.size = size;\n\n\t\tthis.verboseLogging = verboseLogging;\n\t}\n\n\tpublic resolve(options: files.IResolveFileOptions): TPromise<files.IFileStat> {\n\n\t\t// General Data\n\t\tlet fileStat: files.IFileStat = {\n\t\t\tresource: this.resource,\n\t\t\tisDirectory: this.isDirectory,\n\t\t\thasChildren: undefined,\n\t\t\tname: this.name,\n\t\t\tetag: this.etag,\n\t\t\tsize: this.size,\n\t\t\tmtime: this.mtime,\n\t\t\tmime: this.mime\n\t\t};\n\n\t\t// File Specific Data\n\t\tif (!this.isDirectory) {\n\t\t\treturn TPromise.as(fileStat);\n\t\t}\n\n\t\t// Directory Specific Data\n\t\telse {\n\n\t\t\t// Convert the paths from options.resolveTo to absolute paths\n\t\t\tlet absoluteTargetPaths: string[] = null;\n\t\t\tif (options && options.resolveTo) {\n\t\t\t\tabsoluteTargetPaths = [];\n\t\t\t\toptions.resolveTo.forEach((resource) => {\n\t\t\t\t\tabsoluteTargetPaths.push(resource.fsPath);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new TPromise((c, e) => {\n\n\t\t\t\t// Load children\n\t\t\t\tthis.resolveChildren(this.resource.fsPath, absoluteTargetPaths, options && options.resolveSingleChildDescendants, (children) => {\n\t\t\t\t\tchildren = arrays.coalesce(children); // we don't want those null children (could be permission denied when reading a child)\n\t\t\t\t\tfileStat.hasChildren = children && children.length > 0;\n\t\t\t\t\tfileStat.children = children || [];\n\n\t\t\t\t\tc(fileStat);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate resolveChildren(absolutePath: string, absoluteTargetPaths: string[], resolveSingleChildDescendants: boolean, callback: (children: files.IFileStat[]) => void): void {\n\t\tconsole.log('githubFileService.resolveChildren not implemented (' + absolutePath + ')');\n\t\t\n\t\textfs.readdir(absolutePath, (error: Error, files: string[]) => {\n\t\t\tif (error) {\n\t\t\t\tif (this.verboseLogging) {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\n\t\t\t\treturn callback(null); // return - we might not have permissions to read the folder\n\t\t\t}\n\n\t\t\t// for each file in the folder\n\t\t\tflow.parallel(files, (file: string, clb: (error: Error, children: files.IFileStat) => void) => {\n\t\t\t\tlet fileResource = uri.file(paths.resolve(absolutePath, file));\n\t\t\t\tlet fileStat: fs.Stats;\n\t\t\t\tlet $this = this;\n\n\t\t\t\tflow.sequence(\n\t\t\t\t\tfunction onError(error: Error): void {\n\t\t\t\t\t\tif ($this.verboseLogging) {\n\t\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclb(null, null); // return - we might not have permissions to read the folder or stat the file\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction stat(): void {\n\t\t\t\t\t\tfs.stat(fileResource.fsPath, this);\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction countChildren(fsstat: fs.Stats): void {\n\t\t\t\t\t\tfileStat = fsstat;\n\n\t\t\t\t\t\tif (fileStat.isDirectory()) {\n\t\t\t\t\t\t\textfs.readdir(fileResource.fsPath, (error, result) => {\n\t\t\t\t\t\t\t\tthis(null, result ? result.length : 0);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis(null, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tfunction resolve(childCount: number): void {\n\t\t\t\t\t\tlet childStat: files.IFileStat = {\n\t\t\t\t\t\t\tresource: fileResource,\n\t\t\t\t\t\t\tisDirectory: fileStat.isDirectory(),\n\t\t\t\t\t\t\thasChildren: childCount > 0,\n\t\t\t\t\t\t\tname: file,\n\t\t\t\t\t\t\tmtime: fileStat.mtime.getTime(),\n\t\t\t\t\t\t\tetag: etag(fileStat),\n\t\t\t\t\t\t\tsize: fileStat.size,\n\t\t\t\t\t\t\tmime: !fileStat.isDirectory() ? baseMime.guessMimeTypes(fileResource.fsPath).join(', ') : undefined\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Return early for files\n\t\t\t\t\t\tif (!fileStat.isDirectory()) {\n\t\t\t\t\t\t\treturn clb(null, childStat);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle Folder\n\t\t\t\t\t\tlet resolveFolderChildren = false;\n\t\t\t\t\t\tif (files.length === 1 && resolveSingleChildDescendants) {\n\t\t\t\t\t\t\tresolveFolderChildren = true;\n\t\t\t\t\t\t} else if (childCount > 0 && absoluteTargetPaths && absoluteTargetPaths.some((targetPath) => paths.isEqualOrParent(targetPath, fileResource.fsPath))) {\n\t\t\t\t\t\t\tresolveFolderChildren = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Continue resolving children based on condition\n\t\t\t\t\t\tif (resolveFolderChildren) {\n\t\t\t\t\t\t\t$this.resolveChildren(fileResource.fsPath, absoluteTargetPaths, resolveSingleChildDescendants, (children) => {\n\t\t\t\t\t\t\t\tchildren = arrays.coalesce(children);  // we don't want those null children\n\t\t\t\t\t\t\t\tchildStat.hasChildren = children && children.length > 0;\n\t\t\t\t\t\t\t\tchildStat.children = children || [];\n\n\t\t\t\t\t\t\t\tclb(null, childStat);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise return result\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tclb(null, childStat);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}, (errors, result) => {\n\t\t\t\tcallback(result);\n\t\t\t});\n\t\t});\n\t}\n}\n*/"]}