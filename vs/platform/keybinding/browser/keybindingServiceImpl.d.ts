import 'vs/css!./keybindings';
import { IHTMLContentElement } from 'vs/base/common/htmlContent';
import { Keybinding } from 'vs/base/common/keyCodes';
import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
import { ICommandService, ICommandHandler } from 'vs/platform/commands/common/commands';
import { IKeybindingContextKey, IKeybindingItem, IKeybindingScopeLocation, IKeybindingService, KbExpr } from 'vs/platform/keybinding/common/keybinding';
import { IStatusbarService } from 'vs/platform/statusbar/common/statusbar';
import { IMessageService } from 'vs/platform/message/common/message';
import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
import Event, { Emitter } from 'vs/base/common/event';
export declare class KeybindingContext {
    protected _parent: KeybindingContext;
    protected _value: any;
    protected _id: number;
    constructor(id: number, parent: KeybindingContext);
    setValue(key: string, value: any): boolean;
    removeValue(key: string): boolean;
    getValue<T>(key: string): T;
    fillInContext(bucket: any): void;
}
export declare abstract class AbstractKeybindingService {
    _serviceBrand: any;
    protected _onDidChangeContext: Event<string[]>;
    protected _onDidChangeContextKey: Emitter<string>;
    protected _myContextId: number;
    protected _instantiationService: IInstantiationService;
    constructor(myContextId: number);
    createKey<T>(key: string, defaultValue: T): IKeybindingContextKey<T>;
    onDidChangeContext: Event<string[]>;
    setInstantiationService(instantiationService: IInstantiationService): void;
    createScoped(domNode: IKeybindingScopeLocation): IKeybindingService;
    contextMatchesRules(rules: KbExpr): boolean;
    getContextValue<T>(key: string): T;
    setContext(key: string, value: any): void;
    removeContext(key: string): void;
    abstract getLabelFor(keybinding: Keybinding): string;
    abstract getHTMLLabelFor(keybinding: Keybinding): IHTMLContentElement[];
    abstract getAriaLabelFor(keybinding: Keybinding): string;
    abstract getElectronAcceleratorFor(keybinding: Keybinding): string;
    abstract customKeybindingsCount(): number;
    abstract getContext(contextId: number): KeybindingContext;
    abstract createChildContext(parentContextId?: number): number;
    abstract disposeContext(contextId: number): void;
    abstract getDefaultKeybindings(): string;
    abstract lookupKeybindings(commandId: string): Keybinding[];
}
export declare abstract class KeybindingService extends AbstractKeybindingService implements IKeybindingService {
    private _lastContextId;
    private _contexts;
    private _toDispose;
    private _cachedResolver;
    private _firstTimeComputingResolver;
    private _currentChord;
    private _currentChordStatusMessage;
    private _commandService;
    private _statusService;
    private _messageService;
    constructor(commandService: ICommandService, configurationService: IConfigurationService, messageService: IMessageService, statusService?: IStatusbarService);
    protected _beginListening(domNode: HTMLElement): void;
    private _getResolver();
    dispose(): void;
    getLabelFor(keybinding: Keybinding): string;
    getHTMLLabelFor(keybinding: Keybinding): IHTMLContentElement[];
    getAriaLabelFor(keybinding: Keybinding): string;
    getElectronAcceleratorFor(keybinding: Keybinding): string;
    protected updateResolver(): void;
    protected _getExtraKeybindings(isFirstTime: boolean): IKeybindingItem[];
    getDefaultKeybindings(): string;
    customKeybindingsCount(): number;
    lookupKeybindings(commandId: string): Keybinding[];
    private _getAllCommandsAsComment();
    protected _getCommandHandler(commandId: string): ICommandHandler;
    private _dispatch(e);
    private _findContextAttr(domNode);
    getContext(contextId: number): KeybindingContext;
    createChildContext(parentContextId?: number): number;
    disposeContext(contextId: number): void;
}
