{"version":3,"file":"vs/base/node/stdFork.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/base/node/stdFork.ts"],"names":[],"mappings":"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","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport path = require('path');\nimport os = require('os');\nimport net = require('net');\nimport cp = require('child_process');\nimport uri from 'vs/base/common/uri';\n\nexport interface IForkOpts {\n\tcwd?: string;\n\tenv?: any;\n\tencoding?: string;\n\texecArgv?: string[];\n}\n\nfunction makeRandomHexString(length:number): string {\n\tlet chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\tlet result = '';\n\tfor (let i = 0; i < length; i++) {\n\t\tlet idx = Math.floor(chars.length * Math.random());\n\t\tresult += chars[idx];\n\t}\n\treturn result;\n}\n\nfunction generatePipeName(): string {\n\tlet randomName = 'vscode-' + makeRandomHexString(40);\n\tif (process.platform === 'win32') {\n\t\treturn '\\\\\\\\.\\\\pipe\\\\' + randomName + '-sock';\n\t}\n\n\t// Mac/Unix: use socket file\n\treturn path.join(os.tmpdir(), randomName + '.sock');\n}\n\nfunction generatePatchedEnv(env:any, stdInPipeName:string, stdOutPipeName:string, stdErrPipeName:string): any {\n\t// Set the two unique pipe names and the electron flag as process env\n\n\tlet newEnv:any = {};\n\tfor (let key in env) {\n\t\tnewEnv[key] = env[key];\n\t}\n\n\tnewEnv['STDIN_PIPE_NAME'] = stdInPipeName;\n\tnewEnv['STDOUT_PIPE_NAME'] = stdOutPipeName;\n\tnewEnv['STDERR_PIPE_NAME'] = stdErrPipeName;\n\tnewEnv['ATOM_SHELL_INTERNAL_RUN_AS_NODE'] = '1';\n\n\treturn newEnv;\n}\n\nexport function fork(modulePath: string, args: string[], options: IForkOpts, callback:(error:any, cp:cp.ChildProcess)=>void): void {\n\n\tlet callbackCalled = false;\n\tlet resolve = (result: cp.ChildProcess) => {\n\t\tif (callbackCalled) {\n\t\t\treturn;\n\t\t}\n\t\tcallbackCalled = true;\n\t\tcallback(null, result);\n\t};\n\tlet reject = (err:any) => {\n\t\tif (callbackCalled) {\n\t\t\treturn;\n\t\t}\n\t\tcallbackCalled = true;\n\t\tcallback(err, null);\n\t};\n\n\t// Generate three unique pipe names\n\tlet stdInPipeName = generatePipeName();\n\tlet stdOutPipeName = generatePipeName();\n\tlet stdErrPipeName = generatePipeName();\n\n\tlet newEnv = generatePatchedEnv(options.env || process.env, stdInPipeName, stdOutPipeName, stdErrPipeName);\n\n\tlet childProcess: cp.ChildProcess;\n\n\t// Begin listening to stderr pipe\n\tlet stdErrServer = net.createServer((stdErrStream) => {\n\t\t// From now on the childProcess.stderr is available for reading\n\t\tchildProcess.stderr = stdErrStream;\n\t});\n\tstdErrServer.listen(stdErrPipeName);\n\n\t// Begin listening to stdout pipe\n\tlet stdOutServer = net.createServer((stdOutStream) => {\n\t\t// The child process will write exactly one chunk with content `ready` when it has installed a listener to the stdin pipe\n\n\t\tstdOutStream.once('data', (chunk:Buffer) => {\n\t\t\t// The child process is sending me the `ready` chunk, time to connect to the stdin pipe\n\t\t\tchildProcess.stdin = <any>net.connect(stdInPipeName);\n\n\t\t\t// From now on the childProcess.stdout is available for reading\n\t\t\tchildProcess.stdout = stdOutStream;\n\n\t\t\tresolve(childProcess);\n\t\t});\n\t});\n\tstdOutServer.listen(stdOutPipeName);\n\n\tlet serverClosed = false;\n\tlet closeServer = () => {\n\t\tif (serverClosed) {\n\t\t\treturn;\n\t\t}\n\t\tserverClosed = true;\n\t\tstdOutServer.close();\n\t\tstdErrServer.close();\n\t};\n\n\t// Create the process\n\tlet bootstrapperPath = (uri.parse(require.toUrl('./stdForkStart.js')).fsPath);\n\tchildProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {\n\t\tsilent: true,\n\t\tcwd: options.cwd,\n\t\tenv: newEnv,\n\t\texecArgv: options.execArgv\n\t});\n\n\tchildProcess.once('error', (err:Error) => {\n\t\tcloseServer();\n\t\treject(err);\n\t});\n\n\tchildProcess.once('exit', (err:Error) => {\n\t\tcloseServer();\n\t\treject(err);\n\t});\n}"]}