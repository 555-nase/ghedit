{"version":3,"file":"vs/workbench/parts/debug/common/debug.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sources":["vs/workbench/parts/debug/common/debug.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;IAanF,kBAAU,GAAG,sBAAsB,CAAC;IACpC,eAAO,GAAG,sBAAsB,CAAC;IACjC,wBAAgB,GAAG,cAAc,CAAC;IAClC,6BAAqB,GAAG,aAAa,CAAC;IACtC,8BAAsB,GAAG,sBAAsB,CAAC;IAmH7D,SAAS;IAEE,mBAAW,GAAG;QACxB,mBAAmB,EAAE,oBAAoB;QACzC,iBAAiB,EAAE,kBAAkB;QACrC,yBAAyB,EAAE,yBAAyB;QACpD,qBAAqB,EAAE,qBAAqB;KAC5C,CAAC;IAES,uBAAe,GAAG;QAC5B,2BAA2B,EAAE,0BAA0B;QACvD,2BAA2B,EAAE,2BAA2B;QACxD,oCAAoC,EAAE,mCAAmC;KACzE,CAAC;IAES,qBAAa,GAAG;QAC1B,aAAa,EAAE,cAAc;QAC7B,kBAAkB,EAAE,kBAAkB;QACtC,qBAAqB,EAAE,sBAAsB;KAC7C,CAAC;IAES,qBAAa,GAAG;QAC1B,WAAW,EAAE,aAAa;QAC1B,OAAO,EAAE,SAAS;QAClB,kBAAkB,EAAE,YAAY;QAChC,WAAW,EAAE,MAAM;QACnB,SAAS,EAAE,WAAW;QACtB,MAAM,EAAE,QAAQ;QAChB,MAAM,EAAE,QAAQ;QAChB,UAAU,EAAE,YAAY;KACxB,CAAC;IAuBF,gBAAgB;IAEhB,WAAY,KAAK;QAChB,yCAAQ,CAAA;QACR,yCAAQ,CAAA;QACR,iDAAY,CAAA;QACZ,uCAAO,CAAA;QACP,uCAAO,CAAA;QACP,qDAAc,CAAA;IACf,CAAC,EAPW,aAAK,KAAL,aAAK,QAOhB;IAPD,IAAY,KAAK,GAAL,aAOX,CAAA;IAsEU,qBAAa,GAAG,+BAAe,CAAgB,wBAAgB,CAAC,CAAC;IA8F5E;QAGC;YACC,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;QACtB,CAAC;QAEM,iDAAiB,GAAxB,UAAyB,IAAoC,EAAE,KAAa;YAC3E,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,MAAA,IAAI,EAAE,OAAA,KAAK,EAAE,CAAC,CAAC;QACvC,CAAC;QAEM,6CAAa,GAApB;YACC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,UAAC,KAAK,EAAE,MAAM,IAAK,OAAA,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,EAA1B,CAA0B,CAAC;iBACxE,GAAG,CAAC,UAAA,aAAa,IAAI,OAAA,aAAa,CAAC,IAAI,EAAlB,CAAkB,CAAC,CAAC;QAC5C,CAAC;QACF,4BAAC;IAAD,CAAC,AAfD,IAeC;IAEU,yBAAiB,GAAuB,IAAI,qBAAqB,EAAE,CAAC;IAE/E,QAAQ;IAER,IAAM,gBAAgB,GAAG,YAAY,CAAC;IAEtC,mBAA0B,KAAY,EAAE,UAAmB,EAAE,IAA6B;QACzF,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,gBAAgB,EAAE,UAAS,KAAK,EAAE,KAAK;YAC3D,EAAE,CAAC,CAAC,UAAU,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;gBACxD,MAAM,CAAC,KAAK,CAAC;YACd,CAAC;YAED,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC;gBACxC,IAAI,CAAC,KAAK,CAAC;gBACX,KAAK,CAAC;QACR,CAAC,CAAC,CAAC;IACJ,CAAC;IAVe,iBAAS,YAUxB,CAAA","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport uri from 'vs/base/common/uri';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport { IActionRunner } from 'vs/base/common/actions';\nimport ee = require('vs/base/common/eventEmitter');\nimport severity from 'vs/base/common/severity';\nimport { IViewletView } from 'vs/workbench/browser/viewlet';\nimport { createDecorator, ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';\nimport editor = require('vs/editor/common/editorCommon');\nimport editorbrowser = require('vs/editor/browser/editorBrowser');\nimport { Source } from 'vs/workbench/parts/debug/common/debugSource';\n\nexport const VIEWLET_ID = 'workbench.view.debug';\nexport const REPL_ID = 'workbench.panel.repl';\nexport const DEBUG_SERVICE_ID = 'debugService';\nexport const CONTEXT_IN_DEBUG_MODE = 'inDebugMode';\nexport const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';\n\n// raw\n\nexport interface IRawModelUpdate {\n\tthreadId: number;\n\tthread?: DebugProtocol.Thread;\n\tcallStack?: DebugProtocol.StackFrame[];\n\tstoppedDetails?: IRawStoppedDetails;\n\tallThreadsStopped?: boolean;\n}\n\nexport interface IRawStoppedDetails {\n\treason: string;\n\tthreadId?: number;\n\ttext?: string;\n\ttotalFrames?: number;\n}\n\n// model\n\nexport interface ITreeElement {\n\tgetId(): string;\n}\n\nexport interface IExpressionContainer extends ITreeElement {\n\treference: number;\n\tgetChildren(debugService: IDebugService): TPromise<IExpression[]>;\n}\n\nexport interface IExpression extends ITreeElement, IExpressionContainer {\n\tname: string;\n\tvalue: string;\n\tvalueChanged: boolean;\n}\n\nexport interface IThread extends ITreeElement {\n\tthreadId: number;\n\tname: string;\n\tstoppedDetails: IRawStoppedDetails;\n\n\t/**\n\t * Queries the debug adapter for the callstack and returns a promise with\n\t * the stack frames of the callstack.\n\t * If the thread is not stopped, it returns a promise to an empty array.\n\t * Only gets the first 20 stack frames. Calling this method consecutive times\n\t * with getAdditionalStackFrames = true gets the remainder of the call stack.\n\t */\n\tgetCallStack(debugService: IDebugService, getAdditionalStackFrames?: boolean): TPromise<IStackFrame[]>;\n\n\t/**\n\t * Gets the callstack if it has already been received from the debug\n\t * adapter, otherwise it returns undefined.\n\t */\n\tgetCachedCallStack(): IStackFrame[];\n\n\t/**\n\t * Invalidates the callstack cache\n\t */\n\tclearCallStack(): void;\n\n\t/**\n\t * Indicates whether this thread is stopped. The callstack for stopped\n\t * threads can be retrieved from the debug adapter.\n\t */\n\tstopped: boolean;\n}\n\nexport interface IScope extends IExpressionContainer {\n\tname: string;\n\texpensive: boolean;\n}\n\nexport interface IStackFrame extends ITreeElement {\n\tthreadId: number;\n\tname: string;\n\tlineNumber: number;\n\tcolumn: number;\n\tframeId: number;\n\tsource: Source;\n\tgetScopes(debugService: IDebugService): TPromise<IScope[]>;\n}\n\nexport interface IEnablement extends ITreeElement {\n\tenabled: boolean;\n}\n\nexport interface IRawBreakpoint {\n\turi: uri;\n\tlineNumber: number;\n\tenabled: boolean;\n\tcondition?: string;\n}\n\nexport interface IBreakpoint extends IEnablement {\n\tsource: Source;\n\tlineNumber: number;\n\tdesiredLineNumber: number;\n\tcondition: string;\n\tverified: boolean;\n\tidFromAdapter: number;\n\tmessage: string;\n}\n\nexport interface IFunctionBreakpoint extends IEnablement {\n\tname: string;\n\tverified: boolean;\n\tidFromAdapter: number;\n}\n\nexport interface IExceptionBreakpoint extends IEnablement {\n\tfilter: string;\n\tlabel: string;\n}\n\n// events\n\nexport var ModelEvents = {\n\tBREAKPOINTS_UPDATED: 'BreakpointsUpdated',\n\tCALLSTACK_UPDATED: 'CallStackUpdated',\n\tWATCH_EXPRESSIONS_UPDATED: 'WatchExpressionsUpdated',\n\tREPL_ELEMENTS_UPDATED: 'ReplElementsUpdated'\n};\n\nexport var ViewModelEvents = {\n\tFOCUSED_STACK_FRAME_UPDATED: 'FocusedStackFrameUpdated',\n\tSELECTED_EXPRESSION_UPDATED: 'SelectedExpressionUpdated',\n\tSELECTED_FUNCTION_BREAKPOINT_UPDATED: 'SelectedFunctionBreakpointUpdated'\n};\n\nexport var ServiceEvents = {\n\tSTATE_CHANGED: 'StateChanged',\n\tTYPE_NOT_SUPPORTED: 'TypeNotSupported',\n\tCONFIGURATION_CHANGED: 'ConfigurationChanged'\n};\n\nexport var SessionEvents = {\n\tINITIALIZED: 'initialized',\n\tSTOPPED: 'stopped',\n\tDEBUGEE_TERMINATED: 'terminated',\n\tSERVER_EXIT: 'exit',\n\tCONTINUED: 'continued',\n\tTHREAD: 'thread',\n\tOUTPUT: 'output',\n\tBREAKPOINT: 'breakpoint'\n};\n\n// model interfaces\n\nexport interface IViewModel extends ee.EventEmitter {\n\tgetFocusedStackFrame(): IStackFrame;\n\tgetSelectedExpression(): IExpression;\n\tgetFocusedThreadId(): number;\n\tsetSelectedExpression(expression: IExpression);\n\tgetSelectedFunctionBreakpoint(): IFunctionBreakpoint;\n\tsetSelectedFunctionBreakpoint(functionBreakpoint: IFunctionBreakpoint): void;\n}\n\nexport interface IModel extends ee.IEventEmitter, ITreeElement {\n\tgetThreads(): { [threadId: number]: IThread; };\n\tgetBreakpoints(): IBreakpoint[];\n\tareBreakpointsActivated(): boolean;\n\tgetFunctionBreakpoints(): IFunctionBreakpoint[];\n\tgetExceptionBreakpoints(): IExceptionBreakpoint[];\n\tgetWatchExpressions(): IExpression[];\n\tgetReplElements(): ITreeElement[];\n}\n\n// service enums\n\nexport enum State {\n\tDisabled,\n\tInactive,\n\tInitializing,\n\tStopped,\n\tRunning,\n\tRunningNoDebug\n}\n\n// service interfaces\n\nexport interface IGlobalConfig {\n\tversion: string;\n\tdebugServer?: number;\n\tconfigurations: IConfig[];\n}\n\nexport interface IConfig {\n\tname?: string;\n\ttype: string;\n\trequest: string;\n\tprogram?: string;\n\tstopOnEntry?: boolean;\n\targs?: string[];\n\tcwd?: string;\n\truntimeExecutable?: string;\n\truntimeArgs?: string[];\n\tenv?: { [key: string]: string; };\n\tsourceMaps?: boolean;\n\toutDir?: string;\n\taddress?: string;\n\tport?: number;\n\tpreLaunchTask?: string;\n\texternalConsole?: boolean;\n\tdebugServer?: number;\n\tnoDebug?: boolean;\n}\n\nexport interface IRawEnvAdapter {\n\ttype?: string;\n\tlabel?: string;\n\tprogram?: string;\n\targs?: string[];\n\truntime?: string;\n\truntimeArgs?: string[];\n}\n\nexport interface IRawAdapter extends IRawEnvAdapter {\n\tenableBreakpointsFor?: { languageIds: string[] };\n\tconfigurationAttributes?: any;\n\tinitialConfigurations?: any[];\n\taiKey?: string;\n\twin?: IRawEnvAdapter;\n\twinx86?: IRawEnvAdapter;\n\twindows?: IRawEnvAdapter;\n\tosx?: IRawEnvAdapter;\n\tlinux?: IRawEnvAdapter;\n}\n\nexport interface IRawDebugSession extends ee.EventEmitter {\n\tgetType(): string;\n\tisAttach: boolean;\n\tcapabilities: DebugProtocol.Capabilites;\n\tdisconnect(restart?: boolean, force?: boolean): TPromise<DebugProtocol.DisconnectResponse>;\n\n\tnext(args: DebugProtocol.NextArguments): TPromise<DebugProtocol.NextResponse>;\n\tstepIn(args: DebugProtocol.StepInArguments): TPromise<DebugProtocol.StepInResponse>;\n\tstepOut(args: DebugProtocol.StepOutArguments): TPromise<DebugProtocol.StepOutResponse>;\n\tcontinue(args: DebugProtocol.ContinueArguments): TPromise<DebugProtocol.ContinueResponse>;\n\tpause(args: DebugProtocol.PauseArguments): TPromise<DebugProtocol.PauseResponse>;\n\n\tstackTrace(args: DebugProtocol.StackTraceArguments): TPromise<DebugProtocol.StackTraceResponse>;\n\tscopes(args: DebugProtocol.ScopesArguments): TPromise<DebugProtocol.ScopesResponse>;\n\tvariables(args: DebugProtocol.VariablesArguments): TPromise<DebugProtocol.VariablesResponse>;\n\tevaluate(args: DebugProtocol.EvaluateArguments): TPromise<DebugProtocol.EvaluateResponse>;\n}\n\nexport var IDebugService = createDecorator<IDebugService>(DEBUG_SERVICE_ID);\n\nexport interface IDebugService extends ee.IEventEmitter {\n\tserviceId: ServiceIdentifier<any>;\n\tgetState(): State;\n\tcanSetBreakpointsIn(model: editor.IModel): boolean;\n\n\tgetConfigurationName(): string;\n\tsetConfiguration(name: string): TPromise<void>;\n\topenConfigFile(sideBySide: boolean): TPromise<boolean>;\n\tloadLaunchConfig(): TPromise<IGlobalConfig>;\n\n\tsetFocusedStackFrameAndEvaluate(focusedStackFrame: IStackFrame): void;\n\n\t/**\n\t * Sets breakpoints for a model. Does not send them to the adapter.\n\t */\n\tsetBreakpointsForModel(modelUri: uri, rawData: IRawBreakpoint[]): void;\n\ttoggleBreakpoint(IRawBreakpoint): TPromise<void>;\n\tenableOrDisableAllBreakpoints(enabled: boolean): TPromise<void>;\n\ttoggleEnablement(element: IEnablement): TPromise<void>;\n\ttoggleBreakpointsActivated(): TPromise<void>;\n\tremoveAllBreakpoints(): TPromise<any>;\n\tsendAllBreakpoints(): TPromise<any>;\n\teditBreakpoint(editor: editorbrowser.ICodeEditor, lineNumber: number): TPromise<void>;\n\n\taddFunctionBreakpoint(): void;\n\trenameFunctionBreakpoint(id: string, newFunctionName: string): TPromise<void>;\n\tremoveFunctionBreakpoints(id?: string): TPromise<void>;\n\n\taddReplExpression(name: string): TPromise<void>;\n\tclearReplExpressions(): void;\n\n\tlogToRepl(value: string, severity?: severity): void;\n\tlogToRepl(value: { [key: string]: any }, severity?: severity): void;\n\n\tappendReplOutput(value: string, severity?: severity): void;\n\n\taddWatchExpression(name?: string): TPromise<void>;\n\trenameWatchExpression(id: string, newName: string): TPromise<void>;\n\tclearWatchExpressions(id?: string): void;\n\n\t/**\n\t * Creates a new debug session. Depending on the configuration will either 'launch' or 'attach'.\n\t */\n\tcreateSession(noDebug: boolean): TPromise<any>;\n\n\t/**\n\t * Restarts an active debug session or creates a new one if there is no active session.\n\t */\n\trestartSession(): TPromise<any>;\n\n\t/**\n\t * Returns the active debug session or null if debug is inactive.\n\t */\n\tgetActiveSession(): IRawDebugSession;\n\n\t/**\n\t * Gets the current debug model.\n\t */\n\tgetModel(): IModel;\n\n\t/**\n\t * Gets the current view model.\n\t */\n\tgetViewModel(): IViewModel;\n\n\t/**\n\t * Opens a new or reveals an already visible editor showing the source.\n\t */\n\topenOrRevealEditor(source: Source, lineNumber: number, preserveFocus: boolean, sideBySide: boolean): TPromise<any>;\n\n\t/**\n\t * Reveals the repl.\n\t */\n\trevealRepl(focus?: boolean): TPromise<void>;\n}\n\n// Editor interfaces\nexport interface IDebugEditorContribution extends editor.IEditorContribution {\n\tshowHover(range: editor.IEditorRange, hoveringOver: string, focus: boolean): TPromise<void>;\n}\n\n// Debug view registration\n\nexport interface IDebugViewConstructorSignature {\n\tnew (actionRunner: IActionRunner, viewletSetings: any, ...services: { serviceId: ServiceIdentifier<any>; }[]): IViewletView;\n}\n\nexport interface IDebugViewRegistry {\n\tregisterDebugView(view: IDebugViewConstructorSignature, order: number): void;\n\tgetDebugViews(): IDebugViewConstructorSignature[];\n}\n\nclass DebugViewRegistryImpl implements IDebugViewRegistry {\n\tprivate debugViews: { view: IDebugViewConstructorSignature, order: number }[];\n\n\tconstructor() {\n\t\tthis.debugViews = [];\n\t}\n\n\tpublic registerDebugView(view: IDebugViewConstructorSignature, order: number): void {\n\t\tthis.debugViews.push({ view, order });\n\t}\n\n\tpublic getDebugViews(): IDebugViewConstructorSignature[] {\n\t\treturn this.debugViews.sort((first, second) => first.order - second.order)\n\t\t\t.map(viewWithOrder => viewWithOrder.view);\n\t}\n}\n\nexport var DebugViewRegistry = <IDebugViewRegistry>new DebugViewRegistryImpl();\n\n// utils\n\nconst _formatPIIRegexp = /{([^}]+)}/g;\n\nexport function formatPII(value:string, excludePII: boolean, args: {[key: string]: string}): string {\n\treturn value.replace(_formatPIIRegexp, function(match, group) {\n\t\tif (excludePII && group.length > 0 && group[0] !== '_') {\n\t\t\treturn match;\n\t\t}\n\n\t\treturn args && args.hasOwnProperty(group) ?\n\t\t\targs[group] :\n\t\t\tmatch;\n\t});\n}\n"]}