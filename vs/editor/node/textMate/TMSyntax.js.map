{"version":3,"sources":["vs/editor/node/textMate/TMSyntax.ts"],"names":[],"mappings":"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","file":"vs/editor/node/textMate/TMSyntax.js","sourceRoot":"file:///Users/darrin/src/vscode/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as nls from 'vs/nls';\nimport {onUnexpectedError} from 'vs/base/common/errors';\nimport * as paths from 'vs/base/common/paths';\nimport {IExtensionMessageCollector, ExtensionsRegistry} from 'vs/platform/extensions/common/extensionsRegistry';\nimport {ILineTokens, IMode, ITokenizationSupport} from 'vs/editor/common/modes';\nimport {TMState} from 'vs/editor/common/modes/TMState';\nimport {LineTokens, Token} from 'vs/editor/common/modes/supports';\nimport {IModeService} from 'vs/editor/common/services/modeService';\nimport {IGrammar, Registry} from 'vscode-textmate';\nimport {ModeTransition} from 'vs/editor/common/core/modeTransition';\n\nexport interface ITMSyntaxExtensionPoint {\n\tlanguage: string;\n\tscopeName: string;\n\tpath: string;\n}\n\nlet grammarsExtPoint = ExtensionsRegistry.registerExtensionPoint<ITMSyntaxExtensionPoint[]>('grammars', {\n\tdescription: nls.localize('vscode.extension.contributes.grammars', 'Contributes textmate tokenizers.'),\n\ttype: 'array',\n\tdefaultSnippets: [ { body: [{ id: '', extensions: [] }] }],\n\titems: {\n\t\ttype: 'object',\n\t\tdefaultSnippets: [ { body: { language: '{{id}}', scopeName: 'source.{{id}}', path: './syntaxes/{{id}}.tmLanguage.'} }],\n\t\tproperties: {\n\t\t\tlanguage: {\n\t\t\t\tdescription: nls.localize('vscode.extension.contributes.grammars.language', 'Language id for which this syntax is contributed to.'),\n\t\t\t\ttype: 'string'\n\t\t\t},\n\t\t\tscopeName: {\n\t\t\t\tdescription: nls.localize('vscode.extension.contributes.grammars.scopeName', 'Textmate scope name used by the tmLanguage file.'),\n\t\t\t\ttype: 'string'\n\t\t\t},\n\t\t\tpath: {\n\t\t\t\tdescription: nls.localize('vscode.extension.contributes.grammars.path', 'Path of the tmLanguage file. The path is relative to the extension folder and typically starts with \\'./syntaxes/\\'.'),\n\t\t\t\ttype: 'string'\n\t\t\t}\n\t\t}\n\t}\n});\n\nexport class MainProcessTextMateSyntax {\n\tprivate _grammarRegistry: Registry;\n\tprivate _modeService: IModeService;\n\tprivate _scopeNameToFilePath: { [scopeName:string]: string; };\n\n\tconstructor(\n\t\t@IModeService modeService: IModeService\n\t) {\n\t\tthis._modeService = modeService;\n\t\tthis._grammarRegistry = new Registry({\n\t\t\tgetFilePath: (scopeName:string) => {\n\t\t\t\treturn this._scopeNameToFilePath[scopeName];\n\t\t\t}\n\t\t});\n\t\tthis._scopeNameToFilePath = {};\n\n\t\tgrammarsExtPoint.setHandler((extensions) => {\n\t\t\tfor (let i = 0; i < extensions.length; i++) {\n\t\t\t\tlet grammars = extensions[i].value;\n\t\t\t\tfor (let j = 0; j < grammars.length; j++) {\n\t\t\t\t\tthis._handleGrammarExtensionPointUser(extensions[i].description.extensionFolderPath, grammars[j], extensions[i].collector);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _handleGrammarExtensionPointUser(extensionFolderPath:string, syntax:ITMSyntaxExtensionPoint, collector: IExtensionMessageCollector): void {\n\t\tif (syntax.language && ((typeof syntax.language !== 'string') || !this._modeService.isRegisteredMode(syntax.language))) {\n\t\t\tcollector.error(nls.localize('invalid.language', \"Unknown language in `contributes.{0}.language`. Provided value: {1}\", grammarsExtPoint.name, String(syntax.language)));\n\t\t\treturn;\n\t\t}\n\t\tif (!syntax.scopeName || (typeof syntax.scopeName !== 'string')) {\n\t\t\tcollector.error(nls.localize('invalid.scopeName', \"Expected string in `contributes.{0}.scopeName`. Provided value: {1}\", grammarsExtPoint.name, String(syntax.scopeName)));\n\t\t\treturn;\n\t\t}\n\t\tif (!syntax.path || (typeof syntax.path !== 'string')) {\n\t\t\tcollector.error(nls.localize('invalid.path.0', \"Expected string in `contributes.{0}.path`. Provided value: {1}\", grammarsExtPoint.name, String(syntax.path)));\n\t\t\treturn;\n\t\t}\n\t\tlet normalizedAbsolutePath = paths.normalize(paths.join(extensionFolderPath, syntax.path));\n\n\t\tif (normalizedAbsolutePath.indexOf(extensionFolderPath) !== 0) {\n\t\t\tcollector.warn(nls.localize('invalid.path.1', \"Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.\", grammarsExtPoint.name, normalizedAbsolutePath, extensionFolderPath));\n\t\t}\n\n\t\tthis._scopeNameToFilePath[syntax.scopeName] = normalizedAbsolutePath;\n\n\t\tlet modeId = syntax.language;\n\t\tif (modeId) {\n\t\t\tlet disposable = this._modeService.onDidCreateMode((mode) => {\n\t\t\t\tif (mode.getId() !== modeId) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.registerDefinition(modeId, syntax.scopeName);\n\t\t\t\tdisposable.dispose();\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic registerDefinition(modeId: string, scopeName: string): void {\n\t\tthis._grammarRegistry.loadGrammar(scopeName, (err, grammar) => {\n\t\t\tif (err) {\n\t\t\t\tonUnexpectedError(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._modeService.registerTokenizationSupport(modeId, (mode: IMode) => {\n\t\t\t\treturn createTokenizationSupport(mode, grammar);\n\t\t\t});\n\t\t});\n\t}\n}\n\nfunction createTokenizationSupport(mode: IMode, grammar: IGrammar): ITokenizationSupport {\n\tvar tokenizer = new Tokenizer(mode.getId(), grammar);\n\treturn {\n\t\tshouldGenerateEmbeddedModels: false,\n\t\tgetInitialState: () => new TMState(mode, null, null),\n\t\ttokenize: (line, state, offsetDelta?, stopAtOffset?) => tokenizer.tokenize(line, <TMState> state, offsetDelta, stopAtOffset)\n\t};\n}\n\nexport class DecodeMap {\n\t_decodeMapTrait: void;\n\n\tlastAssignedId: number;\n\tscopeToTokenIds: { [scope:string]:number[]; };\n\ttokenToTokenId: { [token:string]:number; };\n\ttokenIdToToken: string[];\n\tprevToken: TMTokenDecodeData;\n\n\tconstructor() {\n\t\tthis.lastAssignedId = 0;\n\t\tthis.scopeToTokenIds = Object.create(null);\n\t\tthis.tokenToTokenId = Object.create(null);\n\t\tthis.tokenIdToToken = [null];\n\t\tthis.prevToken = new TMTokenDecodeData([], []);\n\t}\n\n\tpublic getTokenIds(scope:string): number[] {\n\t\tlet tokens = this.scopeToTokenIds[scope];\n\t\tif (tokens) {\n\t\t\treturn tokens;\n\t\t}\n\t\tlet tmpTokens = scope.split('.');\n\n\t\ttokens = [];\n\t\tfor (let i = 0; i < tmpTokens.length; i++) {\n\t\t\tlet token = tmpTokens[i];\n\t\t\tlet tokenId = this.tokenToTokenId[token];\n\t\t\tif (!tokenId) {\n\t\t\t\ttokenId = (++this.lastAssignedId);\n\t\t\t\tthis.tokenToTokenId[token] = tokenId;\n\t\t\t\tthis.tokenIdToToken[tokenId] = token;\n\t\t\t}\n\t\t\ttokens.push(tokenId);\n\t\t}\n\n\t\tthis.scopeToTokenIds[scope] = tokens;\n\t\treturn tokens;\n\t}\n\n\tpublic getToken(tokenMap:boolean[]): string {\n\t\tlet result = '';\n\t\tlet isFirst = true;\n\t\tfor (let i = 1; i <= this.lastAssignedId; i++) {\n\t\t\tif (tokenMap[i]) {\n\t\t\t\tif (isFirst) {\n\t\t\t\t\tisFirst = false;\n\t\t\t\t\tresult += this.tokenIdToToken[i];\n\t\t\t\t} else {\n\t\t\t\t\tresult += '.';\n\t\t\t\t\tresult += this.tokenIdToToken[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport class TMTokenDecodeData {\n\t_tmTokenDecodeDataTrait: void;\n\n\tpublic scopes: string[];\n\tpublic scopeTokensMaps: boolean[][];\n\n\tconstructor(scopes:string[], scopeTokensMaps:boolean[][]) {\n\t\tthis.scopes = scopes;\n\t\tthis.scopeTokensMaps = scopeTokensMaps;\n\t}\n}\n\nclass Tokenizer {\n\tprivate _grammar: IGrammar;\n\tprivate _modeId: string;\n\tprivate _decodeMap: DecodeMap;\n\n\tconstructor(modeId:string, grammar: IGrammar) {\n\t\tthis._modeId = modeId;\n\t\tthis._grammar = grammar;\n\t\tthis._decodeMap = new DecodeMap();\n\t}\n\n\tpublic tokenize(line: string, state: TMState, offsetDelta: number = 0, stopAtOffset?: number): ILineTokens {\n\t\tif (line.length >= 20000) {\n\t\t\treturn new LineTokens(\n\t\t\t\t[new Token(offsetDelta, '')],\n\t\t\t\t[new ModeTransition(offsetDelta, state.getMode())],\n\t\t\t\toffsetDelta,\n\t\t\t\tstate\n\t\t\t);\n\t\t}\n\t\tlet freshState = state.clone();\n\t\tlet textMateResult = this._grammar.tokenizeLine(line, freshState.getRuleStack());\n\t\tfreshState.setRuleStack(textMateResult.ruleStack);\n\n\t\t// Create the result early and fill in the tokens later\n\t\tlet tokens:Token[] = [];\n\n\t\tlet lastTokenType:string = null;\n\t\tfor (let tokenIndex = 0, len = textMateResult.tokens.length; tokenIndex < len; tokenIndex++) {\n\t\t\tlet token = textMateResult.tokens[tokenIndex];\n\t\t\tlet tokenStartIndex = token.startIndex;\n\t\t\tlet tokenType = decodeTextMateToken(this._decodeMap, token.scopes);\n\n\t\t\t// do not push a new token if the type is exactly the same (also helps with ligatures)\n\t\t\tif (tokenType !== lastTokenType) {\n\t\t\t\ttokens.push(new Token(tokenStartIndex + offsetDelta, tokenType));\n\t\t\t\tlastTokenType = tokenType;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(\n\t\t\ttokens,\n\t\t\t[new ModeTransition(offsetDelta, freshState.getMode())],\n\t\t\toffsetDelta + line.length,\n\t\t\tfreshState\n\t\t);\n\t}\n}\n\nexport function decodeTextMateToken(decodeMap: DecodeMap, scopes: string[]): string {\n\tconst prevTokenScopes = decodeMap.prevToken.scopes;\n\tconst prevTokenScopesLength = prevTokenScopes.length;\n\tconst prevTokenScopeTokensMaps = decodeMap.prevToken.scopeTokensMaps;\n\n\tlet scopeTokensMaps: boolean[][] = [];\n\tlet prevScopeTokensMaps: boolean[] = [];\n\tlet sameAsPrev = true;\n\tfor (let level = 1/* deliberately skip scope 0*/; level < scopes.length; level++) {\n\t\tlet scope = scopes[level];\n\n\t\tif (sameAsPrev) {\n\t\t\tif (level < prevTokenScopesLength && prevTokenScopes[level] === scope) {\n\t\t\t\tprevScopeTokensMaps = prevTokenScopeTokensMaps[level];\n\t\t\t\tscopeTokensMaps[level] = prevScopeTokensMaps;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsameAsPrev = false;\n\t\t}\n\n\t\tlet tokens = decodeMap.getTokenIds(scope);\n\t\tprevScopeTokensMaps = prevScopeTokensMaps.slice(0);\n\t\tfor (let i = 0; i < tokens.length; i++) {\n\t\t\tprevScopeTokensMaps[tokens[i]] = true;\n\t\t}\n\t\tscopeTokensMaps[level] = prevScopeTokensMaps;\n\t}\n\n\tdecodeMap.prevToken = new TMTokenDecodeData(scopes, scopeTokensMaps);\n\treturn decodeMap.getToken(prevScopeTokensMaps);\n}\n"]}