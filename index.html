<!-- Copyright (C) Spiffcode, Inc. All rights reserved. -->
<!-- Copyright (C) Microsoft Corporation. All rights reserved. -->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>GH Code</title>

		<!-- Theming (do not remove, we want to early load it to avoid flashing background) -->
		<style>
			.monaco-shell.vs-dark { background-color: #1E1E1E; }
		</style>

		<!-- Helpers -->
		<script type="text/javascript">
//			var path = require('path');
			var path = {
				resolve: function (partialPath) {
					console.log('path.resolve(' + partialPath + ')');
					return '';
				}
			}
//			var electron = require('electron');
			var globals = {
				globalSettingsValue: undefined,
				programStart: Date.now(),
				vscodeStart: Date.now(),
			};

			var electron = {
				'remote': {
					'getCurrentWindow': function () {
						return {
							'id': 1
						}
					},
					'getGlobal': function (key) {
						return globals[key];
					}
				},
				'ipcRenderer': {
					'send': function (message, value) {
						console.log('ipcRenderer.send: ' + message + ', ' + value);
					}
				}
			};

			var remote = electron.remote;
			var ipc = electron.ipcRenderer;
			var windowId = remote.getCurrentWindow().id;

			function onError(error, enableDeveloperTools) {
				if (enableDeveloperTools) {
					ipc.send('vscode:openDevTools', windowId);
				}

				console.error('[uncaught exception]: ' + error);

				if (error.stack) {
					console.error(error.stack);
				}
			}

			function parseURLQueryArgs() {
				var result = {};
				var search = window.location.search;
				if (search) {
					var params = search.split(/[?&]/);
					for (var i = 0; i < params.length; i++) {
						var param = params[i];
						if (param) {
							var keyValue = param.split('=');
							if (keyValue.length === 2) {
								result[keyValue[0]] = decodeURIComponent(keyValue[1]);
							}
						}
					}
				}

				return result;
			}

			function createScript(src, onload) {
				var script = document.createElement('script');
				script.src = src;
				script.addEventListener('load', onload);

				var head = document.getElementsByTagName('head')[0];
				head.insertBefore(script, head.lastChild);
			}

			function uriFromPath(_path) {
				var pathName = path.resolve(_path).replace(/\\/g, '/');

				if (pathName.length > 0 && pathName.charAt(0) !== '/') {
					pathName = '/' + pathName;
				}

				return encodeURI('file://' + pathName);
			}

			function registerListeners(enableDeveloperTools) {

				// Devtools & reload support
				if (enableDeveloperTools) {
					var extractKey = function(e) {
						return [
							e.ctrlKey ? 'ctrl-' : '',
							e.metaKey ? 'meta-' : '',
							e.altKey ? 'alt-' : '',
							e.shiftKey ? 'shift-' : '',
							e.keyCode
						].join('');
					};

					var TOGGLE_DEV_TOOLS_KB = (process.platform === 'darwin' ? 'meta-alt-73' : 'ctrl-shift-73'); // mac: Cmd-Alt-I, rest: Ctrl-Shift-I
					var RELOAD_KB = (process.platform === 'darwin' ? 'meta-82' : 'ctrl-82'); // mac: Cmd-R, rest: Ctrl-R

					window.addEventListener('keydown', function(e) {
						var key = extractKey(e);
						if (key === TOGGLE_DEV_TOOLS_KB) {
							ipc.send('vscode:toggleDevTools', windowId);
						} else if (key === RELOAD_KB) {
							ipc.send('vscode:reloadWindow', windowId);
						}
					});
				}

				process.on('uncaughtException', function(error) { onError(error, enableDeveloperTools) });
			}
		</script>

		<!-- Startup Code -->
		<script type="text/javascript">
// TODO:			var webFrame = require('electron').webFrame;
			var webFrame = {
				setZoomLevelLimits: function (min, max) { console.log('webFrame.setZoomLevelLimits'); },
				setZoomLevel: function (level) { console.log('webFrame.setZoomLevel'); }
			};
			/* TODO:
			var process = {
				env: { },
				platform: 'darwin', // TODO: check actual platform
				on: function (event, handler) {
					// TODO: onerror for uncaughtException?
					console.log('add process.on(\'' + event + '\') handler');
				},
			};
			 */

			var mainStarted = false;
			var args = parseURLQueryArgs(); // TODO: really they pass a giant config={...} argument?
//			args.config = '{ "userEnv": { "githubUsername": "darrinm", "githubPassword": "<secret>" }, "appSettingsPath": "/", "appSettingsHome": ".settings" }';
			args.config = '{ "userEnv": {}, "appSettingsPath": "/", "appSettingsHome": ".settings" }';
			var configuration = JSON.parse(args['config']);
			configuration.workspacePath = args.workspacePath;
			if (args.repo) {
				configuration.githubRepo = args.repo;
				configuration.workspacePath = '/';
			}
			configuration.githubRef = args.ref || 'master';
			if (args.u)
				configuration.userEnv.githubUsername = args.u;
			if (args.p)
				configuration.userEnv.githubPassword = args.p;
			var enableDeveloperTools = !configuration.isBuilt || !!configuration.extensionDevelopmentPath;

// TODO:			process.env['VSCODE_SHARED_IPC_HOOK'] = configuration.sharedIPCHandle;
			// Get the nls configuration into the process.env as early as possible.
			if (configuration.userEnv && configuration.userEnv['VSCODE_NLS_CONFIG']) {
// TODO:				process.env['VSCODE_NLS_CONFIG'] = configuration.userEnv['VSCODE_NLS_CONFIG'];
			}

// TODO:			registerListeners(enableDeveloperTools);

			// We get the global settings through a remote call from the browser
			// because its value can change dynamically.
			var globalSettings;
			var globalSettingsValue = remote.getGlobal('globalSettingsValue');
			if (globalSettingsValue) {
				globalSettings = JSON.parse(globalSettingsValue);
			} else {
				globalSettings = {
					settings: {},
					keybindings: []
				};
			}

			// disable pinch zoom & apply zoom level early to avoid glitches
			var windowConfiguration = globalSettings.settings && globalSettings.settings.window;
			webFrame.setZoomLevelLimits(1, 1);
			if (windowConfiguration && typeof windowConfiguration.zoomLevel === 'number' && windowConfiguration.zoomLevel !== 0) {
				webFrame.setZoomLevel(windowConfiguration.zoomLevel);
			}

			// Load the loader and start loading the workbench
// TODO:			var rootUrl = uriFromPath(configuration.appRoot) + '/out';
			var rootUrl = window.location.pathname == '/ghcode/' ? '/ghcode' : '/out-build';
			// In the bundled version the nls plugin is packaged with the loader so the NLS Plugins
			// loads as soon as the loader loads. To be able to have pseudo translation
			createScript(rootUrl + '/vs/loader.js', function() {
				var nlsConfig;
				try {
					// TODO: var config = process.env['VSCODE_NLS_CONFIG'];
					var config = null;
					if (config) {
						nlsConfig = JSON.parse(config);
					}
				} catch (e) {
				}
				if (!nlsConfig) {
					nlsConfig = { availableLanguages: {} };
				}
				require.config({
					baseUrl: rootUrl,
					'vs/nls': nlsConfig,
					recordStats: configuration.enablePerformance
				});
				if (nlsConfig.pseudo) {
					require(['vs/nls'], function(nlsPlugin) {
						nlsPlugin.setPseudoTranslation(nlsConfig.pseudo);
					});
				}

				var hasWorkspaceContext = configuration.workspacePath;

				window.GlobalEnvironment = {
					'enableTasks': hasWorkspaceContext,
					'enableSendASmile' : !!configuration.sendASmile
				};

				var timers = window.GlobalEnvironment.timers = {
					start: new Date()
				};

				if (configuration.enablePerformance) {
					var programStart = remote.getGlobal('programStart');
					var vscodeStart = remote.getGlobal('vscodeStart');

					if (programStart) {
						timers.beforeProgram = new Date(programStart);
						timers.afterProgram = new Date(vscodeStart);
					}

					timers.vscodeStart = new Date(vscodeStart);
					timers.start = new Date(programStart || vscodeStart);
				}

				timers.beforeLoad = new Date();

				require([
					'forked/workbench.main',
					'lib/github',
					'vs/nls!vs/workbench/workbench.main',
					'vs/css!vs/workbench/workbench.main'
				], function() {
					timers.afterLoad = new Date();

					var main = require('forked/main');
					main.startup(configuration, globalSettings).then(function() {
						mainStarted = true;
					}, function(error) { onError(error, enableDeveloperTools) });
				});
			});

		</script>
	</head>
	<body class="monaco-shell vs-dark" aria-label=""> <!-- setting aria label to empty here seems to prevent NVDA from reading the full URL of the application on start/reload -->
		<script>
			(function() {
				try {
					var theme = window.localStorage.getItem('storage://global/workbench.theme');
					if (theme && theme.indexOf('vs-dark') < 0) {
						window.document.body.className = 'monaco-shell'; // remove the dark theme class if we are on a light theme
					}
				} catch (error) {
					console.error(error);
				}
			})();
		</script>
	</body>
</html>
