<!-- Copyright (C) Spiffcode, Inc. All rights reserved. -->
<!-- Copyright (C) Microsoft Corporation. All rights reserved. -->
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>GH Code</title>

		<!-- Theming (do not remove, we want to early load it to avoid flashing background) -->
		<style>
			.monaco-shell.vs-dark { background-color: #1E1E1E; }
		</style>

		<!-- Helpers -->
		<script type="text/javascript">
//			var path = require('path');
			var path = {
				resolve: function (partialPath) {
					console.log('path.resolve(' + partialPath + ')');
					return '';
				}
			}
//			var electron = require('electron');
			var globals = {
				globalSettingsValue: undefined,
				programStart: Date.now(),
				vscodeStart: Date.now(),
			};

			var electron = {
				'remote': {
					'getCurrentWindow': function () {
						return {
							'id': 1
						}
					},
					'getGlobal': function (key) {
						return globals[key];
					}
				},
				'ipcRenderer': {
					'send': function (message, value) {
						console.log('ipcRenderer.send: ' + message + ', ' + value);
					}
				}
			};

			var remote = electron.remote;
			var ipc = electron.ipcRenderer;
			var windowId = remote.getCurrentWindow().id;

			function onError(error, enableDeveloperTools) {
				if (enableDeveloperTools) {
					ipc.send('vscode:openDevTools', windowId);
				}

				console.error('[uncaught exception]: ' + error);

				if (error.stack) {
					console.error(error.stack);
				}
			}

			function parseURLQueryArgs() {
				var result = {};
				var search = window.location.search;
				if (search) {
					var params = search.split(/[?&]/);
					for (var i = 0; i < params.length; i++) {
						var param = params[i];
						if (param) {
							var keyValue = param.split('=');
							if (keyValue.length === 2) {
								result[keyValue[0]] = decodeURIComponent(keyValue[1]);
							}
						}
					}
				}

				return result;
			}

			function createScript(src, onload) {
				var script = document.createElement('script');
				script.src = src;
				script.addEventListener('load', onload);

				var head = document.getElementsByTagName('head')[0];
				head.insertBefore(script, head.lastChild);
			}

			function uriFromPath(_path) {
				var pathName = path.resolve(_path).replace(/\\/g, '/');

				if (pathName.length > 0 && pathName.charAt(0) !== '/') {
					pathName = '/' + pathName;
				}

				return encodeURI('file://' + pathName);
			}

			function registerListeners(enableDeveloperTools) {

				// Devtools & reload support
				if (enableDeveloperTools) {
					var extractKey = function(e) {
						return [
							e.ctrlKey ? 'ctrl-' : '',
							e.metaKey ? 'meta-' : '',
							e.altKey ? 'alt-' : '',
							e.shiftKey ? 'shift-' : '',
							e.keyCode
						].join('');
					};

					var TOGGLE_DEV_TOOLS_KB = (process.platform === 'darwin' ? 'meta-alt-73' : 'ctrl-shift-73'); // mac: Cmd-Alt-I, rest: Ctrl-Shift-I
					var RELOAD_KB = (process.platform === 'darwin' ? 'meta-82' : 'ctrl-82'); // mac: Cmd-R, rest: Ctrl-R

					window.addEventListener('keydown', function(e) {
						var key = extractKey(e);
						if (key === TOGGLE_DEV_TOOLS_KB) {
							ipc.send('vscode:toggleDevTools', windowId);
						} else if (key === RELOAD_KB) {
							ipc.send('vscode:reloadWindow', windowId);
						}
					});
				}

				process.on('uncaughtException', function(error) { onError(error, enableDeveloperTools) });
			}
		</script>

		<!-- Startup Code -->
		<script type="text/javascript">
// TODO:			var webFrame = require('electron').webFrame;
			var webFrame = {
				setZoomLevelLimits: function (min, max) { console.log('webFrame.setZoomLevelLimits'); },
				setZoomLevel: function (level) { console.log('webFrame.setZoomLevel'); }
			};

			var mainStarted = false;
			var args = parseURLQueryArgs(); // TODO: really they pass a giant config={...} argument?

			if (args.code) {
				// Ask our auth server to ask for a GitHub access token and redirect with it back to here.
				var xhr = new XMLHttpRequest();
				// TODO: timeout, retry, etc
				xhr.open('POST', 'https://jasper-rider.hyperdev.space/ghauth?code=' + args.code);
				xhr.onload = function (e) {
					if (this.status == 200) {
						var result = {};
						var params = this.responseText.split(/[?&]/);
						for (var i = 0; i < params.length; i++) {
							var param = params[i];
							if (param) {
								var keyValue = param.split('=');
								if (keyValue.length === 2) {
									result[keyValue[0]] = decodeURIComponent(keyValue[1]);
								}
							}
						}
						if (result.access_token) {
							// Retain the access token in local storage for future use.
							window.localStorage.setItem('githubToken', result.access_token);

							startup2(args);

						} else if (result.error) {
							var error = result.error + ': ' + decodeURIComponent(result.error_description.replace(/\+/g, '%20'))
							document.write(error);
							console.log(error);
						}
					}
				}
				xhr.send();
				document.write('Authorizing...');

/* This is the authorization server code:

var https = require('https');
var express = require('express');
var app = express();

app.use(express.static('public'));
app.use(allowCrossDomain);

function allowCrossDomain(req, res, next) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');

  if (req.method == 'OPTIONS') {
    res.send(200);
  } else {
    next();
  }
}

app.post("/ghauth", function (request, response) {
  console.log('ghauth ' + JSON.stringify(request.headers));
  var localhost = request.headers.origin ? (request.headers.origin.indexOf('localhost') != -1) : false;
  console.log('localhost: ' + localhost);
  var client = 'client_id=' + (localhost ? process.env.LOCALHOST_CLIENT_ID : process.env.GITHUB_CLIENT_ID) + 
      '&client_secret=' + (localhost ? process.env.LOCALHOST_CLIENT_SECRET : process.env.GITHUB_CLIENT_SECRET);
  var options = {
    hostname: 'github.com', port: 443, method: 'POST',
    path: '/login/oauth/access_token?' + client + '&code=' + request.query.code
  };
  var req = https.request(options, function(res) {
    console.log('Status: ' + res.statusCode);
    res.setEncoding('utf8');
    res.on('data', function (body) {
      console.log('Body: ' + body);
      response.statusCode = res.statusCode;
      response.statusMessage = res.statusMessage;
      response.end(body);
    });
  });
  req.on('error', function(e) {
    console.log('problem with request: ' + e.message);
    response.sendStatus(res.statusCode);
  });
  req.end();
});
*/

			} else {
				startup2(args);
			}

			function startup2(args) {
				args.config = '{ "userEnv": {}, "appSettingsPath": "/$gist/GHCode Settings/settings.json", "appKeybindingsPath": "/$gist/GHCode Settings/keybindings.json", "appSettingsHome": "/$gist/GHCode Settings" }';
				var configuration = JSON.parse(args['config']);
				configuration.gistRegEx = /^\/\$gist\/.+.*\/.+.*$/;
				configuration.workspacePath = args.workspacePath;

				// If there's no repo in the URL, look in sessionStorage, then localStorage
				if (!args.repo) {
					args.repo = window.sessionStorage.getItem('githubRepo');
					args.ref = window.sessionStorage.getItem('githubRef');
					if (!args.repo) {
						args.repo = window.localStorage.getItem('lastGithubRepo');
						args.ref = window.localStorage.getItem('lastGithubRef');
					}
				}

				// Clear "code=" and any other unneeded args out of the URL and show the active repo and ref.
				var selfURL = location.origin + location.pathname;
				window.history.replaceState(null, '', selfURL + (args.repo ? '?repo=' + args.repo + (args.ref ? '&ref=' + args.ref : '') : ''));

				// If a repo is specified and the user has been authorized, configure the workspace
				// to use it and persist in local/session storage for parameterless reloads.
				if (args.repo) {
					configuration.githubRepo = args.repo;
					configuration.githubRef = args.ref || 'master';
					configuration.workspacePath = '/';
					window.localStorage.setItem('lastGithubRepo', configuration.githubRepo);
					window.localStorage.setItem('lastGithubRef', configuration.githubRef);
					window.sessionStorage.setItem('githubRepo', configuration.githubRepo);
					window.sessionStorage.setItem('githubRef', configuration.githubRef);
				}

				configuration.userEnv.githubToken = window.localStorage.getItem('githubToken');
				if (args.u)
					configuration.userEnv.githubUsername = args.u;
				if (args.p)
					configuration.userEnv.githubPassword = args.p;
				if (args.t)
					configuration.userEnv.githubToken = args.t;
				if (configuration.userEnv.githubToken !== null)
					window.localStorage.setItem('githubToken', configuration.userEnv.githubToken);
				var enableDeveloperTools = !configuration.isBuilt || !!configuration.extensionDevelopmentPath;

	// TODO:			process.env['VSCODE_SHARED_IPC_HOOK'] = configuration.sharedIPCHandle;
				// Get the nls configuration into the process.env as early as possible.
				if (configuration.userEnv && configuration.userEnv['VSCODE_NLS_CONFIG']) {
	// TODO:				process.env['VSCODE_NLS_CONFIG'] = configuration.userEnv['VSCODE_NLS_CONFIG'];
				}

	// TODO:			registerListeners(enableDeveloperTools);

				// We get the global settings through a remote call from the browser
				// because its value can change dynamically.
				var globalSettings;
				var globalSettingsValue = remote.getGlobal('globalSettingsValue');
				if (globalSettingsValue) {
					globalSettings = JSON.parse(globalSettingsValue);
				} else {
					globalSettings = {
						settings: {},
						keybindings: []
					};
				}

				// disable pinch zoom & apply zoom level early to avoid glitches
				var windowConfiguration = globalSettings.settings && globalSettings.settings.window;
				webFrame.setZoomLevelLimits(1, 1);
				if (windowConfiguration && typeof windowConfiguration.zoomLevel === 'number' && windowConfiguration.zoomLevel !== 0) {
					webFrame.setZoomLevel(windowConfiguration.zoomLevel);
				}

				// Load the loader and start loading the workbench
	// TODO:			var rootUrl = uriFromPath(configuration.appRoot) + '/out';
				var rootUrl = window.location.pathname == '/ghcode/' ? '/ghcode' : '/out-build';
				// In the bundled version the nls plugin is packaged with the loader so the NLS Plugins
				// loads as soon as the loader loads. To be able to have pseudo translation
				createScript(rootUrl + '/vs/loader.js', function() {
					var nlsConfig;
					try {
						// TODO: var config = process.env['VSCODE_NLS_CONFIG'];
						var config = null;
						if (config) {
							nlsConfig = JSON.parse(config);
						}
					} catch (e) {
					}
					if (!nlsConfig) {
						nlsConfig = { availableLanguages: {} };
					}
					require.config({
						baseUrl: rootUrl,
						'vs/nls': nlsConfig,
						recordStats: configuration.enablePerformance
					});
					if (nlsConfig.pseudo) {
						require(['vs/nls'], function(nlsPlugin) {
							nlsPlugin.setPseudoTranslation(nlsConfig.pseudo);
						});
					}

					var hasWorkspaceContext = configuration.workspacePath;

					window.GlobalEnvironment = {
						'enableTasks': hasWorkspaceContext,
						'enableSendASmile' : !!configuration.sendASmile
					};

					var timers = window.GlobalEnvironment.timers = {
						start: new Date()
					};

					if (configuration.enablePerformance) {
						var programStart = remote.getGlobal('programStart');
						var vscodeStart = remote.getGlobal('vscodeStart');

						if (programStart) {
							timers.beforeProgram = new Date(programStart);
							timers.afterProgram = new Date(vscodeStart);
						}

						timers.vscodeStart = new Date(vscodeStart);
						timers.start = new Date(programStart || vscodeStart);
					}

					timers.beforeLoad = new Date();

					require([
						'forked/workbench.main',
						'lib/github',
						'vs/nls!vs/workbench/workbench.main',
						'vs/css!vs/workbench/workbench.main'
					], function() {
						timers.afterLoad = new Date();

						var main = require('forked/main');
						main.startup(configuration, globalSettings).then(function() {
							mainStarted = true;
						}, function(error) { onError(error, enableDeveloperTools) });
					});
				});
			}

		</script>
	</head>
	<body class="monaco-shell vs-dark" aria-label=""> <!-- setting aria label to empty here seems to prevent NVDA from reading the full URL of the application on start/reload -->
		<script>
			(function() {
				try {
					var theme = window.localStorage.getItem('storage://global/workbench.theme');
					if (theme && theme.indexOf('vs-dark') < 0) {
						window.document.body.className = 'monaco-shell'; // remove the dark theme class if we are on a light theme
					}
				} catch (error) {
					console.error(error);
				}
			})();
		</script>
	</body>
</html>
